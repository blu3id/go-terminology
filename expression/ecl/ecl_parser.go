// Code generated from ECL.g4 by ANTLR 4.7.2. DO NOT EDIT.

package ecl // ECL
import (
	"fmt"
	"reflect"
	"strconv"

	"github.com/antlr/antlr4/runtime/Go/antlr"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = reflect.Copy
var _ = strconv.Itoa

var parserATN = []uint16{
	3, 24715, 42794, 33075, 47597, 16764, 15335, 30598, 22884, 3, 215, 742,
	4, 2, 9, 2, 4, 3, 9, 3, 4, 4, 9, 4, 4, 5, 9, 5, 4, 6, 9, 6, 4, 7, 9, 7,
	4, 8, 9, 8, 4, 9, 9, 9, 4, 10, 9, 10, 4, 11, 9, 11, 4, 12, 9, 12, 4, 13,
	9, 13, 4, 14, 9, 14, 4, 15, 9, 15, 4, 16, 9, 16, 4, 17, 9, 17, 4, 18, 9,
	18, 4, 19, 9, 19, 4, 20, 9, 20, 4, 21, 9, 21, 4, 22, 9, 22, 4, 23, 9, 23,
	4, 24, 9, 24, 4, 25, 9, 25, 4, 26, 9, 26, 4, 27, 9, 27, 4, 28, 9, 28, 4,
	29, 9, 29, 4, 30, 9, 30, 4, 31, 9, 31, 4, 32, 9, 32, 4, 33, 9, 33, 4, 34,
	9, 34, 4, 35, 9, 35, 4, 36, 9, 36, 4, 37, 9, 37, 4, 38, 9, 38, 4, 39, 9,
	39, 4, 40, 9, 40, 4, 41, 9, 41, 4, 42, 9, 42, 4, 43, 9, 43, 4, 44, 9, 44,
	4, 45, 9, 45, 4, 46, 9, 46, 4, 47, 9, 47, 4, 48, 9, 48, 4, 49, 9, 49, 4,
	50, 9, 50, 4, 51, 9, 51, 4, 52, 9, 52, 4, 53, 9, 53, 4, 54, 9, 54, 4, 55,
	9, 55, 4, 56, 9, 56, 4, 57, 9, 57, 4, 58, 9, 58, 4, 59, 9, 59, 4, 60, 9,
	60, 4, 61, 9, 61, 4, 62, 9, 62, 4, 63, 9, 63, 4, 64, 9, 64, 4, 65, 9, 65,
	4, 66, 9, 66, 4, 67, 9, 67, 4, 68, 9, 68, 4, 69, 9, 69, 4, 70, 9, 70, 4,
	71, 9, 71, 4, 72, 9, 72, 4, 73, 9, 73, 4, 74, 9, 74, 4, 75, 9, 75, 3, 2,
	3, 2, 3, 2, 3, 2, 3, 2, 5, 2, 156, 10, 2, 3, 2, 3, 2, 3, 3, 3, 3, 3, 3,
	3, 3, 3, 3, 3, 3, 3, 4, 3, 4, 3, 4, 5, 4, 169, 10, 4, 3, 5, 3, 5, 3, 5,
	3, 5, 3, 5, 3, 5, 6, 5, 177, 10, 5, 13, 5, 14, 5, 178, 3, 6, 3, 6, 3, 6,
	3, 6, 3, 6, 3, 6, 6, 6, 187, 10, 6, 13, 6, 14, 6, 188, 3, 7, 3, 7, 3, 7,
	3, 7, 3, 7, 3, 7, 3, 8, 3, 8, 3, 8, 3, 8, 6, 8, 201, 10, 8, 13, 8, 14,
	8, 202, 3, 9, 3, 9, 3, 9, 3, 9, 3, 10, 3, 10, 3, 10, 5, 10, 212, 10, 10,
	3, 10, 3, 10, 3, 10, 5, 10, 217, 10, 10, 3, 10, 3, 10, 3, 10, 3, 10, 3,
	10, 3, 10, 3, 10, 5, 10, 226, 10, 10, 3, 11, 3, 11, 5, 11, 230, 10, 11,
	3, 12, 3, 12, 3, 13, 3, 13, 3, 14, 3, 14, 3, 14, 3, 14, 3, 14, 3, 14, 3,
	14, 3, 14, 5, 14, 244, 10, 14, 3, 15, 3, 15, 3, 16, 6, 16, 249, 10, 16,
	13, 16, 14, 16, 250, 3, 16, 6, 16, 254, 10, 16, 13, 16, 14, 16, 255, 3,
	16, 6, 16, 259, 10, 16, 13, 16, 14, 16, 260, 7, 16, 263, 10, 16, 12, 16,
	14, 16, 266, 11, 16, 3, 17, 3, 17, 3, 18, 3, 18, 3, 18, 3, 18, 3, 18, 3,
	18, 5, 18, 276, 10, 18, 3, 19, 3, 19, 3, 20, 3, 20, 3, 20, 3, 21, 3, 21,
	3, 21, 3, 22, 3, 22, 3, 23, 3, 23, 3, 23, 3, 24, 3, 24, 3, 24, 3, 25, 3,
	25, 3, 25, 3, 25, 3, 25, 5, 25, 299, 10, 25, 3, 26, 3, 26, 3, 26, 3, 26,
	3, 27, 3, 27, 3, 27, 3, 27, 3, 27, 3, 27, 3, 27, 3, 28, 3, 28, 3, 28, 3,
	28, 5, 28, 316, 10, 28, 3, 29, 3, 29, 3, 29, 3, 29, 3, 29, 6, 29, 323,
	10, 29, 13, 29, 14, 29, 324, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 6, 30,
	332, 10, 30, 13, 30, 14, 30, 333, 3, 31, 3, 31, 3, 31, 3, 31, 3, 31, 3,
	31, 3, 31, 3, 31, 5, 31, 344, 10, 31, 3, 32, 3, 32, 3, 32, 3, 32, 5, 32,
	350, 10, 32, 3, 33, 3, 33, 3, 33, 3, 33, 3, 33, 6, 33, 357, 10, 33, 13,
	33, 14, 33, 358, 3, 34, 3, 34, 3, 34, 3, 34, 3, 34, 6, 34, 366, 10, 34,
	13, 34, 14, 34, 367, 3, 35, 3, 35, 3, 35, 3, 35, 3, 35, 3, 35, 3, 35, 5,
	35, 377, 10, 35, 3, 36, 3, 36, 3, 36, 3, 36, 3, 36, 5, 36, 384, 10, 36,
	3, 36, 3, 36, 3, 36, 3, 36, 3, 36, 3, 36, 3, 37, 3, 37, 3, 37, 3, 37, 3,
	37, 5, 37, 397, 10, 37, 3, 37, 3, 37, 3, 37, 5, 37, 402, 10, 37, 3, 37,
	3, 37, 3, 37, 3, 37, 3, 37, 3, 37, 3, 37, 3, 37, 3, 37, 3, 37, 3, 37, 3,
	37, 3, 37, 3, 37, 3, 37, 3, 37, 3, 37, 5, 37, 421, 10, 37, 3, 38, 3, 38,
	3, 38, 3, 38, 3, 39, 3, 39, 3, 40, 3, 40, 3, 40, 3, 41, 3, 41, 5, 41, 434,
	10, 41, 3, 42, 3, 42, 3, 43, 3, 43, 3, 44, 3, 44, 3, 45, 3, 45, 3, 45,
	5, 45, 445, 10, 45, 3, 46, 3, 46, 3, 46, 3, 46, 3, 46, 3, 46, 3, 46, 3,
	46, 3, 46, 5, 46, 456, 10, 46, 3, 47, 3, 47, 3, 47, 5, 47, 461, 10, 47,
	3, 48, 5, 48, 464, 10, 48, 3, 48, 3, 48, 5, 48, 468, 10, 48, 3, 49, 3,
	49, 6, 49, 472, 10, 49, 13, 49, 14, 49, 473, 3, 50, 3, 50, 7, 50, 478,
	10, 50, 12, 50, 14, 50, 481, 11, 50, 3, 50, 5, 50, 484, 10, 50, 3, 51,
	3, 51, 3, 51, 6, 51, 489, 10, 51, 13, 51, 14, 51, 490, 3, 52, 3, 52, 7,
	52, 495, 10, 52, 12, 52, 14, 52, 498, 11, 52, 3, 52, 5, 52, 501, 10, 52,
	3, 53, 3, 53, 3, 53, 3, 53, 3, 53, 3, 53, 3, 53, 5, 53, 510, 10, 53, 3,
	53, 3, 53, 3, 53, 3, 53, 3, 53, 3, 53, 3, 53, 3, 53, 3, 53, 3, 53, 3, 53,
	3, 53, 3, 53, 3, 53, 3, 53, 3, 53, 3, 53, 3, 53, 3, 53, 3, 53, 3, 53, 3,
	53, 3, 53, 3, 53, 3, 53, 3, 53, 3, 53, 3, 53, 3, 53, 3, 53, 3, 53, 3, 53,
	3, 53, 3, 53, 3, 53, 3, 53, 3, 53, 3, 53, 3, 53, 3, 53, 3, 53, 3, 53, 3,
	53, 3, 53, 3, 53, 3, 53, 3, 53, 3, 53, 3, 53, 3, 53, 3, 53, 3, 53, 3, 53,
	3, 53, 3, 53, 3, 53, 3, 53, 3, 53, 3, 53, 3, 53, 3, 53, 3, 53, 3, 53, 3,
	53, 3, 53, 3, 53, 3, 53, 3, 53, 3, 53, 3, 53, 3, 53, 3, 53, 3, 53, 3, 53,
	3, 53, 3, 53, 3, 53, 3, 53, 3, 53, 3, 53, 3, 53, 3, 53, 3, 53, 3, 53, 3,
	53, 3, 53, 3, 53, 3, 53, 5, 53, 600, 10, 53, 3, 54, 3, 54, 3, 54, 3, 54,
	3, 54, 7, 54, 607, 10, 54, 12, 54, 14, 54, 610, 11, 54, 3, 55, 3, 55, 3,
	55, 3, 55, 3, 55, 6, 55, 617, 10, 55, 13, 55, 14, 55, 618, 3, 56, 3, 56,
	3, 56, 3, 56, 3, 56, 7, 56, 626, 10, 56, 12, 56, 14, 56, 629, 11, 56, 3,
	56, 3, 56, 3, 56, 3, 57, 3, 57, 3, 57, 3, 57, 3, 57, 3, 57, 3, 57, 3, 57,
	3, 57, 5, 57, 643, 10, 57, 3, 58, 3, 58, 3, 58, 3, 59, 3, 59, 3, 59, 3,
	59, 3, 59, 3, 59, 3, 59, 3, 59, 3, 59, 5, 59, 657, 10, 59, 3, 60, 3, 60,
	3, 61, 3, 61, 3, 62, 3, 62, 3, 63, 3, 63, 3, 64, 3, 64, 3, 65, 3, 65, 3,
	66, 3, 66, 3, 67, 3, 67, 3, 68, 3, 68, 3, 69, 3, 69, 3, 69, 3, 69, 3, 69,
	5, 69, 682, 10, 69, 3, 70, 3, 70, 3, 70, 3, 70, 3, 70, 3, 70, 3, 70, 3,
	70, 3, 70, 3, 70, 5, 70, 694, 10, 70, 3, 71, 3, 71, 3, 71, 3, 71, 3, 71,
	3, 71, 5, 71, 702, 10, 71, 3, 72, 3, 72, 3, 72, 3, 73, 3, 73, 3, 73, 3,
	73, 3, 73, 3, 73, 3, 73, 3, 73, 3, 73, 3, 73, 3, 73, 3, 73, 3, 73, 3, 73,
	5, 73, 721, 10, 73, 3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 3,
	74, 3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 3, 74, 5, 74, 738, 10, 74,
	3, 75, 3, 75, 3, 75, 2, 2, 76, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22,
	24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58,
	60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94,
	96, 98, 100, 102, 104, 106, 108, 110, 112, 114, 116, 118, 120, 122, 124,
	126, 128, 130, 132, 134, 136, 138, 140, 142, 144, 146, 148, 2, 32, 4, 2,
	39, 39, 71, 71, 4, 2, 52, 52, 84, 84, 4, 2, 42, 42, 74, 74, 4, 2, 53, 53,
	85, 85, 4, 2, 56, 56, 88, 88, 4, 2, 51, 51, 83, 83, 4, 2, 47, 47, 79, 79,
	4, 2, 59, 59, 91, 91, 4, 2, 57, 57, 89, 89, 4, 2, 17, 17, 19, 19, 3, 2,
	7, 15, 3, 2, 17, 100, 3, 2, 7, 20, 3, 2, 22, 100, 3, 2, 22, 31, 3, 2, 23,
	31, 3, 2, 7, 97, 3, 2, 99, 100, 3, 2, 6, 7, 3, 2, 9, 65, 3, 2, 67, 100,
	3, 2, 165, 194, 3, 2, 133, 164, 3, 2, 196, 207, 3, 2, 101, 132, 3, 2, 209,
	210, 3, 2, 117, 164, 3, 2, 212, 214, 3, 2, 101, 116, 3, 2, 101, 164, 2,
	782, 2, 150, 3, 2, 2, 2, 4, 159, 3, 2, 2, 2, 6, 168, 3, 2, 2, 2, 8, 170,
	3, 2, 2, 2, 10, 180, 3, 2, 2, 2, 12, 190, 3, 2, 2, 2, 14, 196, 3, 2, 2,
	2, 16, 204, 3, 2, 2, 2, 18, 211, 3, 2, 2, 2, 20, 229, 3, 2, 2, 2, 22, 231,
	3, 2, 2, 2, 24, 233, 3, 2, 2, 2, 26, 235, 3, 2, 2, 2, 28, 245, 3, 2, 2,
	2, 30, 248, 3, 2, 2, 2, 32, 267, 3, 2, 2, 2, 34, 275, 3, 2, 2, 2, 36, 277,
	3, 2, 2, 2, 38, 279, 3, 2, 2, 2, 40, 282, 3, 2, 2, 2, 42, 285, 3, 2, 2,
	2, 44, 287, 3, 2, 2, 2, 46, 290, 3, 2, 2, 2, 48, 298, 3, 2, 2, 2, 50, 300,
	3, 2, 2, 2, 52, 304, 3, 2, 2, 2, 54, 311, 3, 2, 2, 2, 56, 322, 3, 2, 2,
	2, 58, 331, 3, 2, 2, 2, 60, 343, 3, 2, 2, 2, 62, 345, 3, 2, 2, 2, 64, 356,
	3, 2, 2, 2, 66, 365, 3, 2, 2, 2, 68, 376, 3, 2, 2, 2, 70, 383, 3, 2, 2,
	2, 72, 396, 3, 2, 2, 2, 74, 422, 3, 2, 2, 2, 76, 426, 3, 2, 2, 2, 78, 428,
	3, 2, 2, 2, 80, 433, 3, 2, 2, 2, 82, 435, 3, 2, 2, 2, 84, 437, 3, 2, 2,
	2, 86, 439, 3, 2, 2, 2, 88, 444, 3, 2, 2, 2, 90, 455, 3, 2, 2, 2, 92, 460,
	3, 2, 2, 2, 94, 463, 3, 2, 2, 2, 96, 471, 3, 2, 2, 2, 98, 483, 3, 2, 2,
	2, 100, 485, 3, 2, 2, 2, 102, 500, 3, 2, 2, 2, 104, 502, 3, 2, 2, 2, 106,
	608, 3, 2, 2, 2, 108, 616, 3, 2, 2, 2, 110, 620, 3, 2, 2, 2, 112, 642,
	3, 2, 2, 2, 114, 644, 3, 2, 2, 2, 116, 656, 3, 2, 2, 2, 118, 658, 3, 2,
	2, 2, 120, 660, 3, 2, 2, 2, 122, 662, 3, 2, 2, 2, 124, 664, 3, 2, 2, 2,
	126, 666, 3, 2, 2, 2, 128, 668, 3, 2, 2, 2, 130, 670, 3, 2, 2, 2, 132,
	672, 3, 2, 2, 2, 134, 674, 3, 2, 2, 2, 136, 681, 3, 2, 2, 2, 138, 693,
	3, 2, 2, 2, 140, 701, 3, 2, 2, 2, 142, 703, 3, 2, 2, 2, 144, 720, 3, 2,
	2, 2, 146, 737, 3, 2, 2, 2, 148, 739, 3, 2, 2, 2, 150, 155, 5, 106, 54,
	2, 151, 156, 5, 4, 3, 2, 152, 156, 5, 6, 4, 2, 153, 156, 5, 14, 8, 2, 154,
	156, 5, 18, 10, 2, 155, 151, 3, 2, 2, 2, 155, 152, 3, 2, 2, 2, 155, 153,
	3, 2, 2, 2, 155, 154, 3, 2, 2, 2, 156, 157, 3, 2, 2, 2, 157, 158, 5, 106,
	54, 2, 158, 3, 3, 2, 2, 2, 159, 160, 5, 18, 10, 2, 160, 161, 5, 106, 54,
	2, 161, 162, 7, 32, 2, 2, 162, 163, 5, 106, 54, 2, 163, 164, 5, 54, 28,
	2, 164, 5, 3, 2, 2, 2, 165, 169, 5, 8, 5, 2, 166, 169, 5, 10, 6, 2, 167,
	169, 5, 12, 7, 2, 168, 165, 3, 2, 2, 2, 168, 166, 3, 2, 2, 2, 168, 167,
	3, 2, 2, 2, 169, 7, 3, 2, 2, 2, 170, 176, 5, 18, 10, 2, 171, 172, 5, 106,
	54, 2, 172, 173, 5, 48, 25, 2, 173, 174, 5, 106, 54, 2, 174, 175, 5, 18,
	10, 2, 175, 177, 3, 2, 2, 2, 176, 171, 3, 2, 2, 2, 177, 178, 3, 2, 2, 2,
	178, 176, 3, 2, 2, 2, 178, 179, 3, 2, 2, 2, 179, 9, 3, 2, 2, 2, 180, 186,
	5, 18, 10, 2, 181, 182, 5, 106, 54, 2, 182, 183, 5, 50, 26, 2, 183, 184,
	5, 106, 54, 2, 184, 185, 5, 18, 10, 2, 185, 187, 3, 2, 2, 2, 186, 181,
	3, 2, 2, 2, 187, 188, 3, 2, 2, 2, 188, 186, 3, 2, 2, 2, 188, 189, 3, 2,
	2, 2, 189, 11, 3, 2, 2, 2, 190, 191, 5, 18, 10, 2, 191, 192, 5, 106, 54,
	2, 192, 193, 5, 52, 27, 2, 193, 194, 5, 106, 54, 2, 194, 195, 5, 18, 10,
	2, 195, 13, 3, 2, 2, 2, 196, 200, 5, 18, 10, 2, 197, 198, 5, 106, 54, 2,
	198, 199, 5, 16, 9, 2, 199, 201, 3, 2, 2, 2, 200, 197, 3, 2, 2, 2, 201,
	202, 3, 2, 2, 2, 202, 200, 3, 2, 2, 2, 202, 203, 3, 2, 2, 2, 203, 15, 3,
	2, 2, 2, 204, 205, 5, 22, 12, 2, 205, 206, 5, 106, 54, 2, 206, 207, 5,
	86, 44, 2, 207, 17, 3, 2, 2, 2, 208, 209, 5, 34, 18, 2, 209, 210, 5, 106,
	54, 2, 210, 212, 3, 2, 2, 2, 211, 208, 3, 2, 2, 2, 211, 212, 3, 2, 2, 2,
	212, 216, 3, 2, 2, 2, 213, 214, 5, 24, 13, 2, 214, 215, 5, 106, 54, 2,
	215, 217, 3, 2, 2, 2, 216, 213, 3, 2, 2, 2, 216, 217, 3, 2, 2, 2, 217,
	225, 3, 2, 2, 2, 218, 226, 5, 20, 11, 2, 219, 220, 7, 14, 2, 2, 220, 221,
	5, 106, 54, 2, 221, 222, 5, 2, 2, 2, 222, 223, 5, 106, 54, 2, 223, 224,
	7, 15, 2, 2, 224, 226, 3, 2, 2, 2, 225, 218, 3, 2, 2, 2, 225, 219, 3, 2,
	2, 2, 226, 19, 3, 2, 2, 2, 227, 230, 5, 26, 14, 2, 228, 230, 5, 32, 17,
	2, 229, 227, 3, 2, 2, 2, 229, 228, 3, 2, 2, 2, 230, 21, 3, 2, 2, 2, 231,
	232, 7, 20, 2, 2, 232, 23, 3, 2, 2, 2, 233, 234, 7, 68, 2, 2, 234, 25,
	3, 2, 2, 2, 235, 243, 5, 28, 15, 2, 236, 237, 5, 106, 54, 2, 237, 238,
	7, 98, 2, 2, 238, 239, 5, 106, 54, 2, 239, 240, 5, 30, 16, 2, 240, 241,
	5, 106, 54, 2, 241, 242, 7, 98, 2, 2, 242, 244, 3, 2, 2, 2, 243, 236, 3,
	2, 2, 2, 243, 244, 3, 2, 2, 2, 244, 27, 3, 2, 2, 2, 245, 246, 5, 104, 53,
	2, 246, 29, 3, 2, 2, 2, 247, 249, 5, 136, 69, 2, 248, 247, 3, 2, 2, 2,
	249, 250, 3, 2, 2, 2, 250, 248, 3, 2, 2, 2, 250, 251, 3, 2, 2, 2, 251,
	264, 3, 2, 2, 2, 252, 254, 5, 118, 60, 2, 253, 252, 3, 2, 2, 2, 254, 255,
	3, 2, 2, 2, 255, 253, 3, 2, 2, 2, 255, 256, 3, 2, 2, 2, 256, 258, 3, 2,
	2, 2, 257, 259, 5, 136, 69, 2, 258, 257, 3, 2, 2, 2, 259, 260, 3, 2, 2,
	2, 260, 258, 3, 2, 2, 2, 260, 261, 3, 2, 2, 2, 261, 263, 3, 2, 2, 2, 262,
	253, 3, 2, 2, 2, 263, 266, 3, 2, 2, 2, 264, 262, 3, 2, 2, 2, 264, 265,
	3, 2, 2, 2, 265, 31, 3, 2, 2, 2, 266, 264, 3, 2, 2, 2, 267, 268, 7, 16,
	2, 2, 268, 33, 3, 2, 2, 2, 269, 276, 5, 40, 21, 2, 270, 276, 5, 38, 20,
	2, 271, 276, 5, 36, 19, 2, 272, 276, 5, 46, 24, 2, 273, 276, 5, 44, 23,
	2, 274, 276, 5, 42, 22, 2, 275, 269, 3, 2, 2, 2, 275, 270, 3, 2, 2, 2,
	275, 271, 3, 2, 2, 2, 275, 272, 3, 2, 2, 2, 275, 273, 3, 2, 2, 2, 275,
	274, 3, 2, 2, 2, 276, 35, 3, 2, 2, 2, 277, 278, 7, 34, 2, 2, 278, 37, 3,
	2, 2, 2, 279, 280, 7, 34, 2, 2, 280, 281, 7, 34, 2, 2, 281, 39, 3, 2, 2,
	2, 282, 283, 7, 34, 2, 2, 283, 284, 7, 7, 2, 2, 284, 41, 3, 2, 2, 2, 285,
	286, 7, 36, 2, 2, 286, 43, 3, 2, 2, 2, 287, 288, 7, 36, 2, 2, 288, 289,
	7, 36, 2, 2, 289, 45, 3, 2, 2, 2, 290, 291, 7, 36, 2, 2, 291, 292, 7, 7,
	2, 2, 292, 47, 3, 2, 2, 2, 293, 294, 9, 2, 2, 2, 294, 295, 9, 3, 2, 2,
	295, 296, 9, 4, 2, 2, 296, 299, 5, 108, 55, 2, 297, 299, 7, 18, 2, 2, 298,
	293, 3, 2, 2, 2, 298, 297, 3, 2, 2, 2, 299, 49, 3, 2, 2, 2, 300, 301, 9,
	5, 2, 2, 301, 302, 9, 6, 2, 2, 302, 303, 5, 108, 55, 2, 303, 51, 3, 2,
	2, 2, 304, 305, 9, 7, 2, 2, 305, 306, 9, 8, 2, 2, 306, 307, 9, 3, 2, 2,
	307, 308, 9, 9, 2, 2, 308, 309, 9, 10, 2, 2, 309, 310, 5, 108, 55, 2, 310,
	53, 3, 2, 2, 2, 311, 312, 5, 60, 31, 2, 312, 315, 5, 106, 54, 2, 313, 316,
	5, 56, 29, 2, 314, 316, 5, 58, 30, 2, 315, 313, 3, 2, 2, 2, 315, 314, 3,
	2, 2, 2, 315, 316, 3, 2, 2, 2, 316, 55, 3, 2, 2, 2, 317, 318, 5, 106, 54,
	2, 318, 319, 5, 48, 25, 2, 319, 320, 5, 106, 54, 2, 320, 321, 5, 60, 31,
	2, 321, 323, 3, 2, 2, 2, 322, 317, 3, 2, 2, 2, 323, 324, 3, 2, 2, 2, 324,
	322, 3, 2, 2, 2, 324, 325, 3, 2, 2, 2, 325, 57, 3, 2, 2, 2, 326, 327, 5,
	106, 54, 2, 327, 328, 5, 50, 26, 2, 328, 329, 5, 106, 54, 2, 329, 330,
	5, 60, 31, 2, 330, 332, 3, 2, 2, 2, 331, 326, 3, 2, 2, 2, 332, 333, 3,
	2, 2, 2, 333, 331, 3, 2, 2, 2, 333, 334, 3, 2, 2, 2, 334, 59, 3, 2, 2,
	2, 335, 344, 5, 62, 32, 2, 336, 344, 5, 70, 36, 2, 337, 338, 7, 14, 2,
	2, 338, 339, 5, 106, 54, 2, 339, 340, 5, 54, 28, 2, 340, 341, 5, 106, 54,
	2, 341, 342, 7, 15, 2, 2, 342, 344, 3, 2, 2, 2, 343, 335, 3, 2, 2, 2, 343,
	336, 3, 2, 2, 2, 343, 337, 3, 2, 2, 2, 344, 61, 3, 2, 2, 2, 345, 346, 5,
	68, 35, 2, 346, 349, 5, 106, 54, 2, 347, 350, 5, 64, 33, 2, 348, 350, 5,
	66, 34, 2, 349, 347, 3, 2, 2, 2, 349, 348, 3, 2, 2, 2, 349, 350, 3, 2,
	2, 2, 350, 63, 3, 2, 2, 2, 351, 352, 5, 106, 54, 2, 352, 353, 5, 48, 25,
	2, 353, 354, 5, 106, 54, 2, 354, 355, 5, 68, 35, 2, 355, 357, 3, 2, 2,
	2, 356, 351, 3, 2, 2, 2, 357, 358, 3, 2, 2, 2, 358, 356, 3, 2, 2, 2, 358,
	359, 3, 2, 2, 2, 359, 65, 3, 2, 2, 2, 360, 361, 5, 106, 54, 2, 361, 362,
	5, 50, 26, 2, 362, 363, 5, 106, 54, 2, 363, 364, 5, 68, 35, 2, 364, 366,
	3, 2, 2, 2, 365, 360, 3, 2, 2, 2, 366, 367, 3, 2, 2, 2, 367, 365, 3, 2,
	2, 2, 367, 368, 3, 2, 2, 2, 368, 67, 3, 2, 2, 2, 369, 377, 5, 72, 37, 2,
	370, 371, 7, 14, 2, 2, 371, 372, 5, 106, 54, 2, 372, 373, 5, 62, 32, 2,
	373, 374, 5, 106, 54, 2, 374, 375, 7, 15, 2, 2, 375, 377, 3, 2, 2, 2, 376,
	369, 3, 2, 2, 2, 376, 370, 3, 2, 2, 2, 377, 69, 3, 2, 2, 2, 378, 379, 7,
	65, 2, 2, 379, 380, 5, 74, 38, 2, 380, 381, 7, 67, 2, 2, 381, 382, 5, 106,
	54, 2, 382, 384, 3, 2, 2, 2, 383, 378, 3, 2, 2, 2, 383, 384, 3, 2, 2, 2,
	384, 385, 3, 2, 2, 2, 385, 386, 7, 97, 2, 2, 386, 387, 5, 106, 54, 2, 387,
	388, 5, 62, 32, 2, 388, 389, 5, 106, 54, 2, 389, 390, 7, 99, 2, 2, 390,
	71, 3, 2, 2, 2, 391, 392, 7, 65, 2, 2, 392, 393, 5, 74, 38, 2, 393, 394,
	7, 67, 2, 2, 394, 395, 5, 106, 54, 2, 395, 397, 3, 2, 2, 2, 396, 391, 3,
	2, 2, 2, 396, 397, 3, 2, 2, 2, 397, 401, 3, 2, 2, 2, 398, 399, 5, 84, 43,
	2, 399, 400, 5, 106, 54, 2, 400, 402, 3, 2, 2, 2, 401, 398, 3, 2, 2, 2,
	401, 402, 3, 2, 2, 2, 402, 403, 3, 2, 2, 2, 403, 404, 5, 86, 44, 2, 404,
	420, 5, 106, 54, 2, 405, 406, 5, 88, 45, 2, 406, 407, 5, 106, 54, 2, 407,
	408, 5, 18, 10, 2, 408, 421, 3, 2, 2, 2, 409, 410, 5, 90, 46, 2, 410, 411,
	5, 106, 54, 2, 411, 412, 7, 9, 2, 2, 412, 413, 5, 94, 48, 2, 413, 421,
	3, 2, 2, 2, 414, 415, 5, 92, 47, 2, 415, 416, 5, 106, 54, 2, 416, 417,
	5, 126, 64, 2, 417, 418, 5, 96, 49, 2, 418, 419, 5, 126, 64, 2, 419, 421,
	3, 2, 2, 2, 420, 405, 3, 2, 2, 2, 420, 409, 3, 2, 2, 2, 420, 414, 3, 2,
	2, 2, 421, 73, 3, 2, 2, 2, 422, 423, 5, 76, 39, 2, 423, 424, 5, 78, 40,
	2, 424, 425, 5, 80, 41, 2, 425, 75, 3, 2, 2, 2, 426, 427, 5, 102, 52, 2,
	427, 77, 3, 2, 2, 2, 428, 429, 7, 20, 2, 2, 429, 430, 7, 20, 2, 2, 430,
	79, 3, 2, 2, 2, 431, 434, 5, 102, 52, 2, 432, 434, 5, 82, 42, 2, 433, 431,
	3, 2, 2, 2, 433, 432, 3, 2, 2, 2, 434, 81, 3, 2, 2, 2, 435, 436, 7, 16,
	2, 2, 436, 83, 3, 2, 2, 2, 437, 438, 7, 56, 2, 2, 438, 85, 3, 2, 2, 2,
	439, 440, 5, 18, 10, 2, 440, 87, 3, 2, 2, 2, 441, 445, 7, 35, 2, 2, 442,
	443, 7, 7, 2, 2, 443, 445, 7, 35, 2, 2, 444, 441, 3, 2, 2, 2, 444, 442,
	3, 2, 2, 2, 445, 89, 3, 2, 2, 2, 446, 456, 7, 35, 2, 2, 447, 448, 7, 7,
	2, 2, 448, 456, 7, 35, 2, 2, 449, 450, 7, 34, 2, 2, 450, 456, 7, 35, 2,
	2, 451, 456, 7, 34, 2, 2, 452, 453, 7, 36, 2, 2, 453, 456, 7, 35, 2, 2,
	454, 456, 7, 36, 2, 2, 455, 446, 3, 2, 2, 2, 455, 447, 3, 2, 2, 2, 455,
	449, 3, 2, 2, 2, 455, 451, 3, 2, 2, 2, 455, 452, 3, 2, 2, 2, 455, 454,
	3, 2, 2, 2, 456, 91, 3, 2, 2, 2, 457, 461, 7, 35, 2, 2, 458, 459, 7, 7,
	2, 2, 459, 461, 7, 35, 2, 2, 460, 457, 3, 2, 2, 2, 460, 458, 3, 2, 2, 2,
	461, 93, 3, 2, 2, 2, 462, 464, 9, 11, 2, 2, 463, 462, 3, 2, 2, 2, 463,
	464, 3, 2, 2, 2, 464, 467, 3, 2, 2, 2, 465, 468, 5, 100, 51, 2, 466, 468,
	5, 98, 50, 2, 467, 465, 3, 2, 2, 2, 467, 466, 3, 2, 2, 2, 468, 95, 3, 2,
	2, 2, 469, 472, 5, 138, 70, 2, 470, 472, 5, 140, 71, 2, 471, 469, 3, 2,
	2, 2, 471, 470, 3, 2, 2, 2, 472, 473, 3, 2, 2, 2, 473, 471, 3, 2, 2, 2,
	473, 474, 3, 2, 2, 2, 474, 97, 3, 2, 2, 2, 475, 479, 5, 134, 68, 2, 476,
	478, 5, 130, 66, 2, 477, 476, 3, 2, 2, 2, 478, 481, 3, 2, 2, 2, 479, 477,
	3, 2, 2, 2, 479, 480, 3, 2, 2, 2, 480, 484, 3, 2, 2, 2, 481, 479, 3, 2,
	2, 2, 482, 484, 5, 132, 67, 2, 483, 475, 3, 2, 2, 2, 483, 482, 3, 2, 2,
	2, 484, 99, 3, 2, 2, 2, 485, 486, 5, 98, 50, 2, 486, 488, 7, 20, 2, 2,
	487, 489, 5, 130, 66, 2, 488, 487, 3, 2, 2, 2, 489, 490, 3, 2, 2, 2, 490,
	488, 3, 2, 2, 2, 490, 491, 3, 2, 2, 2, 491, 101, 3, 2, 2, 2, 492, 496,
	5, 134, 68, 2, 493, 495, 5, 130, 66, 2, 494, 493, 3, 2, 2, 2, 495, 498,
	3, 2, 2, 2, 496, 494, 3, 2, 2, 2, 496, 497, 3, 2, 2, 2, 497, 501, 3, 2,
	2, 2, 498, 496, 3, 2, 2, 2, 499, 501, 5, 132, 67, 2, 500, 492, 3, 2, 2,
	2, 500, 499, 3, 2, 2, 2, 501, 103, 3, 2, 2, 2, 502, 503, 5, 134, 68, 2,
	503, 504, 5, 130, 66, 2, 504, 505, 5, 130, 66, 2, 505, 506, 5, 130, 66,
	2, 506, 507, 5, 130, 66, 2, 507, 599, 5, 130, 66, 2, 508, 510, 5, 130,
	66, 2, 509, 508, 3, 2, 2, 2, 509, 510, 3, 2, 2, 2, 510, 600, 3, 2, 2, 2,
	511, 512, 5, 130, 66, 2, 512, 513, 5, 130, 66, 2, 513, 600, 3, 2, 2, 2,
	514, 515, 5, 130, 66, 2, 515, 516, 5, 130, 66, 2, 516, 517, 5, 130, 66,
	2, 517, 600, 3, 2, 2, 2, 518, 519, 5, 130, 66, 2, 519, 520, 5, 130, 66,
	2, 520, 521, 5, 130, 66, 2, 521, 522, 5, 130, 66, 2, 522, 600, 3, 2, 2,
	2, 523, 524, 5, 130, 66, 2, 524, 525, 5, 130, 66, 2, 525, 526, 5, 130,
	66, 2, 526, 527, 5, 130, 66, 2, 527, 528, 5, 130, 66, 2, 528, 600, 3, 2,
	2, 2, 529, 530, 5, 130, 66, 2, 530, 531, 5, 130, 66, 2, 531, 532, 5, 130,
	66, 2, 532, 533, 5, 130, 66, 2, 533, 534, 5, 130, 66, 2, 534, 535, 5, 130,
	66, 2, 535, 600, 3, 2, 2, 2, 536, 537, 5, 130, 66, 2, 537, 538, 5, 130,
	66, 2, 538, 539, 5, 130, 66, 2, 539, 540, 5, 130, 66, 2, 540, 541, 5, 130,
	66, 2, 541, 542, 5, 130, 66, 2, 542, 543, 5, 130, 66, 2, 543, 600, 3, 2,
	2, 2, 544, 545, 5, 130, 66, 2, 545, 546, 5, 130, 66, 2, 546, 547, 5, 130,
	66, 2, 547, 548, 5, 130, 66, 2, 548, 549, 5, 130, 66, 2, 549, 550, 5, 130,
	66, 2, 550, 551, 5, 130, 66, 2, 551, 552, 5, 130, 66, 2, 552, 600, 3, 2,
	2, 2, 553, 554, 5, 130, 66, 2, 554, 555, 5, 130, 66, 2, 555, 556, 5, 130,
	66, 2, 556, 557, 5, 130, 66, 2, 557, 558, 5, 130, 66, 2, 558, 559, 5, 130,
	66, 2, 559, 560, 5, 130, 66, 2, 560, 561, 5, 130, 66, 2, 561, 562, 5, 130,
	66, 2, 562, 600, 3, 2, 2, 2, 563, 564, 5, 130, 66, 2, 564, 565, 5, 130,
	66, 2, 565, 566, 5, 130, 66, 2, 566, 567, 5, 130, 66, 2, 567, 568, 5, 130,
	66, 2, 568, 569, 5, 130, 66, 2, 569, 570, 5, 130, 66, 2, 570, 571, 5, 130,
	66, 2, 571, 572, 5, 130, 66, 2, 572, 573, 5, 130, 66, 2, 573, 600, 3, 2,
	2, 2, 574, 575, 5, 130, 66, 2, 575, 576, 5, 130, 66, 2, 576, 577, 5, 130,
	66, 2, 577, 578, 5, 130, 66, 2, 578, 579, 5, 130, 66, 2, 579, 580, 5, 130,
	66, 2, 580, 581, 5, 130, 66, 2, 581, 582, 5, 130, 66, 2, 582, 583, 5, 130,
	66, 2, 583, 584, 5, 130, 66, 2, 584, 585, 5, 130, 66, 2, 585, 600, 3, 2,
	2, 2, 586, 587, 5, 130, 66, 2, 587, 588, 5, 130, 66, 2, 588, 589, 5, 130,
	66, 2, 589, 590, 5, 130, 66, 2, 590, 591, 5, 130, 66, 2, 591, 592, 5, 130,
	66, 2, 592, 593, 5, 130, 66, 2, 593, 594, 5, 130, 66, 2, 594, 595, 5, 130,
	66, 2, 595, 596, 5, 130, 66, 2, 596, 597, 5, 130, 66, 2, 597, 598, 5, 130,
	66, 2, 598, 600, 3, 2, 2, 2, 599, 509, 3, 2, 2, 2, 599, 511, 3, 2, 2, 2,
	599, 514, 3, 2, 2, 2, 599, 518, 3, 2, 2, 2, 599, 523, 3, 2, 2, 2, 599,
	529, 3, 2, 2, 2, 599, 536, 3, 2, 2, 2, 599, 544, 3, 2, 2, 2, 599, 553,
	3, 2, 2, 2, 599, 563, 3, 2, 2, 2, 599, 574, 3, 2, 2, 2, 599, 586, 3, 2,
	2, 2, 600, 105, 3, 2, 2, 2, 601, 607, 5, 118, 60, 2, 602, 607, 5, 120,
	61, 2, 603, 607, 5, 122, 62, 2, 604, 607, 5, 124, 63, 2, 605, 607, 5, 110,
	56, 2, 606, 601, 3, 2, 2, 2, 606, 602, 3, 2, 2, 2, 606, 603, 3, 2, 2, 2,
	606, 604, 3, 2, 2, 2, 606, 605, 3, 2, 2, 2, 607, 610, 3, 2, 2, 2, 608,
	606, 3, 2, 2, 2, 608, 609, 3, 2, 2, 2, 609, 107, 3, 2, 2, 2, 610, 608,
	3, 2, 2, 2, 611, 617, 5, 118, 60, 2, 612, 617, 5, 120, 61, 2, 613, 617,
	5, 122, 62, 2, 614, 617, 5, 124, 63, 2, 615, 617, 5, 110, 56, 2, 616, 611,
	3, 2, 2, 2, 616, 612, 3, 2, 2, 2, 616, 613, 3, 2, 2, 2, 616, 614, 3, 2,
	2, 2, 616, 615, 3, 2, 2, 2, 617, 618, 3, 2, 2, 2, 618, 616, 3, 2, 2, 2,
	618, 619, 3, 2, 2, 2, 619, 109, 3, 2, 2, 2, 620, 621, 7, 21, 2, 2, 621,
	622, 7, 16, 2, 2, 622, 627, 3, 2, 2, 2, 623, 626, 5, 112, 57, 2, 624, 626,
	5, 114, 58, 2, 625, 623, 3, 2, 2, 2, 625, 624, 3, 2, 2, 2, 626, 629, 3,
	2, 2, 2, 627, 625, 3, 2, 2, 2, 627, 628, 3, 2, 2, 2, 628, 630, 3, 2, 2,
	2, 629, 627, 3, 2, 2, 2, 630, 631, 7, 16, 2, 2, 631, 632, 7, 21, 2, 2,
	632, 111, 3, 2, 2, 2, 633, 643, 5, 118, 60, 2, 634, 643, 5, 120, 61, 2,
	635, 643, 5, 122, 62, 2, 636, 643, 5, 124, 63, 2, 637, 643, 9, 12, 2, 2,
	638, 643, 9, 13, 2, 2, 639, 643, 5, 142, 72, 2, 640, 643, 5, 144, 73, 2,
	641, 643, 5, 146, 74, 2, 642, 633, 3, 2, 2, 2, 642, 634, 3, 2, 2, 2, 642,
	635, 3, 2, 2, 2, 642, 636, 3, 2, 2, 2, 642, 637, 3, 2, 2, 2, 642, 638,
	3, 2, 2, 2, 642, 639, 3, 2, 2, 2, 642, 640, 3, 2, 2, 2, 642, 641, 3, 2,
	2, 2, 643, 113, 3, 2, 2, 2, 644, 645, 7, 16, 2, 2, 645, 646, 5, 116, 59,
	2, 646, 115, 3, 2, 2, 2, 647, 657, 5, 118, 60, 2, 648, 657, 5, 120, 61,
	2, 649, 657, 5, 122, 62, 2, 650, 657, 5, 124, 63, 2, 651, 657, 9, 14, 2,
	2, 652, 657, 9, 15, 2, 2, 653, 657, 5, 142, 72, 2, 654, 657, 5, 144, 73,
	2, 655, 657, 5, 146, 74, 2, 656, 647, 3, 2, 2, 2, 656, 648, 3, 2, 2, 2,
	656, 649, 3, 2, 2, 2, 656, 650, 3, 2, 2, 2, 656, 651, 3, 2, 2, 2, 656,
	652, 3, 2, 2, 2, 656, 653, 3, 2, 2, 2, 656, 654, 3, 2, 2, 2, 656, 655,
	3, 2, 2, 2, 657, 117, 3, 2, 2, 2, 658, 659, 7, 6, 2, 2, 659, 119, 3, 2,
	2, 2, 660, 661, 7, 3, 2, 2, 661, 121, 3, 2, 2, 2, 662, 663, 7, 5, 2, 2,
	663, 123, 3, 2, 2, 2, 664, 665, 7, 4, 2, 2, 665, 125, 3, 2, 2, 2, 666,
	667, 7, 8, 2, 2, 667, 127, 3, 2, 2, 2, 668, 669, 7, 66, 2, 2, 669, 129,
	3, 2, 2, 2, 670, 671, 9, 16, 2, 2, 671, 131, 3, 2, 2, 2, 672, 673, 7, 22,
	2, 2, 673, 133, 3, 2, 2, 2, 674, 675, 9, 17, 2, 2, 675, 135, 3, 2, 2, 2,
	676, 682, 9, 18, 2, 2, 677, 682, 9, 19, 2, 2, 678, 682, 5, 142, 72, 2,
	679, 682, 5, 144, 73, 2, 680, 682, 5, 146, 74, 2, 681, 676, 3, 2, 2, 2,
	681, 677, 3, 2, 2, 2, 681, 678, 3, 2, 2, 2, 681, 679, 3, 2, 2, 2, 681,
	680, 3, 2, 2, 2, 682, 137, 3, 2, 2, 2, 683, 694, 5, 118, 60, 2, 684, 694,
	5, 120, 61, 2, 685, 694, 5, 122, 62, 2, 686, 694, 5, 124, 63, 2, 687, 694,
	9, 20, 2, 2, 688, 694, 9, 21, 2, 2, 689, 694, 9, 22, 2, 2, 690, 694, 5,
	142, 72, 2, 691, 694, 5, 144, 73, 2, 692, 694, 5, 146, 74, 2, 693, 683,
	3, 2, 2, 2, 693, 684, 3, 2, 2, 2, 693, 685, 3, 2, 2, 2, 693, 686, 3, 2,
	2, 2, 693, 687, 3, 2, 2, 2, 693, 688, 3, 2, 2, 2, 693, 689, 3, 2, 2, 2,
	693, 690, 3, 2, 2, 2, 693, 691, 3, 2, 2, 2, 693, 692, 3, 2, 2, 2, 694,
	139, 3, 2, 2, 2, 695, 696, 5, 128, 65, 2, 696, 697, 5, 126, 64, 2, 697,
	702, 3, 2, 2, 2, 698, 699, 5, 128, 65, 2, 699, 700, 5, 128, 65, 2, 700,
	702, 3, 2, 2, 2, 701, 695, 3, 2, 2, 2, 701, 698, 3, 2, 2, 2, 702, 141,
	3, 2, 2, 2, 703, 704, 9, 23, 2, 2, 704, 705, 5, 148, 75, 2, 705, 143, 3,
	2, 2, 2, 706, 707, 7, 195, 2, 2, 707, 708, 9, 24, 2, 2, 708, 721, 5, 148,
	75, 2, 709, 710, 9, 25, 2, 2, 710, 711, 5, 148, 75, 2, 711, 712, 5, 148,
	75, 2, 712, 721, 3, 2, 2, 2, 713, 714, 7, 208, 2, 2, 714, 715, 9, 26, 2,
	2, 715, 721, 5, 148, 75, 2, 716, 717, 9, 27, 2, 2, 717, 718, 5, 148, 75,
	2, 718, 719, 5, 148, 75, 2, 719, 721, 3, 2, 2, 2, 720, 706, 3, 2, 2, 2,
	720, 709, 3, 2, 2, 2, 720, 713, 3, 2, 2, 2, 720, 716, 3, 2, 2, 2, 721,
	145, 3, 2, 2, 2, 722, 723, 7, 211, 2, 2, 723, 724, 9, 28, 2, 2, 724, 725,
	5, 148, 75, 2, 725, 726, 5, 148, 75, 2, 726, 738, 3, 2, 2, 2, 727, 728,
	9, 29, 2, 2, 728, 729, 5, 148, 75, 2, 729, 730, 5, 148, 75, 2, 730, 731,
	5, 148, 75, 2, 731, 738, 3, 2, 2, 2, 732, 733, 7, 215, 2, 2, 733, 734,
	9, 30, 2, 2, 734, 735, 5, 148, 75, 2, 735, 736, 5, 148, 75, 2, 736, 738,
	3, 2, 2, 2, 737, 722, 3, 2, 2, 2, 737, 727, 3, 2, 2, 2, 737, 732, 3, 2,
	2, 2, 738, 147, 3, 2, 2, 2, 739, 740, 9, 31, 2, 2, 740, 149, 3, 2, 2, 2,
	58, 155, 168, 178, 188, 202, 211, 216, 225, 229, 243, 250, 255, 260, 264,
	275, 298, 315, 324, 333, 343, 349, 358, 367, 376, 383, 396, 401, 420, 433,
	444, 455, 460, 463, 467, 471, 473, 479, 483, 490, 496, 500, 509, 599, 606,
	608, 616, 618, 625, 627, 642, 656, 681, 693, 701, 720, 737,
}
var deserializer = antlr.NewATNDeserializer(nil)
var deserializedATN = deserializer.DeserializeFromUInt16(parserATN)

var literalNames = []string{
	"", "'\u0009'", "'\u000A'", "'\u000D'", "' '", "'!'", "'\"'", "'#'", "'$'",
	"'%'", "'&'", "'''", "'('", "')'", "'*'", "'+'", "','", "'-'", "'.'", "'/'",
	"'0'", "'1'", "'2'", "'3'", "'4'", "'5'", "'6'", "'7'", "'8'", "'9'", "':'",
	"';'", "'<'", "'='", "'>'", "'?'", "'@'", "'A'", "'B'", "'C'", "'D'", "'E'",
	"'F'", "'G'", "'H'", "'I'", "'J'", "'K'", "'L'", "'M'", "'N'", "'O'", "'P'",
	"'Q'", "'R'", "'S'", "'T'", "'U'", "'V'", "'W'", "'X'", "'Y'", "'Z'", "'['",
	"'\\'", "']'", "'^'", "'_'", "'`'", "'a'", "'b'", "'c'", "'d'", "'e'",
	"'f'", "'g'", "'h'", "'i'", "'j'", "'k'", "'l'", "'m'", "'n'", "'o'", "'p'",
	"'q'", "'r'", "'s'", "'t'", "'u'", "'v'", "'w'", "'x'", "'y'", "'z'", "'{'",
	"'|'", "'}'", "'~'", "'\u0080'", "'\u0081'", "'\u0082'", "'\u0083'", "'\u0084'",
	"'\u0085'", "'\u0086'", "'\u0087'", "'\u0088'", "'\u0089'", "'\u008A'",
	"'\u008B'", "'\u008C'", "'\u008D'", "'\u008E'", "'\u008F'", "'\u0090'",
	"'\u0091'", "'\u0092'", "'\u0093'", "'\u0094'", "'\u0095'", "'\u0096'",
	"'\u0097'", "'\u0098'", "'\u0099'", "'\u009A'", "'\u009B'", "'\u009C'",
	"'\u009D'", "'\u009E'", "'\u009F'", "'\u00A0'", "'\u00A1'", "'\u00A2'",
	"'\u00A3'", "'\u00A4'", "'\u00A5'", "'\u00A6'", "'\u00A7'", "'\u00A8'",
	"'\u00A9'", "'\u00AA'", "'\u00AB'", "'\u00AC'", "'\u00AD'", "'\u00AE'",
	"'\u00AF'", "'\u00B0'", "'\u00B1'", "'\u00B2'", "'\u00B3'", "'\u00B4'",
	"'\u00B5'", "'\u00B6'", "'\u00B7'", "'\u00B8'", "'\u00B9'", "'\u00BA'",
	"'\u00BB'", "'\u00BC'", "'\u00BD'", "'\u00BE'", "'\u00BF'", "'\u00C2'",
	"'\u00C3'", "'\u00C4'", "'\u00C5'", "'\u00C6'", "'\u00C7'", "'\u00C8'",
	"'\u00C9'", "'\u00CA'", "'\u00CB'", "'\u00CC'", "'\u00CD'", "'\u00CE'",
	"'\u00CF'", "'\u00D0'", "'\u00D1'", "'\u00D2'", "'\u00D3'", "'\u00D4'",
	"'\u00D5'", "'\u00D6'", "'\u00D7'", "'\u00D8'", "'\u00D9'", "'\u00DA'",
	"'\u00DB'", "'\u00DC'", "'\u00DD'", "'\u00DE'", "'\u00DF'", "'\u00E0'",
	"'\u00E1'", "'\u00E2'", "'\u00E3'", "'\u00E4'", "'\u00E5'", "'\u00E6'",
	"'\u00E7'", "'\u00E8'", "'\u00E9'", "'\u00EA'", "'\u00EB'", "'\u00EC'",
	"'\u00ED'", "'\u00EE'", "'\u00EF'", "'\u00F0'", "'\u00F1'", "'\u00F2'",
	"'\u00F3'", "'\u00F4'",
}
var symbolicNames = []string{
	"", "TAB", "LF", "CR", "SPACE", "EXCLAMATION", "QUOTE", "POUND", "DOLLAR",
	"PERCENT", "AMPERSAND", "APOSTROPHE", "LEFT_PAREN", "RIGHT_PAREN", "ASTERISK",
	"PLUS", "COMMA", "DASH", "PERIOD", "SLASH", "ZERO", "ONE", "TWO", "THREE",
	"FOUR", "FIVE", "SIX", "SEVEN", "EIGHT", "NINE", "COLON", "SEMICOLON",
	"LESS_THAN", "EQUALS", "GREATER_THAN", "QUESTION", "AT", "CAP_A", "CAP_B",
	"CAP_C", "CAP_D", "CAP_E", "CAP_F", "CAP_G", "CAP_H", "CAP_I", "CAP_J",
	"CAP_K", "CAP_L", "CAP_M", "CAP_N", "CAP_O", "CAP_P", "CAP_Q", "CAP_R",
	"CAP_S", "CAP_T", "CAP_U", "CAP_V", "CAP_W", "CAP_X", "CAP_Y", "CAP_Z",
	"LEFT_BRACE", "BACKSLASH", "RIGHT_BRACE", "CARAT", "UNDERSCORE", "ACCENT",
	"A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O",
	"P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "LEFT_CURLY_BRACE",
	"PIPE", "RIGHT_CURLY_BRACE", "TILDE", "U_0080", "U_0081", "U_0082", "U_0083",
	"U_0084", "U_0085", "U_0086", "U_0087", "U_0088", "U_0089", "U_008A", "U_008B",
	"U_008C", "U_008D", "U_008E", "U_008F", "U_0090", "U_0091", "U_0092", "U_0093",
	"U_0094", "U_0095", "U_0096", "U_0097", "U_0098", "U_0099", "U_009A", "U_009B",
	"U_009C", "U_009D", "U_009E", "U_009F", "U_00A0", "U_00A1", "U_00A2", "U_00A3",
	"U_00A4", "U_00A5", "U_00A6", "U_00A7", "U_00A8", "U_00A9", "U_00AA", "U_00AB",
	"U_00AC", "U_00AD", "U_00AE", "U_00AF", "U_00B0", "U_00B1", "U_00B2", "U_00B3",
	"U_00B4", "U_00B5", "U_00B6", "U_00B7", "U_00B8", "U_00B9", "U_00BA", "U_00BB",
	"U_00BC", "U_00BD", "U_00BE", "U_00BF", "U_00C2", "U_00C3", "U_00C4", "U_00C5",
	"U_00C6", "U_00C7", "U_00C8", "U_00C9", "U_00CA", "U_00CB", "U_00CC", "U_00CD",
	"U_00CE", "U_00CF", "U_00D0", "U_00D1", "U_00D2", "U_00D3", "U_00D4", "U_00D5",
	"U_00D6", "U_00D7", "U_00D8", "U_00D9", "U_00DA", "U_00DB", "U_00DC", "U_00DD",
	"U_00DE", "U_00DF", "U_00E0", "U_00E1", "U_00E2", "U_00E3", "U_00E4", "U_00E5",
	"U_00E6", "U_00E7", "U_00E8", "U_00E9", "U_00EA", "U_00EB", "U_00EC", "U_00ED",
	"U_00EE", "U_00EF", "U_00F0", "U_00F1", "U_00F2", "U_00F3", "U_00F4",
}

var ruleNames = []string{
	"expressionconstraint", "refinedexpressionconstraint", "compoundexpressionconstraint",
	"conjunctionexpressionconstraint", "disjunctionexpressionconstraint", "exclusionexpressionconstraint",
	"dottedexpressionconstraint", "dottedexpressionattribute", "subexpressionconstraint",
	"eclfocusconcept", "dot", "memberof", "eclconceptreference", "conceptid",
	"term", "wildcard", "constraintoperator", "descendantof", "descendantorselfof",
	"childof", "ancestorof", "ancestororselfof", "parentof", "conjunction",
	"disjunction", "exclusion", "eclrefinement", "conjunctionrefinementset",
	"disjunctionrefinementset", "subrefinement", "eclattributeset", "conjunctionattributeset",
	"disjunctionattributeset", "subattributeset", "eclattributegroup", "eclattribute",
	"cardinality", "minvalue", "to", "maxvalue", "many", "reverseflag", "eclattributename",
	"expressioncomparisonoperator", "numericcomparisonoperator", "stringcomparisonoperator",
	"numericvalue", "stringvalue", "integervalue", "decimalvalue", "nonnegativeintegervalue",
	"sctid", "ws", "mws", "comment", "nonstarchar", "starwithnonfslash", "nonfslash",
	"sp", "htab", "cr", "lf", "qm", "bs", "digit", "zero", "digitnonzero",
	"nonwsnonpipe", "anynonescapedchar", "escapedchar", "utf8_2", "utf8_3",
	"utf8_4", "utf8_tail",
}
var decisionToDFA = make([]*antlr.DFA, len(deserializedATN.DecisionToState))

func init() {
	for index, ds := range deserializedATN.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(ds, index)
	}
}

type ECLParser struct {
	*antlr.BaseParser
}

func NewECLParser(input antlr.TokenStream) *ECLParser {
	this := new(ECLParser)

	this.BaseParser = antlr.NewBaseParser(input)

	this.Interpreter = antlr.NewParserATNSimulator(this, deserializedATN, decisionToDFA, antlr.NewPredictionContextCache())
	this.RuleNames = ruleNames
	this.LiteralNames = literalNames
	this.SymbolicNames = symbolicNames
	this.GrammarFileName = "ECL.g4"

	return this
}

// ECLParser tokens.
const (
	ECLParserEOF               = antlr.TokenEOF
	ECLParserTAB               = 1
	ECLParserLF                = 2
	ECLParserCR                = 3
	ECLParserSPACE             = 4
	ECLParserEXCLAMATION       = 5
	ECLParserQUOTE             = 6
	ECLParserPOUND             = 7
	ECLParserDOLLAR            = 8
	ECLParserPERCENT           = 9
	ECLParserAMPERSAND         = 10
	ECLParserAPOSTROPHE        = 11
	ECLParserLEFT_PAREN        = 12
	ECLParserRIGHT_PAREN       = 13
	ECLParserASTERISK          = 14
	ECLParserPLUS              = 15
	ECLParserCOMMA             = 16
	ECLParserDASH              = 17
	ECLParserPERIOD            = 18
	ECLParserSLASH             = 19
	ECLParserZERO              = 20
	ECLParserONE               = 21
	ECLParserTWO               = 22
	ECLParserTHREE             = 23
	ECLParserFOUR              = 24
	ECLParserFIVE              = 25
	ECLParserSIX               = 26
	ECLParserSEVEN             = 27
	ECLParserEIGHT             = 28
	ECLParserNINE              = 29
	ECLParserCOLON             = 30
	ECLParserSEMICOLON         = 31
	ECLParserLESS_THAN         = 32
	ECLParserEQUALS            = 33
	ECLParserGREATER_THAN      = 34
	ECLParserQUESTION          = 35
	ECLParserAT                = 36
	ECLParserCAP_A             = 37
	ECLParserCAP_B             = 38
	ECLParserCAP_C             = 39
	ECLParserCAP_D             = 40
	ECLParserCAP_E             = 41
	ECLParserCAP_F             = 42
	ECLParserCAP_G             = 43
	ECLParserCAP_H             = 44
	ECLParserCAP_I             = 45
	ECLParserCAP_J             = 46
	ECLParserCAP_K             = 47
	ECLParserCAP_L             = 48
	ECLParserCAP_M             = 49
	ECLParserCAP_N             = 50
	ECLParserCAP_O             = 51
	ECLParserCAP_P             = 52
	ECLParserCAP_Q             = 53
	ECLParserCAP_R             = 54
	ECLParserCAP_S             = 55
	ECLParserCAP_T             = 56
	ECLParserCAP_U             = 57
	ECLParserCAP_V             = 58
	ECLParserCAP_W             = 59
	ECLParserCAP_X             = 60
	ECLParserCAP_Y             = 61
	ECLParserCAP_Z             = 62
	ECLParserLEFT_BRACE        = 63
	ECLParserBACKSLASH         = 64
	ECLParserRIGHT_BRACE       = 65
	ECLParserCARAT             = 66
	ECLParserUNDERSCORE        = 67
	ECLParserACCENT            = 68
	ECLParserA                 = 69
	ECLParserB                 = 70
	ECLParserC                 = 71
	ECLParserD                 = 72
	ECLParserE                 = 73
	ECLParserF                 = 74
	ECLParserG                 = 75
	ECLParserH                 = 76
	ECLParserI                 = 77
	ECLParserJ                 = 78
	ECLParserK                 = 79
	ECLParserL                 = 80
	ECLParserM                 = 81
	ECLParserN                 = 82
	ECLParserO                 = 83
	ECLParserP                 = 84
	ECLParserQ                 = 85
	ECLParserR                 = 86
	ECLParserS                 = 87
	ECLParserT                 = 88
	ECLParserU                 = 89
	ECLParserV                 = 90
	ECLParserW                 = 91
	ECLParserX                 = 92
	ECLParserY                 = 93
	ECLParserZ                 = 94
	ECLParserLEFT_CURLY_BRACE  = 95
	ECLParserPIPE              = 96
	ECLParserRIGHT_CURLY_BRACE = 97
	ECLParserTILDE             = 98
	ECLParserU_0080            = 99
	ECLParserU_0081            = 100
	ECLParserU_0082            = 101
	ECLParserU_0083            = 102
	ECLParserU_0084            = 103
	ECLParserU_0085            = 104
	ECLParserU_0086            = 105
	ECLParserU_0087            = 106
	ECLParserU_0088            = 107
	ECLParserU_0089            = 108
	ECLParserU_008A            = 109
	ECLParserU_008B            = 110
	ECLParserU_008C            = 111
	ECLParserU_008D            = 112
	ECLParserU_008E            = 113
	ECLParserU_008F            = 114
	ECLParserU_0090            = 115
	ECLParserU_0091            = 116
	ECLParserU_0092            = 117
	ECLParserU_0093            = 118
	ECLParserU_0094            = 119
	ECLParserU_0095            = 120
	ECLParserU_0096            = 121
	ECLParserU_0097            = 122
	ECLParserU_0098            = 123
	ECLParserU_0099            = 124
	ECLParserU_009A            = 125
	ECLParserU_009B            = 126
	ECLParserU_009C            = 127
	ECLParserU_009D            = 128
	ECLParserU_009E            = 129
	ECLParserU_009F            = 130
	ECLParserU_00A0            = 131
	ECLParserU_00A1            = 132
	ECLParserU_00A2            = 133
	ECLParserU_00A3            = 134
	ECLParserU_00A4            = 135
	ECLParserU_00A5            = 136
	ECLParserU_00A6            = 137
	ECLParserU_00A7            = 138
	ECLParserU_00A8            = 139
	ECLParserU_00A9            = 140
	ECLParserU_00AA            = 141
	ECLParserU_00AB            = 142
	ECLParserU_00AC            = 143
	ECLParserU_00AD            = 144
	ECLParserU_00AE            = 145
	ECLParserU_00AF            = 146
	ECLParserU_00B0            = 147
	ECLParserU_00B1            = 148
	ECLParserU_00B2            = 149
	ECLParserU_00B3            = 150
	ECLParserU_00B4            = 151
	ECLParserU_00B5            = 152
	ECLParserU_00B6            = 153
	ECLParserU_00B7            = 154
	ECLParserU_00B8            = 155
	ECLParserU_00B9            = 156
	ECLParserU_00BA            = 157
	ECLParserU_00BB            = 158
	ECLParserU_00BC            = 159
	ECLParserU_00BD            = 160
	ECLParserU_00BE            = 161
	ECLParserU_00BF            = 162
	ECLParserU_00C2            = 163
	ECLParserU_00C3            = 164
	ECLParserU_00C4            = 165
	ECLParserU_00C5            = 166
	ECLParserU_00C6            = 167
	ECLParserU_00C7            = 168
	ECLParserU_00C8            = 169
	ECLParserU_00C9            = 170
	ECLParserU_00CA            = 171
	ECLParserU_00CB            = 172
	ECLParserU_00CC            = 173
	ECLParserU_00CD            = 174
	ECLParserU_00CE            = 175
	ECLParserU_00CF            = 176
	ECLParserU_00D0            = 177
	ECLParserU_00D1            = 178
	ECLParserU_00D2            = 179
	ECLParserU_00D3            = 180
	ECLParserU_00D4            = 181
	ECLParserU_00D5            = 182
	ECLParserU_00D6            = 183
	ECLParserU_00D7            = 184
	ECLParserU_00D8            = 185
	ECLParserU_00D9            = 186
	ECLParserU_00DA            = 187
	ECLParserU_00DB            = 188
	ECLParserU_00DC            = 189
	ECLParserU_00DD            = 190
	ECLParserU_00DE            = 191
	ECLParserU_00DF            = 192
	ECLParserU_00E0            = 193
	ECLParserU_00E1            = 194
	ECLParserU_00E2            = 195
	ECLParserU_00E3            = 196
	ECLParserU_00E4            = 197
	ECLParserU_00E5            = 198
	ECLParserU_00E6            = 199
	ECLParserU_00E7            = 200
	ECLParserU_00E8            = 201
	ECLParserU_00E9            = 202
	ECLParserU_00EA            = 203
	ECLParserU_00EB            = 204
	ECLParserU_00EC            = 205
	ECLParserU_00ED            = 206
	ECLParserU_00EE            = 207
	ECLParserU_00EF            = 208
	ECLParserU_00F0            = 209
	ECLParserU_00F1            = 210
	ECLParserU_00F2            = 211
	ECLParserU_00F3            = 212
	ECLParserU_00F4            = 213
)

// ECLParser rules.
const (
	ECLParserRULE_expressionconstraint            = 0
	ECLParserRULE_refinedexpressionconstraint     = 1
	ECLParserRULE_compoundexpressionconstraint    = 2
	ECLParserRULE_conjunctionexpressionconstraint = 3
	ECLParserRULE_disjunctionexpressionconstraint = 4
	ECLParserRULE_exclusionexpressionconstraint   = 5
	ECLParserRULE_dottedexpressionconstraint      = 6
	ECLParserRULE_dottedexpressionattribute       = 7
	ECLParserRULE_subexpressionconstraint         = 8
	ECLParserRULE_eclfocusconcept                 = 9
	ECLParserRULE_dot                             = 10
	ECLParserRULE_memberof                        = 11
	ECLParserRULE_eclconceptreference             = 12
	ECLParserRULE_conceptid                       = 13
	ECLParserRULE_term                            = 14
	ECLParserRULE_wildcard                        = 15
	ECLParserRULE_constraintoperator              = 16
	ECLParserRULE_descendantof                    = 17
	ECLParserRULE_descendantorselfof              = 18
	ECLParserRULE_childof                         = 19
	ECLParserRULE_ancestorof                      = 20
	ECLParserRULE_ancestororselfof                = 21
	ECLParserRULE_parentof                        = 22
	ECLParserRULE_conjunction                     = 23
	ECLParserRULE_disjunction                     = 24
	ECLParserRULE_exclusion                       = 25
	ECLParserRULE_eclrefinement                   = 26
	ECLParserRULE_conjunctionrefinementset        = 27
	ECLParserRULE_disjunctionrefinementset        = 28
	ECLParserRULE_subrefinement                   = 29
	ECLParserRULE_eclattributeset                 = 30
	ECLParserRULE_conjunctionattributeset         = 31
	ECLParserRULE_disjunctionattributeset         = 32
	ECLParserRULE_subattributeset                 = 33
	ECLParserRULE_eclattributegroup               = 34
	ECLParserRULE_eclattribute                    = 35
	ECLParserRULE_cardinality                     = 36
	ECLParserRULE_minvalue                        = 37
	ECLParserRULE_to                              = 38
	ECLParserRULE_maxvalue                        = 39
	ECLParserRULE_many                            = 40
	ECLParserRULE_reverseflag                     = 41
	ECLParserRULE_eclattributename                = 42
	ECLParserRULE_expressioncomparisonoperator    = 43
	ECLParserRULE_numericcomparisonoperator       = 44
	ECLParserRULE_stringcomparisonoperator        = 45
	ECLParserRULE_numericvalue                    = 46
	ECLParserRULE_stringvalue                     = 47
	ECLParserRULE_integervalue                    = 48
	ECLParserRULE_decimalvalue                    = 49
	ECLParserRULE_nonnegativeintegervalue         = 50
	ECLParserRULE_sctid                           = 51
	ECLParserRULE_ws                              = 52
	ECLParserRULE_mws                             = 53
	ECLParserRULE_comment                         = 54
	ECLParserRULE_nonstarchar                     = 55
	ECLParserRULE_starwithnonfslash               = 56
	ECLParserRULE_nonfslash                       = 57
	ECLParserRULE_sp                              = 58
	ECLParserRULE_htab                            = 59
	ECLParserRULE_cr                              = 60
	ECLParserRULE_lf                              = 61
	ECLParserRULE_qm                              = 62
	ECLParserRULE_bs                              = 63
	ECLParserRULE_digit                           = 64
	ECLParserRULE_zero                            = 65
	ECLParserRULE_digitnonzero                    = 66
	ECLParserRULE_nonwsnonpipe                    = 67
	ECLParserRULE_anynonescapedchar               = 68
	ECLParserRULE_escapedchar                     = 69
	ECLParserRULE_utf8_2                          = 70
	ECLParserRULE_utf8_3                          = 71
	ECLParserRULE_utf8_4                          = 72
	ECLParserRULE_utf8_tail                       = 73
)

// IExpressionconstraintContext is an interface to support dynamic dispatch.
type IExpressionconstraintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpressionconstraintContext differentiates from other interfaces.
	IsExpressionconstraintContext()
}

type ExpressionconstraintContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionconstraintContext() *ExpressionconstraintContext {
	var p = new(ExpressionconstraintContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ECLParserRULE_expressionconstraint
	return p
}

func (*ExpressionconstraintContext) IsExpressionconstraintContext() {}

func NewExpressionconstraintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionconstraintContext {
	var p = new(ExpressionconstraintContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ECLParserRULE_expressionconstraint

	return p
}

func (s *ExpressionconstraintContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionconstraintContext) AllWs() []IWsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IWsContext)(nil)).Elem())
	var tst = make([]IWsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IWsContext)
		}
	}

	return tst
}

func (s *ExpressionconstraintContext) Ws(i int) IWsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IWsContext)
}

func (s *ExpressionconstraintContext) Refinedexpressionconstraint() IRefinedexpressionconstraintContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRefinedexpressionconstraintContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRefinedexpressionconstraintContext)
}

func (s *ExpressionconstraintContext) Compoundexpressionconstraint() ICompoundexpressionconstraintContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICompoundexpressionconstraintContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICompoundexpressionconstraintContext)
}

func (s *ExpressionconstraintContext) Dottedexpressionconstraint() IDottedexpressionconstraintContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDottedexpressionconstraintContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDottedexpressionconstraintContext)
}

func (s *ExpressionconstraintContext) Subexpressionconstraint() ISubexpressionconstraintContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubexpressionconstraintContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubexpressionconstraintContext)
}

func (s *ExpressionconstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionconstraintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionconstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ECLListener); ok {
		listenerT.EnterExpressionconstraint(s)
	}
}

func (s *ExpressionconstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ECLListener); ok {
		listenerT.ExitExpressionconstraint(s)
	}
}

func (s *ExpressionconstraintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ECLVisitor:
		return t.VisitExpressionconstraint(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ECLParser) Expressionconstraint() (localctx IExpressionconstraintContext) {
	localctx = NewExpressionconstraintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, ECLParserRULE_expressionconstraint)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(148)
		p.Ws()
	}
	p.SetState(153)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 0, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(149)
			p.Refinedexpressionconstraint()
		}

	case 2:
		{
			p.SetState(150)
			p.Compoundexpressionconstraint()
		}

	case 3:
		{
			p.SetState(151)
			p.Dottedexpressionconstraint()
		}

	case 4:
		{
			p.SetState(152)
			p.Subexpressionconstraint()
		}

	}
	{
		p.SetState(155)
		p.Ws()
	}

	return localctx
}

// IRefinedexpressionconstraintContext is an interface to support dynamic dispatch.
type IRefinedexpressionconstraintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRefinedexpressionconstraintContext differentiates from other interfaces.
	IsRefinedexpressionconstraintContext()
}

type RefinedexpressionconstraintContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRefinedexpressionconstraintContext() *RefinedexpressionconstraintContext {
	var p = new(RefinedexpressionconstraintContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ECLParserRULE_refinedexpressionconstraint
	return p
}

func (*RefinedexpressionconstraintContext) IsRefinedexpressionconstraintContext() {}

func NewRefinedexpressionconstraintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RefinedexpressionconstraintContext {
	var p = new(RefinedexpressionconstraintContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ECLParserRULE_refinedexpressionconstraint

	return p
}

func (s *RefinedexpressionconstraintContext) GetParser() antlr.Parser { return s.parser }

func (s *RefinedexpressionconstraintContext) Subexpressionconstraint() ISubexpressionconstraintContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubexpressionconstraintContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubexpressionconstraintContext)
}

func (s *RefinedexpressionconstraintContext) AllWs() []IWsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IWsContext)(nil)).Elem())
	var tst = make([]IWsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IWsContext)
		}
	}

	return tst
}

func (s *RefinedexpressionconstraintContext) Ws(i int) IWsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IWsContext)
}

func (s *RefinedexpressionconstraintContext) COLON() antlr.TerminalNode {
	return s.GetToken(ECLParserCOLON, 0)
}

func (s *RefinedexpressionconstraintContext) Eclrefinement() IEclrefinementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEclrefinementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEclrefinementContext)
}

func (s *RefinedexpressionconstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RefinedexpressionconstraintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RefinedexpressionconstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ECLListener); ok {
		listenerT.EnterRefinedexpressionconstraint(s)
	}
}

func (s *RefinedexpressionconstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ECLListener); ok {
		listenerT.ExitRefinedexpressionconstraint(s)
	}
}

func (s *RefinedexpressionconstraintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ECLVisitor:
		return t.VisitRefinedexpressionconstraint(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ECLParser) Refinedexpressionconstraint() (localctx IRefinedexpressionconstraintContext) {
	localctx = NewRefinedexpressionconstraintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, ECLParserRULE_refinedexpressionconstraint)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(157)
		p.Subexpressionconstraint()
	}
	{
		p.SetState(158)
		p.Ws()
	}
	{
		p.SetState(159)
		p.Match(ECLParserCOLON)
	}
	{
		p.SetState(160)
		p.Ws()
	}
	{
		p.SetState(161)
		p.Eclrefinement()
	}

	return localctx
}

// ICompoundexpressionconstraintContext is an interface to support dynamic dispatch.
type ICompoundexpressionconstraintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCompoundexpressionconstraintContext differentiates from other interfaces.
	IsCompoundexpressionconstraintContext()
}

type CompoundexpressionconstraintContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCompoundexpressionconstraintContext() *CompoundexpressionconstraintContext {
	var p = new(CompoundexpressionconstraintContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ECLParserRULE_compoundexpressionconstraint
	return p
}

func (*CompoundexpressionconstraintContext) IsCompoundexpressionconstraintContext() {}

func NewCompoundexpressionconstraintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CompoundexpressionconstraintContext {
	var p = new(CompoundexpressionconstraintContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ECLParserRULE_compoundexpressionconstraint

	return p
}

func (s *CompoundexpressionconstraintContext) GetParser() antlr.Parser { return s.parser }

func (s *CompoundexpressionconstraintContext) Conjunctionexpressionconstraint() IConjunctionexpressionconstraintContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConjunctionexpressionconstraintContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConjunctionexpressionconstraintContext)
}

func (s *CompoundexpressionconstraintContext) Disjunctionexpressionconstraint() IDisjunctionexpressionconstraintContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDisjunctionexpressionconstraintContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDisjunctionexpressionconstraintContext)
}

func (s *CompoundexpressionconstraintContext) Exclusionexpressionconstraint() IExclusionexpressionconstraintContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExclusionexpressionconstraintContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExclusionexpressionconstraintContext)
}

func (s *CompoundexpressionconstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CompoundexpressionconstraintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CompoundexpressionconstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ECLListener); ok {
		listenerT.EnterCompoundexpressionconstraint(s)
	}
}

func (s *CompoundexpressionconstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ECLListener); ok {
		listenerT.ExitCompoundexpressionconstraint(s)
	}
}

func (s *CompoundexpressionconstraintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ECLVisitor:
		return t.VisitCompoundexpressionconstraint(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ECLParser) Compoundexpressionconstraint() (localctx ICompoundexpressionconstraintContext) {
	localctx = NewCompoundexpressionconstraintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, ECLParserRULE_compoundexpressionconstraint)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(166)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 1, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(163)
			p.Conjunctionexpressionconstraint()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(164)
			p.Disjunctionexpressionconstraint()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(165)
			p.Exclusionexpressionconstraint()
		}

	}

	return localctx
}

// IConjunctionexpressionconstraintContext is an interface to support dynamic dispatch.
type IConjunctionexpressionconstraintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConjunctionexpressionconstraintContext differentiates from other interfaces.
	IsConjunctionexpressionconstraintContext()
}

type ConjunctionexpressionconstraintContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConjunctionexpressionconstraintContext() *ConjunctionexpressionconstraintContext {
	var p = new(ConjunctionexpressionconstraintContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ECLParserRULE_conjunctionexpressionconstraint
	return p
}

func (*ConjunctionexpressionconstraintContext) IsConjunctionexpressionconstraintContext() {}

func NewConjunctionexpressionconstraintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConjunctionexpressionconstraintContext {
	var p = new(ConjunctionexpressionconstraintContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ECLParserRULE_conjunctionexpressionconstraint

	return p
}

func (s *ConjunctionexpressionconstraintContext) GetParser() antlr.Parser { return s.parser }

func (s *ConjunctionexpressionconstraintContext) AllSubexpressionconstraint() []ISubexpressionconstraintContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISubexpressionconstraintContext)(nil)).Elem())
	var tst = make([]ISubexpressionconstraintContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISubexpressionconstraintContext)
		}
	}

	return tst
}

func (s *ConjunctionexpressionconstraintContext) Subexpressionconstraint(i int) ISubexpressionconstraintContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubexpressionconstraintContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISubexpressionconstraintContext)
}

func (s *ConjunctionexpressionconstraintContext) AllWs() []IWsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IWsContext)(nil)).Elem())
	var tst = make([]IWsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IWsContext)
		}
	}

	return tst
}

func (s *ConjunctionexpressionconstraintContext) Ws(i int) IWsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IWsContext)
}

func (s *ConjunctionexpressionconstraintContext) AllConjunction() []IConjunctionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IConjunctionContext)(nil)).Elem())
	var tst = make([]IConjunctionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IConjunctionContext)
		}
	}

	return tst
}

func (s *ConjunctionexpressionconstraintContext) Conjunction(i int) IConjunctionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConjunctionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IConjunctionContext)
}

func (s *ConjunctionexpressionconstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConjunctionexpressionconstraintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConjunctionexpressionconstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ECLListener); ok {
		listenerT.EnterConjunctionexpressionconstraint(s)
	}
}

func (s *ConjunctionexpressionconstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ECLListener); ok {
		listenerT.ExitConjunctionexpressionconstraint(s)
	}
}

func (s *ConjunctionexpressionconstraintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ECLVisitor:
		return t.VisitConjunctionexpressionconstraint(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ECLParser) Conjunctionexpressionconstraint() (localctx IConjunctionexpressionconstraintContext) {
	localctx = NewConjunctionexpressionconstraintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, ECLParserRULE_conjunctionexpressionconstraint)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(168)
		p.Subexpressionconstraint()
	}
	p.SetState(174)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(169)
				p.Ws()
			}
			{
				p.SetState(170)
				p.Conjunction()
			}
			{
				p.SetState(171)
				p.Ws()
			}
			{
				p.SetState(172)
				p.Subexpressionconstraint()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(176)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 2, p.GetParserRuleContext())
	}

	return localctx
}

// IDisjunctionexpressionconstraintContext is an interface to support dynamic dispatch.
type IDisjunctionexpressionconstraintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDisjunctionexpressionconstraintContext differentiates from other interfaces.
	IsDisjunctionexpressionconstraintContext()
}

type DisjunctionexpressionconstraintContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDisjunctionexpressionconstraintContext() *DisjunctionexpressionconstraintContext {
	var p = new(DisjunctionexpressionconstraintContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ECLParserRULE_disjunctionexpressionconstraint
	return p
}

func (*DisjunctionexpressionconstraintContext) IsDisjunctionexpressionconstraintContext() {}

func NewDisjunctionexpressionconstraintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DisjunctionexpressionconstraintContext {
	var p = new(DisjunctionexpressionconstraintContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ECLParserRULE_disjunctionexpressionconstraint

	return p
}

func (s *DisjunctionexpressionconstraintContext) GetParser() antlr.Parser { return s.parser }

func (s *DisjunctionexpressionconstraintContext) AllSubexpressionconstraint() []ISubexpressionconstraintContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISubexpressionconstraintContext)(nil)).Elem())
	var tst = make([]ISubexpressionconstraintContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISubexpressionconstraintContext)
		}
	}

	return tst
}

func (s *DisjunctionexpressionconstraintContext) Subexpressionconstraint(i int) ISubexpressionconstraintContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubexpressionconstraintContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISubexpressionconstraintContext)
}

func (s *DisjunctionexpressionconstraintContext) AllWs() []IWsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IWsContext)(nil)).Elem())
	var tst = make([]IWsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IWsContext)
		}
	}

	return tst
}

func (s *DisjunctionexpressionconstraintContext) Ws(i int) IWsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IWsContext)
}

func (s *DisjunctionexpressionconstraintContext) AllDisjunction() []IDisjunctionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDisjunctionContext)(nil)).Elem())
	var tst = make([]IDisjunctionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDisjunctionContext)
		}
	}

	return tst
}

func (s *DisjunctionexpressionconstraintContext) Disjunction(i int) IDisjunctionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDisjunctionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDisjunctionContext)
}

func (s *DisjunctionexpressionconstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DisjunctionexpressionconstraintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DisjunctionexpressionconstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ECLListener); ok {
		listenerT.EnterDisjunctionexpressionconstraint(s)
	}
}

func (s *DisjunctionexpressionconstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ECLListener); ok {
		listenerT.ExitDisjunctionexpressionconstraint(s)
	}
}

func (s *DisjunctionexpressionconstraintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ECLVisitor:
		return t.VisitDisjunctionexpressionconstraint(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ECLParser) Disjunctionexpressionconstraint() (localctx IDisjunctionexpressionconstraintContext) {
	localctx = NewDisjunctionexpressionconstraintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, ECLParserRULE_disjunctionexpressionconstraint)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(178)
		p.Subexpressionconstraint()
	}
	p.SetState(184)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(179)
				p.Ws()
			}
			{
				p.SetState(180)
				p.Disjunction()
			}
			{
				p.SetState(181)
				p.Ws()
			}
			{
				p.SetState(182)
				p.Subexpressionconstraint()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(186)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 3, p.GetParserRuleContext())
	}

	return localctx
}

// IExclusionexpressionconstraintContext is an interface to support dynamic dispatch.
type IExclusionexpressionconstraintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExclusionexpressionconstraintContext differentiates from other interfaces.
	IsExclusionexpressionconstraintContext()
}

type ExclusionexpressionconstraintContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExclusionexpressionconstraintContext() *ExclusionexpressionconstraintContext {
	var p = new(ExclusionexpressionconstraintContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ECLParserRULE_exclusionexpressionconstraint
	return p
}

func (*ExclusionexpressionconstraintContext) IsExclusionexpressionconstraintContext() {}

func NewExclusionexpressionconstraintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExclusionexpressionconstraintContext {
	var p = new(ExclusionexpressionconstraintContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ECLParserRULE_exclusionexpressionconstraint

	return p
}

func (s *ExclusionexpressionconstraintContext) GetParser() antlr.Parser { return s.parser }

func (s *ExclusionexpressionconstraintContext) AllSubexpressionconstraint() []ISubexpressionconstraintContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISubexpressionconstraintContext)(nil)).Elem())
	var tst = make([]ISubexpressionconstraintContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISubexpressionconstraintContext)
		}
	}

	return tst
}

func (s *ExclusionexpressionconstraintContext) Subexpressionconstraint(i int) ISubexpressionconstraintContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubexpressionconstraintContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISubexpressionconstraintContext)
}

func (s *ExclusionexpressionconstraintContext) AllWs() []IWsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IWsContext)(nil)).Elem())
	var tst = make([]IWsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IWsContext)
		}
	}

	return tst
}

func (s *ExclusionexpressionconstraintContext) Ws(i int) IWsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IWsContext)
}

func (s *ExclusionexpressionconstraintContext) Exclusion() IExclusionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExclusionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExclusionContext)
}

func (s *ExclusionexpressionconstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExclusionexpressionconstraintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExclusionexpressionconstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ECLListener); ok {
		listenerT.EnterExclusionexpressionconstraint(s)
	}
}

func (s *ExclusionexpressionconstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ECLListener); ok {
		listenerT.ExitExclusionexpressionconstraint(s)
	}
}

func (s *ExclusionexpressionconstraintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ECLVisitor:
		return t.VisitExclusionexpressionconstraint(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ECLParser) Exclusionexpressionconstraint() (localctx IExclusionexpressionconstraintContext) {
	localctx = NewExclusionexpressionconstraintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, ECLParserRULE_exclusionexpressionconstraint)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(188)
		p.Subexpressionconstraint()
	}
	{
		p.SetState(189)
		p.Ws()
	}
	{
		p.SetState(190)
		p.Exclusion()
	}
	{
		p.SetState(191)
		p.Ws()
	}
	{
		p.SetState(192)
		p.Subexpressionconstraint()
	}

	return localctx
}

// IDottedexpressionconstraintContext is an interface to support dynamic dispatch.
type IDottedexpressionconstraintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDottedexpressionconstraintContext differentiates from other interfaces.
	IsDottedexpressionconstraintContext()
}

type DottedexpressionconstraintContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDottedexpressionconstraintContext() *DottedexpressionconstraintContext {
	var p = new(DottedexpressionconstraintContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ECLParserRULE_dottedexpressionconstraint
	return p
}

func (*DottedexpressionconstraintContext) IsDottedexpressionconstraintContext() {}

func NewDottedexpressionconstraintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DottedexpressionconstraintContext {
	var p = new(DottedexpressionconstraintContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ECLParserRULE_dottedexpressionconstraint

	return p
}

func (s *DottedexpressionconstraintContext) GetParser() antlr.Parser { return s.parser }

func (s *DottedexpressionconstraintContext) Subexpressionconstraint() ISubexpressionconstraintContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubexpressionconstraintContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubexpressionconstraintContext)
}

func (s *DottedexpressionconstraintContext) AllWs() []IWsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IWsContext)(nil)).Elem())
	var tst = make([]IWsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IWsContext)
		}
	}

	return tst
}

func (s *DottedexpressionconstraintContext) Ws(i int) IWsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IWsContext)
}

func (s *DottedexpressionconstraintContext) AllDottedexpressionattribute() []IDottedexpressionattributeContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDottedexpressionattributeContext)(nil)).Elem())
	var tst = make([]IDottedexpressionattributeContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDottedexpressionattributeContext)
		}
	}

	return tst
}

func (s *DottedexpressionconstraintContext) Dottedexpressionattribute(i int) IDottedexpressionattributeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDottedexpressionattributeContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDottedexpressionattributeContext)
}

func (s *DottedexpressionconstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DottedexpressionconstraintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DottedexpressionconstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ECLListener); ok {
		listenerT.EnterDottedexpressionconstraint(s)
	}
}

func (s *DottedexpressionconstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ECLListener); ok {
		listenerT.ExitDottedexpressionconstraint(s)
	}
}

func (s *DottedexpressionconstraintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ECLVisitor:
		return t.VisitDottedexpressionconstraint(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ECLParser) Dottedexpressionconstraint() (localctx IDottedexpressionconstraintContext) {
	localctx = NewDottedexpressionconstraintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, ECLParserRULE_dottedexpressionconstraint)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(194)
		p.Subexpressionconstraint()
	}
	p.SetState(198)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(195)
				p.Ws()
			}
			{
				p.SetState(196)
				p.Dottedexpressionattribute()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(200)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 4, p.GetParserRuleContext())
	}

	return localctx
}

// IDottedexpressionattributeContext is an interface to support dynamic dispatch.
type IDottedexpressionattributeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDottedexpressionattributeContext differentiates from other interfaces.
	IsDottedexpressionattributeContext()
}

type DottedexpressionattributeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDottedexpressionattributeContext() *DottedexpressionattributeContext {
	var p = new(DottedexpressionattributeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ECLParserRULE_dottedexpressionattribute
	return p
}

func (*DottedexpressionattributeContext) IsDottedexpressionattributeContext() {}

func NewDottedexpressionattributeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DottedexpressionattributeContext {
	var p = new(DottedexpressionattributeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ECLParserRULE_dottedexpressionattribute

	return p
}

func (s *DottedexpressionattributeContext) GetParser() antlr.Parser { return s.parser }

func (s *DottedexpressionattributeContext) Dot() IDotContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDotContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDotContext)
}

func (s *DottedexpressionattributeContext) Ws() IWsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWsContext)
}

func (s *DottedexpressionattributeContext) Eclattributename() IEclattributenameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEclattributenameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEclattributenameContext)
}

func (s *DottedexpressionattributeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DottedexpressionattributeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DottedexpressionattributeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ECLListener); ok {
		listenerT.EnterDottedexpressionattribute(s)
	}
}

func (s *DottedexpressionattributeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ECLListener); ok {
		listenerT.ExitDottedexpressionattribute(s)
	}
}

func (s *DottedexpressionattributeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ECLVisitor:
		return t.VisitDottedexpressionattribute(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ECLParser) Dottedexpressionattribute() (localctx IDottedexpressionattributeContext) {
	localctx = NewDottedexpressionattributeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, ECLParserRULE_dottedexpressionattribute)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(202)
		p.Dot()
	}
	{
		p.SetState(203)
		p.Ws()
	}
	{
		p.SetState(204)
		p.Eclattributename()
	}

	return localctx
}

// ISubexpressionconstraintContext is an interface to support dynamic dispatch.
type ISubexpressionconstraintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSubexpressionconstraintContext differentiates from other interfaces.
	IsSubexpressionconstraintContext()
}

type SubexpressionconstraintContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubexpressionconstraintContext() *SubexpressionconstraintContext {
	var p = new(SubexpressionconstraintContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ECLParserRULE_subexpressionconstraint
	return p
}

func (*SubexpressionconstraintContext) IsSubexpressionconstraintContext() {}

func NewSubexpressionconstraintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SubexpressionconstraintContext {
	var p = new(SubexpressionconstraintContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ECLParserRULE_subexpressionconstraint

	return p
}

func (s *SubexpressionconstraintContext) GetParser() antlr.Parser { return s.parser }

func (s *SubexpressionconstraintContext) Eclfocusconcept() IEclfocusconceptContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEclfocusconceptContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEclfocusconceptContext)
}

func (s *SubexpressionconstraintContext) Constraintoperator() IConstraintoperatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstraintoperatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstraintoperatorContext)
}

func (s *SubexpressionconstraintContext) AllWs() []IWsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IWsContext)(nil)).Elem())
	var tst = make([]IWsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IWsContext)
		}
	}

	return tst
}

func (s *SubexpressionconstraintContext) Ws(i int) IWsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IWsContext)
}

func (s *SubexpressionconstraintContext) Memberof() IMemberofContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMemberofContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMemberofContext)
}

func (s *SubexpressionconstraintContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(ECLParserLEFT_PAREN, 0)
}

func (s *SubexpressionconstraintContext) Expressionconstraint() IExpressionconstraintContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionconstraintContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionconstraintContext)
}

func (s *SubexpressionconstraintContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(ECLParserRIGHT_PAREN, 0)
}

func (s *SubexpressionconstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubexpressionconstraintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SubexpressionconstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ECLListener); ok {
		listenerT.EnterSubexpressionconstraint(s)
	}
}

func (s *SubexpressionconstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ECLListener); ok {
		listenerT.ExitSubexpressionconstraint(s)
	}
}

func (s *SubexpressionconstraintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ECLVisitor:
		return t.VisitSubexpressionconstraint(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ECLParser) Subexpressionconstraint() (localctx ISubexpressionconstraintContext) {
	localctx = NewSubexpressionconstraintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, ECLParserRULE_subexpressionconstraint)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(209)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ECLParserLESS_THAN || _la == ECLParserGREATER_THAN {
		{
			p.SetState(206)
			p.Constraintoperator()
		}
		{
			p.SetState(207)
			p.Ws()
		}

	}
	p.SetState(214)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ECLParserCARAT {
		{
			p.SetState(211)
			p.Memberof()
		}
		{
			p.SetState(212)
			p.Ws()
		}

	}
	p.SetState(223)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ECLParserASTERISK, ECLParserONE, ECLParserTWO, ECLParserTHREE, ECLParserFOUR, ECLParserFIVE, ECLParserSIX, ECLParserSEVEN, ECLParserEIGHT, ECLParserNINE:
		{
			p.SetState(216)
			p.Eclfocusconcept()
		}

	case ECLParserLEFT_PAREN:
		{
			p.SetState(217)
			p.Match(ECLParserLEFT_PAREN)
		}
		{
			p.SetState(218)
			p.Ws()
		}
		{
			p.SetState(219)
			p.Expressionconstraint()
		}
		{
			p.SetState(220)
			p.Ws()
		}
		{
			p.SetState(221)
			p.Match(ECLParserRIGHT_PAREN)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IEclfocusconceptContext is an interface to support dynamic dispatch.
type IEclfocusconceptContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEclfocusconceptContext differentiates from other interfaces.
	IsEclfocusconceptContext()
}

type EclfocusconceptContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEclfocusconceptContext() *EclfocusconceptContext {
	var p = new(EclfocusconceptContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ECLParserRULE_eclfocusconcept
	return p
}

func (*EclfocusconceptContext) IsEclfocusconceptContext() {}

func NewEclfocusconceptContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EclfocusconceptContext {
	var p = new(EclfocusconceptContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ECLParserRULE_eclfocusconcept

	return p
}

func (s *EclfocusconceptContext) GetParser() antlr.Parser { return s.parser }

func (s *EclfocusconceptContext) Eclconceptreference() IEclconceptreferenceContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEclconceptreferenceContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEclconceptreferenceContext)
}

func (s *EclfocusconceptContext) Wildcard() IWildcardContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWildcardContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWildcardContext)
}

func (s *EclfocusconceptContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EclfocusconceptContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EclfocusconceptContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ECLListener); ok {
		listenerT.EnterEclfocusconcept(s)
	}
}

func (s *EclfocusconceptContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ECLListener); ok {
		listenerT.ExitEclfocusconcept(s)
	}
}

func (s *EclfocusconceptContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ECLVisitor:
		return t.VisitEclfocusconcept(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ECLParser) Eclfocusconcept() (localctx IEclfocusconceptContext) {
	localctx = NewEclfocusconceptContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, ECLParserRULE_eclfocusconcept)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(227)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ECLParserONE, ECLParserTWO, ECLParserTHREE, ECLParserFOUR, ECLParserFIVE, ECLParserSIX, ECLParserSEVEN, ECLParserEIGHT, ECLParserNINE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(225)
			p.Eclconceptreference()
		}

	case ECLParserASTERISK:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(226)
			p.Wildcard()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IDotContext is an interface to support dynamic dispatch.
type IDotContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDotContext differentiates from other interfaces.
	IsDotContext()
}

type DotContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDotContext() *DotContext {
	var p = new(DotContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ECLParserRULE_dot
	return p
}

func (*DotContext) IsDotContext() {}

func NewDotContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DotContext {
	var p = new(DotContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ECLParserRULE_dot

	return p
}

func (s *DotContext) GetParser() antlr.Parser { return s.parser }

func (s *DotContext) PERIOD() antlr.TerminalNode {
	return s.GetToken(ECLParserPERIOD, 0)
}

func (s *DotContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DotContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DotContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ECLListener); ok {
		listenerT.EnterDot(s)
	}
}

func (s *DotContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ECLListener); ok {
		listenerT.ExitDot(s)
	}
}

func (s *DotContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ECLVisitor:
		return t.VisitDot(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ECLParser) Dot() (localctx IDotContext) {
	localctx = NewDotContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, ECLParserRULE_dot)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(229)
		p.Match(ECLParserPERIOD)
	}

	return localctx
}

// IMemberofContext is an interface to support dynamic dispatch.
type IMemberofContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMemberofContext differentiates from other interfaces.
	IsMemberofContext()
}

type MemberofContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMemberofContext() *MemberofContext {
	var p = new(MemberofContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ECLParserRULE_memberof
	return p
}

func (*MemberofContext) IsMemberofContext() {}

func NewMemberofContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MemberofContext {
	var p = new(MemberofContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ECLParserRULE_memberof

	return p
}

func (s *MemberofContext) GetParser() antlr.Parser { return s.parser }

func (s *MemberofContext) CARAT() antlr.TerminalNode {
	return s.GetToken(ECLParserCARAT, 0)
}

func (s *MemberofContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MemberofContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MemberofContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ECLListener); ok {
		listenerT.EnterMemberof(s)
	}
}

func (s *MemberofContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ECLListener); ok {
		listenerT.ExitMemberof(s)
	}
}

func (s *MemberofContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ECLVisitor:
		return t.VisitMemberof(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ECLParser) Memberof() (localctx IMemberofContext) {
	localctx = NewMemberofContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, ECLParserRULE_memberof)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(231)
		p.Match(ECLParserCARAT)
	}

	return localctx
}

// IEclconceptreferenceContext is an interface to support dynamic dispatch.
type IEclconceptreferenceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEclconceptreferenceContext differentiates from other interfaces.
	IsEclconceptreferenceContext()
}

type EclconceptreferenceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEclconceptreferenceContext() *EclconceptreferenceContext {
	var p = new(EclconceptreferenceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ECLParserRULE_eclconceptreference
	return p
}

func (*EclconceptreferenceContext) IsEclconceptreferenceContext() {}

func NewEclconceptreferenceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EclconceptreferenceContext {
	var p = new(EclconceptreferenceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ECLParserRULE_eclconceptreference

	return p
}

func (s *EclconceptreferenceContext) GetParser() antlr.Parser { return s.parser }

func (s *EclconceptreferenceContext) Conceptid() IConceptidContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConceptidContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConceptidContext)
}

func (s *EclconceptreferenceContext) AllWs() []IWsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IWsContext)(nil)).Elem())
	var tst = make([]IWsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IWsContext)
		}
	}

	return tst
}

func (s *EclconceptreferenceContext) Ws(i int) IWsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IWsContext)
}

func (s *EclconceptreferenceContext) AllPIPE() []antlr.TerminalNode {
	return s.GetTokens(ECLParserPIPE)
}

func (s *EclconceptreferenceContext) PIPE(i int) antlr.TerminalNode {
	return s.GetToken(ECLParserPIPE, i)
}

func (s *EclconceptreferenceContext) Term() ITermContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITermContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITermContext)
}

func (s *EclconceptreferenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EclconceptreferenceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EclconceptreferenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ECLListener); ok {
		listenerT.EnterEclconceptreference(s)
	}
}

func (s *EclconceptreferenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ECLListener); ok {
		listenerT.ExitEclconceptreference(s)
	}
}

func (s *EclconceptreferenceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ECLVisitor:
		return t.VisitEclconceptreference(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ECLParser) Eclconceptreference() (localctx IEclconceptreferenceContext) {
	localctx = NewEclconceptreferenceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, ECLParserRULE_eclconceptreference)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(233)
		p.Conceptid()
	}
	p.SetState(241)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 9, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(234)
			p.Ws()
		}
		{
			p.SetState(235)
			p.Match(ECLParserPIPE)
		}
		{
			p.SetState(236)
			p.Ws()
		}
		{
			p.SetState(237)
			p.Term()
		}
		{
			p.SetState(238)
			p.Ws()
		}
		{
			p.SetState(239)
			p.Match(ECLParserPIPE)
		}

	}

	return localctx
}

// IConceptidContext is an interface to support dynamic dispatch.
type IConceptidContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConceptidContext differentiates from other interfaces.
	IsConceptidContext()
}

type ConceptidContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConceptidContext() *ConceptidContext {
	var p = new(ConceptidContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ECLParserRULE_conceptid
	return p
}

func (*ConceptidContext) IsConceptidContext() {}

func NewConceptidContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConceptidContext {
	var p = new(ConceptidContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ECLParserRULE_conceptid

	return p
}

func (s *ConceptidContext) GetParser() antlr.Parser { return s.parser }

func (s *ConceptidContext) Sctid() ISctidContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISctidContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISctidContext)
}

func (s *ConceptidContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConceptidContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConceptidContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ECLListener); ok {
		listenerT.EnterConceptid(s)
	}
}

func (s *ConceptidContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ECLListener); ok {
		listenerT.ExitConceptid(s)
	}
}

func (s *ConceptidContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ECLVisitor:
		return t.VisitConceptid(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ECLParser) Conceptid() (localctx IConceptidContext) {
	localctx = NewConceptidContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, ECLParserRULE_conceptid)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(243)
		p.Sctid()
	}

	return localctx
}

// ITermContext is an interface to support dynamic dispatch.
type ITermContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTermContext differentiates from other interfaces.
	IsTermContext()
}

type TermContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTermContext() *TermContext {
	var p = new(TermContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ECLParserRULE_term
	return p
}

func (*TermContext) IsTermContext() {}

func NewTermContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TermContext {
	var p = new(TermContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ECLParserRULE_term

	return p
}

func (s *TermContext) GetParser() antlr.Parser { return s.parser }

func (s *TermContext) AllNonwsnonpipe() []INonwsnonpipeContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INonwsnonpipeContext)(nil)).Elem())
	var tst = make([]INonwsnonpipeContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INonwsnonpipeContext)
		}
	}

	return tst
}

func (s *TermContext) Nonwsnonpipe(i int) INonwsnonpipeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INonwsnonpipeContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INonwsnonpipeContext)
}

func (s *TermContext) AllSp() []ISpContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISpContext)(nil)).Elem())
	var tst = make([]ISpContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISpContext)
		}
	}

	return tst
}

func (s *TermContext) Sp(i int) ISpContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISpContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISpContext)
}

func (s *TermContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TermContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TermContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ECLListener); ok {
		listenerT.EnterTerm(s)
	}
}

func (s *TermContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ECLListener); ok {
		listenerT.ExitTerm(s)
	}
}

func (s *TermContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ECLVisitor:
		return t.VisitTerm(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ECLParser) Term() (localctx ITermContext) {
	localctx = NewTermContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, ECLParserRULE_term)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(246)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(245)
				p.Nonwsnonpipe()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(248)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 10, p.GetParserRuleContext())
	}
	p.SetState(262)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 13, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(251)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for ok := true; ok; ok = _la == ECLParserSPACE {
				{
					p.SetState(250)
					p.Sp()
				}

				p.SetState(253)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			p.SetState(256)
			p.GetErrorHandler().Sync(p)
			_alt = 1
			for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
				switch _alt {
				case 1:
					{
						p.SetState(255)
						p.Nonwsnonpipe()
					}

				default:
					panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				}

				p.SetState(258)
				p.GetErrorHandler().Sync(p)
				_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 12, p.GetParserRuleContext())
			}

		}
		p.SetState(264)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 13, p.GetParserRuleContext())
	}

	return localctx
}

// IWildcardContext is an interface to support dynamic dispatch.
type IWildcardContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWildcardContext differentiates from other interfaces.
	IsWildcardContext()
}

type WildcardContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWildcardContext() *WildcardContext {
	var p = new(WildcardContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ECLParserRULE_wildcard
	return p
}

func (*WildcardContext) IsWildcardContext() {}

func NewWildcardContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WildcardContext {
	var p = new(WildcardContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ECLParserRULE_wildcard

	return p
}

func (s *WildcardContext) GetParser() antlr.Parser { return s.parser }

func (s *WildcardContext) ASTERISK() antlr.TerminalNode {
	return s.GetToken(ECLParserASTERISK, 0)
}

func (s *WildcardContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WildcardContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WildcardContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ECLListener); ok {
		listenerT.EnterWildcard(s)
	}
}

func (s *WildcardContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ECLListener); ok {
		listenerT.ExitWildcard(s)
	}
}

func (s *WildcardContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ECLVisitor:
		return t.VisitWildcard(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ECLParser) Wildcard() (localctx IWildcardContext) {
	localctx = NewWildcardContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, ECLParserRULE_wildcard)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(265)
		p.Match(ECLParserASTERISK)
	}

	return localctx
}

// IConstraintoperatorContext is an interface to support dynamic dispatch.
type IConstraintoperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConstraintoperatorContext differentiates from other interfaces.
	IsConstraintoperatorContext()
}

type ConstraintoperatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstraintoperatorContext() *ConstraintoperatorContext {
	var p = new(ConstraintoperatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ECLParserRULE_constraintoperator
	return p
}

func (*ConstraintoperatorContext) IsConstraintoperatorContext() {}

func NewConstraintoperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstraintoperatorContext {
	var p = new(ConstraintoperatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ECLParserRULE_constraintoperator

	return p
}

func (s *ConstraintoperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstraintoperatorContext) Childof() IChildofContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IChildofContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IChildofContext)
}

func (s *ConstraintoperatorContext) Descendantorselfof() IDescendantorselfofContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDescendantorselfofContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDescendantorselfofContext)
}

func (s *ConstraintoperatorContext) Descendantof() IDescendantofContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDescendantofContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDescendantofContext)
}

func (s *ConstraintoperatorContext) Parentof() IParentofContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParentofContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParentofContext)
}

func (s *ConstraintoperatorContext) Ancestororselfof() IAncestororselfofContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAncestororselfofContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAncestororselfofContext)
}

func (s *ConstraintoperatorContext) Ancestorof() IAncestorofContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAncestorofContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAncestorofContext)
}

func (s *ConstraintoperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstraintoperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConstraintoperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ECLListener); ok {
		listenerT.EnterConstraintoperator(s)
	}
}

func (s *ConstraintoperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ECLListener); ok {
		listenerT.ExitConstraintoperator(s)
	}
}

func (s *ConstraintoperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ECLVisitor:
		return t.VisitConstraintoperator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ECLParser) Constraintoperator() (localctx IConstraintoperatorContext) {
	localctx = NewConstraintoperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, ECLParserRULE_constraintoperator)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(273)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 14, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(267)
			p.Childof()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(268)
			p.Descendantorselfof()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(269)
			p.Descendantof()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(270)
			p.Parentof()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(271)
			p.Ancestororselfof()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(272)
			p.Ancestorof()
		}

	}

	return localctx
}

// IDescendantofContext is an interface to support dynamic dispatch.
type IDescendantofContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDescendantofContext differentiates from other interfaces.
	IsDescendantofContext()
}

type DescendantofContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDescendantofContext() *DescendantofContext {
	var p = new(DescendantofContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ECLParserRULE_descendantof
	return p
}

func (*DescendantofContext) IsDescendantofContext() {}

func NewDescendantofContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DescendantofContext {
	var p = new(DescendantofContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ECLParserRULE_descendantof

	return p
}

func (s *DescendantofContext) GetParser() antlr.Parser { return s.parser }

func (s *DescendantofContext) LESS_THAN() antlr.TerminalNode {
	return s.GetToken(ECLParserLESS_THAN, 0)
}

func (s *DescendantofContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DescendantofContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DescendantofContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ECLListener); ok {
		listenerT.EnterDescendantof(s)
	}
}

func (s *DescendantofContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ECLListener); ok {
		listenerT.ExitDescendantof(s)
	}
}

func (s *DescendantofContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ECLVisitor:
		return t.VisitDescendantof(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ECLParser) Descendantof() (localctx IDescendantofContext) {
	localctx = NewDescendantofContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, ECLParserRULE_descendantof)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(275)
		p.Match(ECLParserLESS_THAN)
	}

	return localctx
}

// IDescendantorselfofContext is an interface to support dynamic dispatch.
type IDescendantorselfofContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDescendantorselfofContext differentiates from other interfaces.
	IsDescendantorselfofContext()
}

type DescendantorselfofContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDescendantorselfofContext() *DescendantorselfofContext {
	var p = new(DescendantorselfofContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ECLParserRULE_descendantorselfof
	return p
}

func (*DescendantorselfofContext) IsDescendantorselfofContext() {}

func NewDescendantorselfofContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DescendantorselfofContext {
	var p = new(DescendantorselfofContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ECLParserRULE_descendantorselfof

	return p
}

func (s *DescendantorselfofContext) GetParser() antlr.Parser { return s.parser }

func (s *DescendantorselfofContext) AllLESS_THAN() []antlr.TerminalNode {
	return s.GetTokens(ECLParserLESS_THAN)
}

func (s *DescendantorselfofContext) LESS_THAN(i int) antlr.TerminalNode {
	return s.GetToken(ECLParserLESS_THAN, i)
}

func (s *DescendantorselfofContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DescendantorselfofContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DescendantorselfofContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ECLListener); ok {
		listenerT.EnterDescendantorselfof(s)
	}
}

func (s *DescendantorselfofContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ECLListener); ok {
		listenerT.ExitDescendantorselfof(s)
	}
}

func (s *DescendantorselfofContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ECLVisitor:
		return t.VisitDescendantorselfof(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ECLParser) Descendantorselfof() (localctx IDescendantorselfofContext) {
	localctx = NewDescendantorselfofContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, ECLParserRULE_descendantorselfof)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(277)
		p.Match(ECLParserLESS_THAN)
	}
	{
		p.SetState(278)
		p.Match(ECLParserLESS_THAN)
	}

	return localctx
}

// IChildofContext is an interface to support dynamic dispatch.
type IChildofContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsChildofContext differentiates from other interfaces.
	IsChildofContext()
}

type ChildofContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyChildofContext() *ChildofContext {
	var p = new(ChildofContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ECLParserRULE_childof
	return p
}

func (*ChildofContext) IsChildofContext() {}

func NewChildofContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ChildofContext {
	var p = new(ChildofContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ECLParserRULE_childof

	return p
}

func (s *ChildofContext) GetParser() antlr.Parser { return s.parser }

func (s *ChildofContext) LESS_THAN() antlr.TerminalNode {
	return s.GetToken(ECLParserLESS_THAN, 0)
}

func (s *ChildofContext) EXCLAMATION() antlr.TerminalNode {
	return s.GetToken(ECLParserEXCLAMATION, 0)
}

func (s *ChildofContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ChildofContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ChildofContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ECLListener); ok {
		listenerT.EnterChildof(s)
	}
}

func (s *ChildofContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ECLListener); ok {
		listenerT.ExitChildof(s)
	}
}

func (s *ChildofContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ECLVisitor:
		return t.VisitChildof(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ECLParser) Childof() (localctx IChildofContext) {
	localctx = NewChildofContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, ECLParserRULE_childof)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(280)
		p.Match(ECLParserLESS_THAN)
	}
	{
		p.SetState(281)
		p.Match(ECLParserEXCLAMATION)
	}

	return localctx
}

// IAncestorofContext is an interface to support dynamic dispatch.
type IAncestorofContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAncestorofContext differentiates from other interfaces.
	IsAncestorofContext()
}

type AncestorofContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAncestorofContext() *AncestorofContext {
	var p = new(AncestorofContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ECLParserRULE_ancestorof
	return p
}

func (*AncestorofContext) IsAncestorofContext() {}

func NewAncestorofContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AncestorofContext {
	var p = new(AncestorofContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ECLParserRULE_ancestorof

	return p
}

func (s *AncestorofContext) GetParser() antlr.Parser { return s.parser }

func (s *AncestorofContext) GREATER_THAN() antlr.TerminalNode {
	return s.GetToken(ECLParserGREATER_THAN, 0)
}

func (s *AncestorofContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AncestorofContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AncestorofContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ECLListener); ok {
		listenerT.EnterAncestorof(s)
	}
}

func (s *AncestorofContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ECLListener); ok {
		listenerT.ExitAncestorof(s)
	}
}

func (s *AncestorofContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ECLVisitor:
		return t.VisitAncestorof(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ECLParser) Ancestorof() (localctx IAncestorofContext) {
	localctx = NewAncestorofContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, ECLParserRULE_ancestorof)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(283)
		p.Match(ECLParserGREATER_THAN)
	}

	return localctx
}

// IAncestororselfofContext is an interface to support dynamic dispatch.
type IAncestororselfofContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAncestororselfofContext differentiates from other interfaces.
	IsAncestororselfofContext()
}

type AncestororselfofContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAncestororselfofContext() *AncestororselfofContext {
	var p = new(AncestororselfofContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ECLParserRULE_ancestororselfof
	return p
}

func (*AncestororselfofContext) IsAncestororselfofContext() {}

func NewAncestororselfofContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AncestororselfofContext {
	var p = new(AncestororselfofContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ECLParserRULE_ancestororselfof

	return p
}

func (s *AncestororselfofContext) GetParser() antlr.Parser { return s.parser }

func (s *AncestororselfofContext) AllGREATER_THAN() []antlr.TerminalNode {
	return s.GetTokens(ECLParserGREATER_THAN)
}

func (s *AncestororselfofContext) GREATER_THAN(i int) antlr.TerminalNode {
	return s.GetToken(ECLParserGREATER_THAN, i)
}

func (s *AncestororselfofContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AncestororselfofContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AncestororselfofContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ECLListener); ok {
		listenerT.EnterAncestororselfof(s)
	}
}

func (s *AncestororselfofContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ECLListener); ok {
		listenerT.ExitAncestororselfof(s)
	}
}

func (s *AncestororselfofContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ECLVisitor:
		return t.VisitAncestororselfof(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ECLParser) Ancestororselfof() (localctx IAncestororselfofContext) {
	localctx = NewAncestororselfofContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, ECLParserRULE_ancestororselfof)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(285)
		p.Match(ECLParserGREATER_THAN)
	}
	{
		p.SetState(286)
		p.Match(ECLParserGREATER_THAN)
	}

	return localctx
}

// IParentofContext is an interface to support dynamic dispatch.
type IParentofContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParentofContext differentiates from other interfaces.
	IsParentofContext()
}

type ParentofContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParentofContext() *ParentofContext {
	var p = new(ParentofContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ECLParserRULE_parentof
	return p
}

func (*ParentofContext) IsParentofContext() {}

func NewParentofContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParentofContext {
	var p = new(ParentofContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ECLParserRULE_parentof

	return p
}

func (s *ParentofContext) GetParser() antlr.Parser { return s.parser }

func (s *ParentofContext) GREATER_THAN() antlr.TerminalNode {
	return s.GetToken(ECLParserGREATER_THAN, 0)
}

func (s *ParentofContext) EXCLAMATION() antlr.TerminalNode {
	return s.GetToken(ECLParserEXCLAMATION, 0)
}

func (s *ParentofContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParentofContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParentofContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ECLListener); ok {
		listenerT.EnterParentof(s)
	}
}

func (s *ParentofContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ECLListener); ok {
		listenerT.ExitParentof(s)
	}
}

func (s *ParentofContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ECLVisitor:
		return t.VisitParentof(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ECLParser) Parentof() (localctx IParentofContext) {
	localctx = NewParentofContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, ECLParserRULE_parentof)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(288)
		p.Match(ECLParserGREATER_THAN)
	}
	{
		p.SetState(289)
		p.Match(ECLParserEXCLAMATION)
	}

	return localctx
}

// IConjunctionContext is an interface to support dynamic dispatch.
type IConjunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConjunctionContext differentiates from other interfaces.
	IsConjunctionContext()
}

type ConjunctionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConjunctionContext() *ConjunctionContext {
	var p = new(ConjunctionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ECLParserRULE_conjunction
	return p
}

func (*ConjunctionContext) IsConjunctionContext() {}

func NewConjunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConjunctionContext {
	var p = new(ConjunctionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ECLParserRULE_conjunction

	return p
}

func (s *ConjunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *ConjunctionContext) Mws() IMwsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMwsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMwsContext)
}

func (s *ConjunctionContext) A() antlr.TerminalNode {
	return s.GetToken(ECLParserA, 0)
}

func (s *ConjunctionContext) CAP_A() antlr.TerminalNode {
	return s.GetToken(ECLParserCAP_A, 0)
}

func (s *ConjunctionContext) N() antlr.TerminalNode {
	return s.GetToken(ECLParserN, 0)
}

func (s *ConjunctionContext) CAP_N() antlr.TerminalNode {
	return s.GetToken(ECLParserCAP_N, 0)
}

func (s *ConjunctionContext) D() antlr.TerminalNode {
	return s.GetToken(ECLParserD, 0)
}

func (s *ConjunctionContext) CAP_D() antlr.TerminalNode {
	return s.GetToken(ECLParserCAP_D, 0)
}

func (s *ConjunctionContext) COMMA() antlr.TerminalNode {
	return s.GetToken(ECLParserCOMMA, 0)
}

func (s *ConjunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConjunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConjunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ECLListener); ok {
		listenerT.EnterConjunction(s)
	}
}

func (s *ConjunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ECLListener); ok {
		listenerT.ExitConjunction(s)
	}
}

func (s *ConjunctionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ECLVisitor:
		return t.VisitConjunction(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ECLParser) Conjunction() (localctx IConjunctionContext) {
	localctx = NewConjunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, ECLParserRULE_conjunction)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(296)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ECLParserCAP_A, ECLParserA:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(291)
			_la = p.GetTokenStream().LA(1)

			if !(_la == ECLParserCAP_A || _la == ECLParserA) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(292)
			_la = p.GetTokenStream().LA(1)

			if !(_la == ECLParserCAP_N || _la == ECLParserN) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(293)
			_la = p.GetTokenStream().LA(1)

			if !(_la == ECLParserCAP_D || _la == ECLParserD) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(294)
			p.Mws()
		}

	case ECLParserCOMMA:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(295)
			p.Match(ECLParserCOMMA)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IDisjunctionContext is an interface to support dynamic dispatch.
type IDisjunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDisjunctionContext differentiates from other interfaces.
	IsDisjunctionContext()
}

type DisjunctionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDisjunctionContext() *DisjunctionContext {
	var p = new(DisjunctionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ECLParserRULE_disjunction
	return p
}

func (*DisjunctionContext) IsDisjunctionContext() {}

func NewDisjunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DisjunctionContext {
	var p = new(DisjunctionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ECLParserRULE_disjunction

	return p
}

func (s *DisjunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *DisjunctionContext) Mws() IMwsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMwsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMwsContext)
}

func (s *DisjunctionContext) O() antlr.TerminalNode {
	return s.GetToken(ECLParserO, 0)
}

func (s *DisjunctionContext) CAP_O() antlr.TerminalNode {
	return s.GetToken(ECLParserCAP_O, 0)
}

func (s *DisjunctionContext) R() antlr.TerminalNode {
	return s.GetToken(ECLParserR, 0)
}

func (s *DisjunctionContext) CAP_R() antlr.TerminalNode {
	return s.GetToken(ECLParserCAP_R, 0)
}

func (s *DisjunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DisjunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DisjunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ECLListener); ok {
		listenerT.EnterDisjunction(s)
	}
}

func (s *DisjunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ECLListener); ok {
		listenerT.ExitDisjunction(s)
	}
}

func (s *DisjunctionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ECLVisitor:
		return t.VisitDisjunction(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ECLParser) Disjunction() (localctx IDisjunctionContext) {
	localctx = NewDisjunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, ECLParserRULE_disjunction)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(298)
		_la = p.GetTokenStream().LA(1)

		if !(_la == ECLParserCAP_O || _la == ECLParserO) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(299)
		_la = p.GetTokenStream().LA(1)

		if !(_la == ECLParserCAP_R || _la == ECLParserR) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(300)
		p.Mws()
	}

	return localctx
}

// IExclusionContext is an interface to support dynamic dispatch.
type IExclusionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExclusionContext differentiates from other interfaces.
	IsExclusionContext()
}

type ExclusionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExclusionContext() *ExclusionContext {
	var p = new(ExclusionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ECLParserRULE_exclusion
	return p
}

func (*ExclusionContext) IsExclusionContext() {}

func NewExclusionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExclusionContext {
	var p = new(ExclusionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ECLParserRULE_exclusion

	return p
}

func (s *ExclusionContext) GetParser() antlr.Parser { return s.parser }

func (s *ExclusionContext) Mws() IMwsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMwsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMwsContext)
}

func (s *ExclusionContext) M() antlr.TerminalNode {
	return s.GetToken(ECLParserM, 0)
}

func (s *ExclusionContext) CAP_M() antlr.TerminalNode {
	return s.GetToken(ECLParserCAP_M, 0)
}

func (s *ExclusionContext) I() antlr.TerminalNode {
	return s.GetToken(ECLParserI, 0)
}

func (s *ExclusionContext) CAP_I() antlr.TerminalNode {
	return s.GetToken(ECLParserCAP_I, 0)
}

func (s *ExclusionContext) N() antlr.TerminalNode {
	return s.GetToken(ECLParserN, 0)
}

func (s *ExclusionContext) CAP_N() antlr.TerminalNode {
	return s.GetToken(ECLParserCAP_N, 0)
}

func (s *ExclusionContext) U() antlr.TerminalNode {
	return s.GetToken(ECLParserU, 0)
}

func (s *ExclusionContext) CAP_U() antlr.TerminalNode {
	return s.GetToken(ECLParserCAP_U, 0)
}

func (s *ExclusionContext) S() antlr.TerminalNode {
	return s.GetToken(ECLParserS, 0)
}

func (s *ExclusionContext) CAP_S() antlr.TerminalNode {
	return s.GetToken(ECLParserCAP_S, 0)
}

func (s *ExclusionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExclusionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExclusionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ECLListener); ok {
		listenerT.EnterExclusion(s)
	}
}

func (s *ExclusionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ECLListener); ok {
		listenerT.ExitExclusion(s)
	}
}

func (s *ExclusionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ECLVisitor:
		return t.VisitExclusion(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ECLParser) Exclusion() (localctx IExclusionContext) {
	localctx = NewExclusionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, ECLParserRULE_exclusion)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(302)
		_la = p.GetTokenStream().LA(1)

		if !(_la == ECLParserCAP_M || _la == ECLParserM) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(303)
		_la = p.GetTokenStream().LA(1)

		if !(_la == ECLParserCAP_I || _la == ECLParserI) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(304)
		_la = p.GetTokenStream().LA(1)

		if !(_la == ECLParserCAP_N || _la == ECLParserN) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(305)
		_la = p.GetTokenStream().LA(1)

		if !(_la == ECLParserCAP_U || _la == ECLParserU) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(306)
		_la = p.GetTokenStream().LA(1)

		if !(_la == ECLParserCAP_S || _la == ECLParserS) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(307)
		p.Mws()
	}

	return localctx
}

// IEclrefinementContext is an interface to support dynamic dispatch.
type IEclrefinementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEclrefinementContext differentiates from other interfaces.
	IsEclrefinementContext()
}

type EclrefinementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEclrefinementContext() *EclrefinementContext {
	var p = new(EclrefinementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ECLParserRULE_eclrefinement
	return p
}

func (*EclrefinementContext) IsEclrefinementContext() {}

func NewEclrefinementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EclrefinementContext {
	var p = new(EclrefinementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ECLParserRULE_eclrefinement

	return p
}

func (s *EclrefinementContext) GetParser() antlr.Parser { return s.parser }

func (s *EclrefinementContext) Subrefinement() ISubrefinementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubrefinementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubrefinementContext)
}

func (s *EclrefinementContext) Ws() IWsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWsContext)
}

func (s *EclrefinementContext) Conjunctionrefinementset() IConjunctionrefinementsetContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConjunctionrefinementsetContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConjunctionrefinementsetContext)
}

func (s *EclrefinementContext) Disjunctionrefinementset() IDisjunctionrefinementsetContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDisjunctionrefinementsetContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDisjunctionrefinementsetContext)
}

func (s *EclrefinementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EclrefinementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EclrefinementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ECLListener); ok {
		listenerT.EnterEclrefinement(s)
	}
}

func (s *EclrefinementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ECLListener); ok {
		listenerT.ExitEclrefinement(s)
	}
}

func (s *EclrefinementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ECLVisitor:
		return t.VisitEclrefinement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ECLParser) Eclrefinement() (localctx IEclrefinementContext) {
	localctx = NewEclrefinementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, ECLParserRULE_eclrefinement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(309)
		p.Subrefinement()
	}
	{
		p.SetState(310)
		p.Ws()
	}
	p.SetState(313)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 16, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(311)
			p.Conjunctionrefinementset()
		}

	} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 16, p.GetParserRuleContext()) == 2 {
		{
			p.SetState(312)
			p.Disjunctionrefinementset()
		}

	}

	return localctx
}

// IConjunctionrefinementsetContext is an interface to support dynamic dispatch.
type IConjunctionrefinementsetContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConjunctionrefinementsetContext differentiates from other interfaces.
	IsConjunctionrefinementsetContext()
}

type ConjunctionrefinementsetContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConjunctionrefinementsetContext() *ConjunctionrefinementsetContext {
	var p = new(ConjunctionrefinementsetContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ECLParserRULE_conjunctionrefinementset
	return p
}

func (*ConjunctionrefinementsetContext) IsConjunctionrefinementsetContext() {}

func NewConjunctionrefinementsetContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConjunctionrefinementsetContext {
	var p = new(ConjunctionrefinementsetContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ECLParserRULE_conjunctionrefinementset

	return p
}

func (s *ConjunctionrefinementsetContext) GetParser() antlr.Parser { return s.parser }

func (s *ConjunctionrefinementsetContext) AllWs() []IWsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IWsContext)(nil)).Elem())
	var tst = make([]IWsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IWsContext)
		}
	}

	return tst
}

func (s *ConjunctionrefinementsetContext) Ws(i int) IWsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IWsContext)
}

func (s *ConjunctionrefinementsetContext) AllConjunction() []IConjunctionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IConjunctionContext)(nil)).Elem())
	var tst = make([]IConjunctionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IConjunctionContext)
		}
	}

	return tst
}

func (s *ConjunctionrefinementsetContext) Conjunction(i int) IConjunctionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConjunctionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IConjunctionContext)
}

func (s *ConjunctionrefinementsetContext) AllSubrefinement() []ISubrefinementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISubrefinementContext)(nil)).Elem())
	var tst = make([]ISubrefinementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISubrefinementContext)
		}
	}

	return tst
}

func (s *ConjunctionrefinementsetContext) Subrefinement(i int) ISubrefinementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubrefinementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISubrefinementContext)
}

func (s *ConjunctionrefinementsetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConjunctionrefinementsetContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConjunctionrefinementsetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ECLListener); ok {
		listenerT.EnterConjunctionrefinementset(s)
	}
}

func (s *ConjunctionrefinementsetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ECLListener); ok {
		listenerT.ExitConjunctionrefinementset(s)
	}
}

func (s *ConjunctionrefinementsetContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ECLVisitor:
		return t.VisitConjunctionrefinementset(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ECLParser) Conjunctionrefinementset() (localctx IConjunctionrefinementsetContext) {
	localctx = NewConjunctionrefinementsetContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, ECLParserRULE_conjunctionrefinementset)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(320)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(315)
				p.Ws()
			}
			{
				p.SetState(316)
				p.Conjunction()
			}
			{
				p.SetState(317)
				p.Ws()
			}
			{
				p.SetState(318)
				p.Subrefinement()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(322)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 17, p.GetParserRuleContext())
	}

	return localctx
}

// IDisjunctionrefinementsetContext is an interface to support dynamic dispatch.
type IDisjunctionrefinementsetContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDisjunctionrefinementsetContext differentiates from other interfaces.
	IsDisjunctionrefinementsetContext()
}

type DisjunctionrefinementsetContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDisjunctionrefinementsetContext() *DisjunctionrefinementsetContext {
	var p = new(DisjunctionrefinementsetContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ECLParserRULE_disjunctionrefinementset
	return p
}

func (*DisjunctionrefinementsetContext) IsDisjunctionrefinementsetContext() {}

func NewDisjunctionrefinementsetContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DisjunctionrefinementsetContext {
	var p = new(DisjunctionrefinementsetContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ECLParserRULE_disjunctionrefinementset

	return p
}

func (s *DisjunctionrefinementsetContext) GetParser() antlr.Parser { return s.parser }

func (s *DisjunctionrefinementsetContext) AllWs() []IWsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IWsContext)(nil)).Elem())
	var tst = make([]IWsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IWsContext)
		}
	}

	return tst
}

func (s *DisjunctionrefinementsetContext) Ws(i int) IWsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IWsContext)
}

func (s *DisjunctionrefinementsetContext) AllDisjunction() []IDisjunctionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDisjunctionContext)(nil)).Elem())
	var tst = make([]IDisjunctionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDisjunctionContext)
		}
	}

	return tst
}

func (s *DisjunctionrefinementsetContext) Disjunction(i int) IDisjunctionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDisjunctionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDisjunctionContext)
}

func (s *DisjunctionrefinementsetContext) AllSubrefinement() []ISubrefinementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISubrefinementContext)(nil)).Elem())
	var tst = make([]ISubrefinementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISubrefinementContext)
		}
	}

	return tst
}

func (s *DisjunctionrefinementsetContext) Subrefinement(i int) ISubrefinementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubrefinementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISubrefinementContext)
}

func (s *DisjunctionrefinementsetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DisjunctionrefinementsetContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DisjunctionrefinementsetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ECLListener); ok {
		listenerT.EnterDisjunctionrefinementset(s)
	}
}

func (s *DisjunctionrefinementsetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ECLListener); ok {
		listenerT.ExitDisjunctionrefinementset(s)
	}
}

func (s *DisjunctionrefinementsetContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ECLVisitor:
		return t.VisitDisjunctionrefinementset(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ECLParser) Disjunctionrefinementset() (localctx IDisjunctionrefinementsetContext) {
	localctx = NewDisjunctionrefinementsetContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, ECLParserRULE_disjunctionrefinementset)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(329)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(324)
				p.Ws()
			}
			{
				p.SetState(325)
				p.Disjunction()
			}
			{
				p.SetState(326)
				p.Ws()
			}
			{
				p.SetState(327)
				p.Subrefinement()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(331)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 18, p.GetParserRuleContext())
	}

	return localctx
}

// ISubrefinementContext is an interface to support dynamic dispatch.
type ISubrefinementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSubrefinementContext differentiates from other interfaces.
	IsSubrefinementContext()
}

type SubrefinementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubrefinementContext() *SubrefinementContext {
	var p = new(SubrefinementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ECLParserRULE_subrefinement
	return p
}

func (*SubrefinementContext) IsSubrefinementContext() {}

func NewSubrefinementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SubrefinementContext {
	var p = new(SubrefinementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ECLParserRULE_subrefinement

	return p
}

func (s *SubrefinementContext) GetParser() antlr.Parser { return s.parser }

func (s *SubrefinementContext) Eclattributeset() IEclattributesetContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEclattributesetContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEclattributesetContext)
}

func (s *SubrefinementContext) Eclattributegroup() IEclattributegroupContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEclattributegroupContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEclattributegroupContext)
}

func (s *SubrefinementContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(ECLParserLEFT_PAREN, 0)
}

func (s *SubrefinementContext) AllWs() []IWsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IWsContext)(nil)).Elem())
	var tst = make([]IWsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IWsContext)
		}
	}

	return tst
}

func (s *SubrefinementContext) Ws(i int) IWsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IWsContext)
}

func (s *SubrefinementContext) Eclrefinement() IEclrefinementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEclrefinementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEclrefinementContext)
}

func (s *SubrefinementContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(ECLParserRIGHT_PAREN, 0)
}

func (s *SubrefinementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubrefinementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SubrefinementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ECLListener); ok {
		listenerT.EnterSubrefinement(s)
	}
}

func (s *SubrefinementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ECLListener); ok {
		listenerT.ExitSubrefinement(s)
	}
}

func (s *SubrefinementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ECLVisitor:
		return t.VisitSubrefinement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ECLParser) Subrefinement() (localctx ISubrefinementContext) {
	localctx = NewSubrefinementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, ECLParserRULE_subrefinement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(341)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 19, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(333)
			p.Eclattributeset()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(334)
			p.Eclattributegroup()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(335)
			p.Match(ECLParserLEFT_PAREN)
		}
		{
			p.SetState(336)
			p.Ws()
		}
		{
			p.SetState(337)
			p.Eclrefinement()
		}
		{
			p.SetState(338)
			p.Ws()
		}
		{
			p.SetState(339)
			p.Match(ECLParserRIGHT_PAREN)
		}

	}

	return localctx
}

// IEclattributesetContext is an interface to support dynamic dispatch.
type IEclattributesetContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEclattributesetContext differentiates from other interfaces.
	IsEclattributesetContext()
}

type EclattributesetContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEclattributesetContext() *EclattributesetContext {
	var p = new(EclattributesetContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ECLParserRULE_eclattributeset
	return p
}

func (*EclattributesetContext) IsEclattributesetContext() {}

func NewEclattributesetContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EclattributesetContext {
	var p = new(EclattributesetContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ECLParserRULE_eclattributeset

	return p
}

func (s *EclattributesetContext) GetParser() antlr.Parser { return s.parser }

func (s *EclattributesetContext) Subattributeset() ISubattributesetContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubattributesetContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubattributesetContext)
}

func (s *EclattributesetContext) Ws() IWsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWsContext)
}

func (s *EclattributesetContext) Conjunctionattributeset() IConjunctionattributesetContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConjunctionattributesetContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConjunctionattributesetContext)
}

func (s *EclattributesetContext) Disjunctionattributeset() IDisjunctionattributesetContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDisjunctionattributesetContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDisjunctionattributesetContext)
}

func (s *EclattributesetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EclattributesetContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EclattributesetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ECLListener); ok {
		listenerT.EnterEclattributeset(s)
	}
}

func (s *EclattributesetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ECLListener); ok {
		listenerT.ExitEclattributeset(s)
	}
}

func (s *EclattributesetContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ECLVisitor:
		return t.VisitEclattributeset(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ECLParser) Eclattributeset() (localctx IEclattributesetContext) {
	localctx = NewEclattributesetContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, ECLParserRULE_eclattributeset)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(343)
		p.Subattributeset()
	}
	{
		p.SetState(344)
		p.Ws()
	}
	p.SetState(347)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 20, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(345)
			p.Conjunctionattributeset()
		}

	} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 20, p.GetParserRuleContext()) == 2 {
		{
			p.SetState(346)
			p.Disjunctionattributeset()
		}

	}

	return localctx
}

// IConjunctionattributesetContext is an interface to support dynamic dispatch.
type IConjunctionattributesetContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConjunctionattributesetContext differentiates from other interfaces.
	IsConjunctionattributesetContext()
}

type ConjunctionattributesetContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConjunctionattributesetContext() *ConjunctionattributesetContext {
	var p = new(ConjunctionattributesetContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ECLParserRULE_conjunctionattributeset
	return p
}

func (*ConjunctionattributesetContext) IsConjunctionattributesetContext() {}

func NewConjunctionattributesetContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConjunctionattributesetContext {
	var p = new(ConjunctionattributesetContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ECLParserRULE_conjunctionattributeset

	return p
}

func (s *ConjunctionattributesetContext) GetParser() antlr.Parser { return s.parser }

func (s *ConjunctionattributesetContext) AllWs() []IWsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IWsContext)(nil)).Elem())
	var tst = make([]IWsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IWsContext)
		}
	}

	return tst
}

func (s *ConjunctionattributesetContext) Ws(i int) IWsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IWsContext)
}

func (s *ConjunctionattributesetContext) AllConjunction() []IConjunctionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IConjunctionContext)(nil)).Elem())
	var tst = make([]IConjunctionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IConjunctionContext)
		}
	}

	return tst
}

func (s *ConjunctionattributesetContext) Conjunction(i int) IConjunctionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConjunctionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IConjunctionContext)
}

func (s *ConjunctionattributesetContext) AllSubattributeset() []ISubattributesetContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISubattributesetContext)(nil)).Elem())
	var tst = make([]ISubattributesetContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISubattributesetContext)
		}
	}

	return tst
}

func (s *ConjunctionattributesetContext) Subattributeset(i int) ISubattributesetContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubattributesetContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISubattributesetContext)
}

func (s *ConjunctionattributesetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConjunctionattributesetContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConjunctionattributesetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ECLListener); ok {
		listenerT.EnterConjunctionattributeset(s)
	}
}

func (s *ConjunctionattributesetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ECLListener); ok {
		listenerT.ExitConjunctionattributeset(s)
	}
}

func (s *ConjunctionattributesetContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ECLVisitor:
		return t.VisitConjunctionattributeset(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ECLParser) Conjunctionattributeset() (localctx IConjunctionattributesetContext) {
	localctx = NewConjunctionattributesetContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, ECLParserRULE_conjunctionattributeset)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(354)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(349)
				p.Ws()
			}
			{
				p.SetState(350)
				p.Conjunction()
			}
			{
				p.SetState(351)
				p.Ws()
			}
			{
				p.SetState(352)
				p.Subattributeset()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(356)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 21, p.GetParserRuleContext())
	}

	return localctx
}

// IDisjunctionattributesetContext is an interface to support dynamic dispatch.
type IDisjunctionattributesetContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDisjunctionattributesetContext differentiates from other interfaces.
	IsDisjunctionattributesetContext()
}

type DisjunctionattributesetContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDisjunctionattributesetContext() *DisjunctionattributesetContext {
	var p = new(DisjunctionattributesetContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ECLParserRULE_disjunctionattributeset
	return p
}

func (*DisjunctionattributesetContext) IsDisjunctionattributesetContext() {}

func NewDisjunctionattributesetContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DisjunctionattributesetContext {
	var p = new(DisjunctionattributesetContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ECLParserRULE_disjunctionattributeset

	return p
}

func (s *DisjunctionattributesetContext) GetParser() antlr.Parser { return s.parser }

func (s *DisjunctionattributesetContext) AllWs() []IWsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IWsContext)(nil)).Elem())
	var tst = make([]IWsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IWsContext)
		}
	}

	return tst
}

func (s *DisjunctionattributesetContext) Ws(i int) IWsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IWsContext)
}

func (s *DisjunctionattributesetContext) AllDisjunction() []IDisjunctionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDisjunctionContext)(nil)).Elem())
	var tst = make([]IDisjunctionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDisjunctionContext)
		}
	}

	return tst
}

func (s *DisjunctionattributesetContext) Disjunction(i int) IDisjunctionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDisjunctionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDisjunctionContext)
}

func (s *DisjunctionattributesetContext) AllSubattributeset() []ISubattributesetContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISubattributesetContext)(nil)).Elem())
	var tst = make([]ISubattributesetContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISubattributesetContext)
		}
	}

	return tst
}

func (s *DisjunctionattributesetContext) Subattributeset(i int) ISubattributesetContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubattributesetContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISubattributesetContext)
}

func (s *DisjunctionattributesetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DisjunctionattributesetContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DisjunctionattributesetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ECLListener); ok {
		listenerT.EnterDisjunctionattributeset(s)
	}
}

func (s *DisjunctionattributesetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ECLListener); ok {
		listenerT.ExitDisjunctionattributeset(s)
	}
}

func (s *DisjunctionattributesetContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ECLVisitor:
		return t.VisitDisjunctionattributeset(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ECLParser) Disjunctionattributeset() (localctx IDisjunctionattributesetContext) {
	localctx = NewDisjunctionattributesetContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, ECLParserRULE_disjunctionattributeset)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(363)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(358)
				p.Ws()
			}
			{
				p.SetState(359)
				p.Disjunction()
			}
			{
				p.SetState(360)
				p.Ws()
			}
			{
				p.SetState(361)
				p.Subattributeset()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(365)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 22, p.GetParserRuleContext())
	}

	return localctx
}

// ISubattributesetContext is an interface to support dynamic dispatch.
type ISubattributesetContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSubattributesetContext differentiates from other interfaces.
	IsSubattributesetContext()
}

type SubattributesetContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubattributesetContext() *SubattributesetContext {
	var p = new(SubattributesetContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ECLParserRULE_subattributeset
	return p
}

func (*SubattributesetContext) IsSubattributesetContext() {}

func NewSubattributesetContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SubattributesetContext {
	var p = new(SubattributesetContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ECLParserRULE_subattributeset

	return p
}

func (s *SubattributesetContext) GetParser() antlr.Parser { return s.parser }

func (s *SubattributesetContext) Eclattribute() IEclattributeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEclattributeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEclattributeContext)
}

func (s *SubattributesetContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(ECLParserLEFT_PAREN, 0)
}

func (s *SubattributesetContext) AllWs() []IWsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IWsContext)(nil)).Elem())
	var tst = make([]IWsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IWsContext)
		}
	}

	return tst
}

func (s *SubattributesetContext) Ws(i int) IWsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IWsContext)
}

func (s *SubattributesetContext) Eclattributeset() IEclattributesetContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEclattributesetContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEclattributesetContext)
}

func (s *SubattributesetContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(ECLParserRIGHT_PAREN, 0)
}

func (s *SubattributesetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubattributesetContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SubattributesetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ECLListener); ok {
		listenerT.EnterSubattributeset(s)
	}
}

func (s *SubattributesetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ECLListener); ok {
		listenerT.ExitSubattributeset(s)
	}
}

func (s *SubattributesetContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ECLVisitor:
		return t.VisitSubattributeset(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ECLParser) Subattributeset() (localctx ISubattributesetContext) {
	localctx = NewSubattributesetContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, ECLParserRULE_subattributeset)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(374)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 23, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(367)
			p.Eclattribute()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(368)
			p.Match(ECLParserLEFT_PAREN)
		}
		{
			p.SetState(369)
			p.Ws()
		}
		{
			p.SetState(370)
			p.Eclattributeset()
		}
		{
			p.SetState(371)
			p.Ws()
		}
		{
			p.SetState(372)
			p.Match(ECLParserRIGHT_PAREN)
		}

	}

	return localctx
}

// IEclattributegroupContext is an interface to support dynamic dispatch.
type IEclattributegroupContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEclattributegroupContext differentiates from other interfaces.
	IsEclattributegroupContext()
}

type EclattributegroupContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEclattributegroupContext() *EclattributegroupContext {
	var p = new(EclattributegroupContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ECLParserRULE_eclattributegroup
	return p
}

func (*EclattributegroupContext) IsEclattributegroupContext() {}

func NewEclattributegroupContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EclattributegroupContext {
	var p = new(EclattributegroupContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ECLParserRULE_eclattributegroup

	return p
}

func (s *EclattributegroupContext) GetParser() antlr.Parser { return s.parser }

func (s *EclattributegroupContext) LEFT_CURLY_BRACE() antlr.TerminalNode {
	return s.GetToken(ECLParserLEFT_CURLY_BRACE, 0)
}

func (s *EclattributegroupContext) AllWs() []IWsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IWsContext)(nil)).Elem())
	var tst = make([]IWsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IWsContext)
		}
	}

	return tst
}

func (s *EclattributegroupContext) Ws(i int) IWsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IWsContext)
}

func (s *EclattributegroupContext) Eclattributeset() IEclattributesetContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEclattributesetContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEclattributesetContext)
}

func (s *EclattributegroupContext) RIGHT_CURLY_BRACE() antlr.TerminalNode {
	return s.GetToken(ECLParserRIGHT_CURLY_BRACE, 0)
}

func (s *EclattributegroupContext) LEFT_BRACE() antlr.TerminalNode {
	return s.GetToken(ECLParserLEFT_BRACE, 0)
}

func (s *EclattributegroupContext) Cardinality() ICardinalityContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICardinalityContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICardinalityContext)
}

func (s *EclattributegroupContext) RIGHT_BRACE() antlr.TerminalNode {
	return s.GetToken(ECLParserRIGHT_BRACE, 0)
}

func (s *EclattributegroupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EclattributegroupContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EclattributegroupContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ECLListener); ok {
		listenerT.EnterEclattributegroup(s)
	}
}

func (s *EclattributegroupContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ECLListener); ok {
		listenerT.ExitEclattributegroup(s)
	}
}

func (s *EclattributegroupContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ECLVisitor:
		return t.VisitEclattributegroup(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ECLParser) Eclattributegroup() (localctx IEclattributegroupContext) {
	localctx = NewEclattributegroupContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, ECLParserRULE_eclattributegroup)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(381)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ECLParserLEFT_BRACE {
		{
			p.SetState(376)
			p.Match(ECLParserLEFT_BRACE)
		}
		{
			p.SetState(377)
			p.Cardinality()
		}
		{
			p.SetState(378)
			p.Match(ECLParserRIGHT_BRACE)
		}
		{
			p.SetState(379)
			p.Ws()
		}

	}
	{
		p.SetState(383)
		p.Match(ECLParserLEFT_CURLY_BRACE)
	}
	{
		p.SetState(384)
		p.Ws()
	}
	{
		p.SetState(385)
		p.Eclattributeset()
	}
	{
		p.SetState(386)
		p.Ws()
	}
	{
		p.SetState(387)
		p.Match(ECLParserRIGHT_CURLY_BRACE)
	}

	return localctx
}

// IEclattributeContext is an interface to support dynamic dispatch.
type IEclattributeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEclattributeContext differentiates from other interfaces.
	IsEclattributeContext()
}

type EclattributeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEclattributeContext() *EclattributeContext {
	var p = new(EclattributeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ECLParserRULE_eclattribute
	return p
}

func (*EclattributeContext) IsEclattributeContext() {}

func NewEclattributeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EclattributeContext {
	var p = new(EclattributeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ECLParserRULE_eclattribute

	return p
}

func (s *EclattributeContext) GetParser() antlr.Parser { return s.parser }

func (s *EclattributeContext) Eclattributename() IEclattributenameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEclattributenameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEclattributenameContext)
}

func (s *EclattributeContext) AllWs() []IWsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IWsContext)(nil)).Elem())
	var tst = make([]IWsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IWsContext)
		}
	}

	return tst
}

func (s *EclattributeContext) Ws(i int) IWsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IWsContext)
}

func (s *EclattributeContext) LEFT_BRACE() antlr.TerminalNode {
	return s.GetToken(ECLParserLEFT_BRACE, 0)
}

func (s *EclattributeContext) Cardinality() ICardinalityContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICardinalityContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICardinalityContext)
}

func (s *EclattributeContext) RIGHT_BRACE() antlr.TerminalNode {
	return s.GetToken(ECLParserRIGHT_BRACE, 0)
}

func (s *EclattributeContext) Reverseflag() IReverseflagContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReverseflagContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReverseflagContext)
}

func (s *EclattributeContext) Expressioncomparisonoperator() IExpressioncomparisonoperatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressioncomparisonoperatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressioncomparisonoperatorContext)
}

func (s *EclattributeContext) Subexpressionconstraint() ISubexpressionconstraintContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubexpressionconstraintContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubexpressionconstraintContext)
}

func (s *EclattributeContext) Numericcomparisonoperator() INumericcomparisonoperatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INumericcomparisonoperatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INumericcomparisonoperatorContext)
}

func (s *EclattributeContext) POUND() antlr.TerminalNode {
	return s.GetToken(ECLParserPOUND, 0)
}

func (s *EclattributeContext) Numericvalue() INumericvalueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INumericvalueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INumericvalueContext)
}

func (s *EclattributeContext) Stringcomparisonoperator() IStringcomparisonoperatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStringcomparisonoperatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStringcomparisonoperatorContext)
}

func (s *EclattributeContext) AllQm() []IQmContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IQmContext)(nil)).Elem())
	var tst = make([]IQmContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IQmContext)
		}
	}

	return tst
}

func (s *EclattributeContext) Qm(i int) IQmContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQmContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IQmContext)
}

func (s *EclattributeContext) Stringvalue() IStringvalueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStringvalueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStringvalueContext)
}

func (s *EclattributeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EclattributeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EclattributeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ECLListener); ok {
		listenerT.EnterEclattribute(s)
	}
}

func (s *EclattributeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ECLListener); ok {
		listenerT.ExitEclattribute(s)
	}
}

func (s *EclattributeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ECLVisitor:
		return t.VisitEclattribute(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ECLParser) Eclattribute() (localctx IEclattributeContext) {
	localctx = NewEclattributeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, ECLParserRULE_eclattribute)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(394)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ECLParserLEFT_BRACE {
		{
			p.SetState(389)
			p.Match(ECLParserLEFT_BRACE)
		}
		{
			p.SetState(390)
			p.Cardinality()
		}
		{
			p.SetState(391)
			p.Match(ECLParserRIGHT_BRACE)
		}
		{
			p.SetState(392)
			p.Ws()
		}

	}
	p.SetState(399)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ECLParserCAP_R {
		{
			p.SetState(396)
			p.Reverseflag()
		}
		{
			p.SetState(397)
			p.Ws()
		}

	}
	{
		p.SetState(401)
		p.Eclattributename()
	}
	{
		p.SetState(402)
		p.Ws()
	}
	p.SetState(418)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 27, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(403)
			p.Expressioncomparisonoperator()
		}
		{
			p.SetState(404)
			p.Ws()
		}
		{
			p.SetState(405)
			p.Subexpressionconstraint()
		}

	case 2:
		{
			p.SetState(407)
			p.Numericcomparisonoperator()
		}
		{
			p.SetState(408)
			p.Ws()
		}
		{
			p.SetState(409)
			p.Match(ECLParserPOUND)
		}
		{
			p.SetState(410)
			p.Numericvalue()
		}

	case 3:
		{
			p.SetState(412)
			p.Stringcomparisonoperator()
		}
		{
			p.SetState(413)
			p.Ws()
		}
		{
			p.SetState(414)
			p.Qm()
		}
		{
			p.SetState(415)
			p.Stringvalue()
		}
		{
			p.SetState(416)
			p.Qm()
		}

	}

	return localctx
}

// ICardinalityContext is an interface to support dynamic dispatch.
type ICardinalityContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCardinalityContext differentiates from other interfaces.
	IsCardinalityContext()
}

type CardinalityContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCardinalityContext() *CardinalityContext {
	var p = new(CardinalityContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ECLParserRULE_cardinality
	return p
}

func (*CardinalityContext) IsCardinalityContext() {}

func NewCardinalityContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CardinalityContext {
	var p = new(CardinalityContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ECLParserRULE_cardinality

	return p
}

func (s *CardinalityContext) GetParser() antlr.Parser { return s.parser }

func (s *CardinalityContext) Minvalue() IMinvalueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMinvalueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMinvalueContext)
}

func (s *CardinalityContext) To() IToContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IToContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IToContext)
}

func (s *CardinalityContext) Maxvalue() IMaxvalueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMaxvalueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMaxvalueContext)
}

func (s *CardinalityContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CardinalityContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CardinalityContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ECLListener); ok {
		listenerT.EnterCardinality(s)
	}
}

func (s *CardinalityContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ECLListener); ok {
		listenerT.ExitCardinality(s)
	}
}

func (s *CardinalityContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ECLVisitor:
		return t.VisitCardinality(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ECLParser) Cardinality() (localctx ICardinalityContext) {
	localctx = NewCardinalityContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, ECLParserRULE_cardinality)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(420)
		p.Minvalue()
	}
	{
		p.SetState(421)
		p.To()
	}
	{
		p.SetState(422)
		p.Maxvalue()
	}

	return localctx
}

// IMinvalueContext is an interface to support dynamic dispatch.
type IMinvalueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMinvalueContext differentiates from other interfaces.
	IsMinvalueContext()
}

type MinvalueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMinvalueContext() *MinvalueContext {
	var p = new(MinvalueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ECLParserRULE_minvalue
	return p
}

func (*MinvalueContext) IsMinvalueContext() {}

func NewMinvalueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MinvalueContext {
	var p = new(MinvalueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ECLParserRULE_minvalue

	return p
}

func (s *MinvalueContext) GetParser() antlr.Parser { return s.parser }

func (s *MinvalueContext) Nonnegativeintegervalue() INonnegativeintegervalueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INonnegativeintegervalueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INonnegativeintegervalueContext)
}

func (s *MinvalueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MinvalueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MinvalueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ECLListener); ok {
		listenerT.EnterMinvalue(s)
	}
}

func (s *MinvalueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ECLListener); ok {
		listenerT.ExitMinvalue(s)
	}
}

func (s *MinvalueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ECLVisitor:
		return t.VisitMinvalue(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ECLParser) Minvalue() (localctx IMinvalueContext) {
	localctx = NewMinvalueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, ECLParserRULE_minvalue)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(424)
		p.Nonnegativeintegervalue()
	}

	return localctx
}

// IToContext is an interface to support dynamic dispatch.
type IToContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsToContext differentiates from other interfaces.
	IsToContext()
}

type ToContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyToContext() *ToContext {
	var p = new(ToContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ECLParserRULE_to
	return p
}

func (*ToContext) IsToContext() {}

func NewToContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ToContext {
	var p = new(ToContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ECLParserRULE_to

	return p
}

func (s *ToContext) GetParser() antlr.Parser { return s.parser }

func (s *ToContext) AllPERIOD() []antlr.TerminalNode {
	return s.GetTokens(ECLParserPERIOD)
}

func (s *ToContext) PERIOD(i int) antlr.TerminalNode {
	return s.GetToken(ECLParserPERIOD, i)
}

func (s *ToContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ToContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ToContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ECLListener); ok {
		listenerT.EnterTo(s)
	}
}

func (s *ToContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ECLListener); ok {
		listenerT.ExitTo(s)
	}
}

func (s *ToContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ECLVisitor:
		return t.VisitTo(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ECLParser) To() (localctx IToContext) {
	localctx = NewToContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, ECLParserRULE_to)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(426)
		p.Match(ECLParserPERIOD)
	}
	{
		p.SetState(427)
		p.Match(ECLParserPERIOD)
	}

	return localctx
}

// IMaxvalueContext is an interface to support dynamic dispatch.
type IMaxvalueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMaxvalueContext differentiates from other interfaces.
	IsMaxvalueContext()
}

type MaxvalueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMaxvalueContext() *MaxvalueContext {
	var p = new(MaxvalueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ECLParserRULE_maxvalue
	return p
}

func (*MaxvalueContext) IsMaxvalueContext() {}

func NewMaxvalueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MaxvalueContext {
	var p = new(MaxvalueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ECLParserRULE_maxvalue

	return p
}

func (s *MaxvalueContext) GetParser() antlr.Parser { return s.parser }

func (s *MaxvalueContext) Nonnegativeintegervalue() INonnegativeintegervalueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INonnegativeintegervalueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INonnegativeintegervalueContext)
}

func (s *MaxvalueContext) Many() IManyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IManyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IManyContext)
}

func (s *MaxvalueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MaxvalueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MaxvalueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ECLListener); ok {
		listenerT.EnterMaxvalue(s)
	}
}

func (s *MaxvalueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ECLListener); ok {
		listenerT.ExitMaxvalue(s)
	}
}

func (s *MaxvalueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ECLVisitor:
		return t.VisitMaxvalue(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ECLParser) Maxvalue() (localctx IMaxvalueContext) {
	localctx = NewMaxvalueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, ECLParserRULE_maxvalue)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(431)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ECLParserZERO, ECLParserONE, ECLParserTWO, ECLParserTHREE, ECLParserFOUR, ECLParserFIVE, ECLParserSIX, ECLParserSEVEN, ECLParserEIGHT, ECLParserNINE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(429)
			p.Nonnegativeintegervalue()
		}

	case ECLParserASTERISK:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(430)
			p.Many()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IManyContext is an interface to support dynamic dispatch.
type IManyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsManyContext differentiates from other interfaces.
	IsManyContext()
}

type ManyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyManyContext() *ManyContext {
	var p = new(ManyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ECLParserRULE_many
	return p
}

func (*ManyContext) IsManyContext() {}

func NewManyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ManyContext {
	var p = new(ManyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ECLParserRULE_many

	return p
}

func (s *ManyContext) GetParser() antlr.Parser { return s.parser }

func (s *ManyContext) ASTERISK() antlr.TerminalNode {
	return s.GetToken(ECLParserASTERISK, 0)
}

func (s *ManyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ManyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ManyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ECLListener); ok {
		listenerT.EnterMany(s)
	}
}

func (s *ManyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ECLListener); ok {
		listenerT.ExitMany(s)
	}
}

func (s *ManyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ECLVisitor:
		return t.VisitMany(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ECLParser) Many() (localctx IManyContext) {
	localctx = NewManyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, ECLParserRULE_many)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(433)
		p.Match(ECLParserASTERISK)
	}

	return localctx
}

// IReverseflagContext is an interface to support dynamic dispatch.
type IReverseflagContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReverseflagContext differentiates from other interfaces.
	IsReverseflagContext()
}

type ReverseflagContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReverseflagContext() *ReverseflagContext {
	var p = new(ReverseflagContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ECLParserRULE_reverseflag
	return p
}

func (*ReverseflagContext) IsReverseflagContext() {}

func NewReverseflagContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReverseflagContext {
	var p = new(ReverseflagContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ECLParserRULE_reverseflag

	return p
}

func (s *ReverseflagContext) GetParser() antlr.Parser { return s.parser }

func (s *ReverseflagContext) CAP_R() antlr.TerminalNode {
	return s.GetToken(ECLParserCAP_R, 0)
}

func (s *ReverseflagContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReverseflagContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReverseflagContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ECLListener); ok {
		listenerT.EnterReverseflag(s)
	}
}

func (s *ReverseflagContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ECLListener); ok {
		listenerT.ExitReverseflag(s)
	}
}

func (s *ReverseflagContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ECLVisitor:
		return t.VisitReverseflag(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ECLParser) Reverseflag() (localctx IReverseflagContext) {
	localctx = NewReverseflagContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, ECLParserRULE_reverseflag)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(435)
		p.Match(ECLParserCAP_R)
	}

	return localctx
}

// IEclattributenameContext is an interface to support dynamic dispatch.
type IEclattributenameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEclattributenameContext differentiates from other interfaces.
	IsEclattributenameContext()
}

type EclattributenameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEclattributenameContext() *EclattributenameContext {
	var p = new(EclattributenameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ECLParserRULE_eclattributename
	return p
}

func (*EclattributenameContext) IsEclattributenameContext() {}

func NewEclattributenameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EclattributenameContext {
	var p = new(EclattributenameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ECLParserRULE_eclattributename

	return p
}

func (s *EclattributenameContext) GetParser() antlr.Parser { return s.parser }

func (s *EclattributenameContext) Subexpressionconstraint() ISubexpressionconstraintContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISubexpressionconstraintContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISubexpressionconstraintContext)
}

func (s *EclattributenameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EclattributenameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EclattributenameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ECLListener); ok {
		listenerT.EnterEclattributename(s)
	}
}

func (s *EclattributenameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ECLListener); ok {
		listenerT.ExitEclattributename(s)
	}
}

func (s *EclattributenameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ECLVisitor:
		return t.VisitEclattributename(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ECLParser) Eclattributename() (localctx IEclattributenameContext) {
	localctx = NewEclattributenameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, ECLParserRULE_eclattributename)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(437)
		p.Subexpressionconstraint()
	}

	return localctx
}

// IExpressioncomparisonoperatorContext is an interface to support dynamic dispatch.
type IExpressioncomparisonoperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpressioncomparisonoperatorContext differentiates from other interfaces.
	IsExpressioncomparisonoperatorContext()
}

type ExpressioncomparisonoperatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressioncomparisonoperatorContext() *ExpressioncomparisonoperatorContext {
	var p = new(ExpressioncomparisonoperatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ECLParserRULE_expressioncomparisonoperator
	return p
}

func (*ExpressioncomparisonoperatorContext) IsExpressioncomparisonoperatorContext() {}

func NewExpressioncomparisonoperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressioncomparisonoperatorContext {
	var p = new(ExpressioncomparisonoperatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ECLParserRULE_expressioncomparisonoperator

	return p
}

func (s *ExpressioncomparisonoperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressioncomparisonoperatorContext) EQUALS() antlr.TerminalNode {
	return s.GetToken(ECLParserEQUALS, 0)
}

func (s *ExpressioncomparisonoperatorContext) EXCLAMATION() antlr.TerminalNode {
	return s.GetToken(ECLParserEXCLAMATION, 0)
}

func (s *ExpressioncomparisonoperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressioncomparisonoperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressioncomparisonoperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ECLListener); ok {
		listenerT.EnterExpressioncomparisonoperator(s)
	}
}

func (s *ExpressioncomparisonoperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ECLListener); ok {
		listenerT.ExitExpressioncomparisonoperator(s)
	}
}

func (s *ExpressioncomparisonoperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ECLVisitor:
		return t.VisitExpressioncomparisonoperator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ECLParser) Expressioncomparisonoperator() (localctx IExpressioncomparisonoperatorContext) {
	localctx = NewExpressioncomparisonoperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, ECLParserRULE_expressioncomparisonoperator)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(442)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ECLParserEQUALS:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(439)
			p.Match(ECLParserEQUALS)
		}

	case ECLParserEXCLAMATION:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(440)
			p.Match(ECLParserEXCLAMATION)
		}
		{
			p.SetState(441)
			p.Match(ECLParserEQUALS)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// INumericcomparisonoperatorContext is an interface to support dynamic dispatch.
type INumericcomparisonoperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNumericcomparisonoperatorContext differentiates from other interfaces.
	IsNumericcomparisonoperatorContext()
}

type NumericcomparisonoperatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNumericcomparisonoperatorContext() *NumericcomparisonoperatorContext {
	var p = new(NumericcomparisonoperatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ECLParserRULE_numericcomparisonoperator
	return p
}

func (*NumericcomparisonoperatorContext) IsNumericcomparisonoperatorContext() {}

func NewNumericcomparisonoperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NumericcomparisonoperatorContext {
	var p = new(NumericcomparisonoperatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ECLParserRULE_numericcomparisonoperator

	return p
}

func (s *NumericcomparisonoperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *NumericcomparisonoperatorContext) EQUALS() antlr.TerminalNode {
	return s.GetToken(ECLParserEQUALS, 0)
}

func (s *NumericcomparisonoperatorContext) EXCLAMATION() antlr.TerminalNode {
	return s.GetToken(ECLParserEXCLAMATION, 0)
}

func (s *NumericcomparisonoperatorContext) LESS_THAN() antlr.TerminalNode {
	return s.GetToken(ECLParserLESS_THAN, 0)
}

func (s *NumericcomparisonoperatorContext) GREATER_THAN() antlr.TerminalNode {
	return s.GetToken(ECLParserGREATER_THAN, 0)
}

func (s *NumericcomparisonoperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NumericcomparisonoperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NumericcomparisonoperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ECLListener); ok {
		listenerT.EnterNumericcomparisonoperator(s)
	}
}

func (s *NumericcomparisonoperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ECLListener); ok {
		listenerT.ExitNumericcomparisonoperator(s)
	}
}

func (s *NumericcomparisonoperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ECLVisitor:
		return t.VisitNumericcomparisonoperator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ECLParser) Numericcomparisonoperator() (localctx INumericcomparisonoperatorContext) {
	localctx = NewNumericcomparisonoperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, ECLParserRULE_numericcomparisonoperator)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(453)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 30, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(444)
			p.Match(ECLParserEQUALS)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(445)
			p.Match(ECLParserEXCLAMATION)
		}
		{
			p.SetState(446)
			p.Match(ECLParserEQUALS)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(447)
			p.Match(ECLParserLESS_THAN)
		}
		{
			p.SetState(448)
			p.Match(ECLParserEQUALS)
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(449)
			p.Match(ECLParserLESS_THAN)
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(450)
			p.Match(ECLParserGREATER_THAN)
		}
		{
			p.SetState(451)
			p.Match(ECLParserEQUALS)
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(452)
			p.Match(ECLParserGREATER_THAN)
		}

	}

	return localctx
}

// IStringcomparisonoperatorContext is an interface to support dynamic dispatch.
type IStringcomparisonoperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStringcomparisonoperatorContext differentiates from other interfaces.
	IsStringcomparisonoperatorContext()
}

type StringcomparisonoperatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStringcomparisonoperatorContext() *StringcomparisonoperatorContext {
	var p = new(StringcomparisonoperatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ECLParserRULE_stringcomparisonoperator
	return p
}

func (*StringcomparisonoperatorContext) IsStringcomparisonoperatorContext() {}

func NewStringcomparisonoperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StringcomparisonoperatorContext {
	var p = new(StringcomparisonoperatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ECLParserRULE_stringcomparisonoperator

	return p
}

func (s *StringcomparisonoperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *StringcomparisonoperatorContext) EQUALS() antlr.TerminalNode {
	return s.GetToken(ECLParserEQUALS, 0)
}

func (s *StringcomparisonoperatorContext) EXCLAMATION() antlr.TerminalNode {
	return s.GetToken(ECLParserEXCLAMATION, 0)
}

func (s *StringcomparisonoperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringcomparisonoperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StringcomparisonoperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ECLListener); ok {
		listenerT.EnterStringcomparisonoperator(s)
	}
}

func (s *StringcomparisonoperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ECLListener); ok {
		listenerT.ExitStringcomparisonoperator(s)
	}
}

func (s *StringcomparisonoperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ECLVisitor:
		return t.VisitStringcomparisonoperator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ECLParser) Stringcomparisonoperator() (localctx IStringcomparisonoperatorContext) {
	localctx = NewStringcomparisonoperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, ECLParserRULE_stringcomparisonoperator)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(458)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ECLParserEQUALS:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(455)
			p.Match(ECLParserEQUALS)
		}

	case ECLParserEXCLAMATION:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(456)
			p.Match(ECLParserEXCLAMATION)
		}
		{
			p.SetState(457)
			p.Match(ECLParserEQUALS)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// INumericvalueContext is an interface to support dynamic dispatch.
type INumericvalueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNumericvalueContext differentiates from other interfaces.
	IsNumericvalueContext()
}

type NumericvalueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNumericvalueContext() *NumericvalueContext {
	var p = new(NumericvalueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ECLParserRULE_numericvalue
	return p
}

func (*NumericvalueContext) IsNumericvalueContext() {}

func NewNumericvalueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NumericvalueContext {
	var p = new(NumericvalueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ECLParserRULE_numericvalue

	return p
}

func (s *NumericvalueContext) GetParser() antlr.Parser { return s.parser }

func (s *NumericvalueContext) Decimalvalue() IDecimalvalueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDecimalvalueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDecimalvalueContext)
}

func (s *NumericvalueContext) Integervalue() IIntegervalueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntegervalueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIntegervalueContext)
}

func (s *NumericvalueContext) DASH() antlr.TerminalNode {
	return s.GetToken(ECLParserDASH, 0)
}

func (s *NumericvalueContext) PLUS() antlr.TerminalNode {
	return s.GetToken(ECLParserPLUS, 0)
}

func (s *NumericvalueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NumericvalueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NumericvalueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ECLListener); ok {
		listenerT.EnterNumericvalue(s)
	}
}

func (s *NumericvalueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ECLListener); ok {
		listenerT.ExitNumericvalue(s)
	}
}

func (s *NumericvalueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ECLVisitor:
		return t.VisitNumericvalue(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ECLParser) Numericvalue() (localctx INumericvalueContext) {
	localctx = NewNumericvalueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, ECLParserRULE_numericvalue)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(461)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == ECLParserPLUS || _la == ECLParserDASH {
		{
			p.SetState(460)
			_la = p.GetTokenStream().LA(1)

			if !(_la == ECLParserPLUS || _la == ECLParserDASH) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	p.SetState(465)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 33, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(463)
			p.Decimalvalue()
		}

	case 2:
		{
			p.SetState(464)
			p.Integervalue()
		}

	}

	return localctx
}

// IStringvalueContext is an interface to support dynamic dispatch.
type IStringvalueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStringvalueContext differentiates from other interfaces.
	IsStringvalueContext()
}

type StringvalueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStringvalueContext() *StringvalueContext {
	var p = new(StringvalueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ECLParserRULE_stringvalue
	return p
}

func (*StringvalueContext) IsStringvalueContext() {}

func NewStringvalueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StringvalueContext {
	var p = new(StringvalueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ECLParserRULE_stringvalue

	return p
}

func (s *StringvalueContext) GetParser() antlr.Parser { return s.parser }

func (s *StringvalueContext) AllAnynonescapedchar() []IAnynonescapedcharContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAnynonescapedcharContext)(nil)).Elem())
	var tst = make([]IAnynonescapedcharContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAnynonescapedcharContext)
		}
	}

	return tst
}

func (s *StringvalueContext) Anynonescapedchar(i int) IAnynonescapedcharContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnynonescapedcharContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAnynonescapedcharContext)
}

func (s *StringvalueContext) AllEscapedchar() []IEscapedcharContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IEscapedcharContext)(nil)).Elem())
	var tst = make([]IEscapedcharContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IEscapedcharContext)
		}
	}

	return tst
}

func (s *StringvalueContext) Escapedchar(i int) IEscapedcharContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEscapedcharContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IEscapedcharContext)
}

func (s *StringvalueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringvalueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StringvalueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ECLListener); ok {
		listenerT.EnterStringvalue(s)
	}
}

func (s *StringvalueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ECLListener); ok {
		listenerT.ExitStringvalue(s)
	}
}

func (s *StringvalueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ECLVisitor:
		return t.VisitStringvalue(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ECLParser) Stringvalue() (localctx IStringvalueContext) {
	localctx = NewStringvalueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, ECLParserRULE_stringvalue)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(469)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<ECLParserTAB)|(1<<ECLParserLF)|(1<<ECLParserCR)|(1<<ECLParserSPACE)|(1<<ECLParserEXCLAMATION)|(1<<ECLParserPOUND)|(1<<ECLParserDOLLAR)|(1<<ECLParserPERCENT)|(1<<ECLParserAMPERSAND)|(1<<ECLParserAPOSTROPHE)|(1<<ECLParserLEFT_PAREN)|(1<<ECLParserRIGHT_PAREN)|(1<<ECLParserASTERISK)|(1<<ECLParserPLUS)|(1<<ECLParserCOMMA)|(1<<ECLParserDASH)|(1<<ECLParserPERIOD)|(1<<ECLParserSLASH)|(1<<ECLParserZERO)|(1<<ECLParserONE)|(1<<ECLParserTWO)|(1<<ECLParserTHREE)|(1<<ECLParserFOUR)|(1<<ECLParserFIVE)|(1<<ECLParserSIX)|(1<<ECLParserSEVEN)|(1<<ECLParserEIGHT)|(1<<ECLParserNINE)|(1<<ECLParserCOLON)|(1<<ECLParserSEMICOLON))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(ECLParserLESS_THAN-32))|(1<<(ECLParserEQUALS-32))|(1<<(ECLParserGREATER_THAN-32))|(1<<(ECLParserQUESTION-32))|(1<<(ECLParserAT-32))|(1<<(ECLParserCAP_A-32))|(1<<(ECLParserCAP_B-32))|(1<<(ECLParserCAP_C-32))|(1<<(ECLParserCAP_D-32))|(1<<(ECLParserCAP_E-32))|(1<<(ECLParserCAP_F-32))|(1<<(ECLParserCAP_G-32))|(1<<(ECLParserCAP_H-32))|(1<<(ECLParserCAP_I-32))|(1<<(ECLParserCAP_J-32))|(1<<(ECLParserCAP_K-32))|(1<<(ECLParserCAP_L-32))|(1<<(ECLParserCAP_M-32))|(1<<(ECLParserCAP_N-32))|(1<<(ECLParserCAP_O-32))|(1<<(ECLParserCAP_P-32))|(1<<(ECLParserCAP_Q-32))|(1<<(ECLParserCAP_R-32))|(1<<(ECLParserCAP_S-32))|(1<<(ECLParserCAP_T-32))|(1<<(ECLParserCAP_U-32))|(1<<(ECLParserCAP_V-32))|(1<<(ECLParserCAP_W-32))|(1<<(ECLParserCAP_X-32))|(1<<(ECLParserCAP_Y-32))|(1<<(ECLParserCAP_Z-32))|(1<<(ECLParserLEFT_BRACE-32)))) != 0) || (((_la-64)&-(0x1f+1)) == 0 && ((1<<uint((_la-64)))&((1<<(ECLParserBACKSLASH-64))|(1<<(ECLParserRIGHT_BRACE-64))|(1<<(ECLParserCARAT-64))|(1<<(ECLParserUNDERSCORE-64))|(1<<(ECLParserACCENT-64))|(1<<(ECLParserA-64))|(1<<(ECLParserB-64))|(1<<(ECLParserC-64))|(1<<(ECLParserD-64))|(1<<(ECLParserE-64))|(1<<(ECLParserF-64))|(1<<(ECLParserG-64))|(1<<(ECLParserH-64))|(1<<(ECLParserI-64))|(1<<(ECLParserJ-64))|(1<<(ECLParserK-64))|(1<<(ECLParserL-64))|(1<<(ECLParserM-64))|(1<<(ECLParserN-64))|(1<<(ECLParserO-64))|(1<<(ECLParserP-64))|(1<<(ECLParserQ-64))|(1<<(ECLParserR-64))|(1<<(ECLParserS-64))|(1<<(ECLParserT-64))|(1<<(ECLParserU-64))|(1<<(ECLParserV-64))|(1<<(ECLParserW-64))|(1<<(ECLParserX-64))|(1<<(ECLParserY-64))|(1<<(ECLParserZ-64))|(1<<(ECLParserLEFT_CURLY_BRACE-64)))) != 0) || (((_la-96)&-(0x1f+1)) == 0 && ((1<<uint((_la-96)))&((1<<(ECLParserPIPE-96))|(1<<(ECLParserRIGHT_CURLY_BRACE-96))|(1<<(ECLParserTILDE-96)))) != 0) || (((_la-163)&-(0x1f+1)) == 0 && ((1<<uint((_la-163)))&((1<<(ECLParserU_00C2-163))|(1<<(ECLParserU_00C3-163))|(1<<(ECLParserU_00C4-163))|(1<<(ECLParserU_00C5-163))|(1<<(ECLParserU_00C6-163))|(1<<(ECLParserU_00C7-163))|(1<<(ECLParserU_00C8-163))|(1<<(ECLParserU_00C9-163))|(1<<(ECLParserU_00CA-163))|(1<<(ECLParserU_00CB-163))|(1<<(ECLParserU_00CC-163))|(1<<(ECLParserU_00CD-163))|(1<<(ECLParserU_00CE-163))|(1<<(ECLParserU_00CF-163))|(1<<(ECLParserU_00D0-163))|(1<<(ECLParserU_00D1-163))|(1<<(ECLParserU_00D2-163))|(1<<(ECLParserU_00D3-163))|(1<<(ECLParserU_00D4-163))|(1<<(ECLParserU_00D5-163))|(1<<(ECLParserU_00D6-163))|(1<<(ECLParserU_00D7-163))|(1<<(ECLParserU_00D8-163))|(1<<(ECLParserU_00D9-163))|(1<<(ECLParserU_00DA-163))|(1<<(ECLParserU_00DB-163))|(1<<(ECLParserU_00DC-163))|(1<<(ECLParserU_00DD-163))|(1<<(ECLParserU_00DE-163))|(1<<(ECLParserU_00DF-163))|(1<<(ECLParserU_00E0-163))|(1<<(ECLParserU_00E1-163)))) != 0) || (((_la-195)&-(0x1f+1)) == 0 && ((1<<uint((_la-195)))&((1<<(ECLParserU_00E2-195))|(1<<(ECLParserU_00E3-195))|(1<<(ECLParserU_00E4-195))|(1<<(ECLParserU_00E5-195))|(1<<(ECLParserU_00E6-195))|(1<<(ECLParserU_00E7-195))|(1<<(ECLParserU_00E8-195))|(1<<(ECLParserU_00E9-195))|(1<<(ECLParserU_00EA-195))|(1<<(ECLParserU_00EB-195))|(1<<(ECLParserU_00EC-195))|(1<<(ECLParserU_00ED-195))|(1<<(ECLParserU_00EE-195))|(1<<(ECLParserU_00EF-195))|(1<<(ECLParserU_00F0-195))|(1<<(ECLParserU_00F1-195))|(1<<(ECLParserU_00F2-195))|(1<<(ECLParserU_00F3-195))|(1<<(ECLParserU_00F4-195)))) != 0) {
		p.SetState(469)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case ECLParserTAB, ECLParserLF, ECLParserCR, ECLParserSPACE, ECLParserEXCLAMATION, ECLParserPOUND, ECLParserDOLLAR, ECLParserPERCENT, ECLParserAMPERSAND, ECLParserAPOSTROPHE, ECLParserLEFT_PAREN, ECLParserRIGHT_PAREN, ECLParserASTERISK, ECLParserPLUS, ECLParserCOMMA, ECLParserDASH, ECLParserPERIOD, ECLParserSLASH, ECLParserZERO, ECLParserONE, ECLParserTWO, ECLParserTHREE, ECLParserFOUR, ECLParserFIVE, ECLParserSIX, ECLParserSEVEN, ECLParserEIGHT, ECLParserNINE, ECLParserCOLON, ECLParserSEMICOLON, ECLParserLESS_THAN, ECLParserEQUALS, ECLParserGREATER_THAN, ECLParserQUESTION, ECLParserAT, ECLParserCAP_A, ECLParserCAP_B, ECLParserCAP_C, ECLParserCAP_D, ECLParserCAP_E, ECLParserCAP_F, ECLParserCAP_G, ECLParserCAP_H, ECLParserCAP_I, ECLParserCAP_J, ECLParserCAP_K, ECLParserCAP_L, ECLParserCAP_M, ECLParserCAP_N, ECLParserCAP_O, ECLParserCAP_P, ECLParserCAP_Q, ECLParserCAP_R, ECLParserCAP_S, ECLParserCAP_T, ECLParserCAP_U, ECLParserCAP_V, ECLParserCAP_W, ECLParserCAP_X, ECLParserCAP_Y, ECLParserCAP_Z, ECLParserLEFT_BRACE, ECLParserRIGHT_BRACE, ECLParserCARAT, ECLParserUNDERSCORE, ECLParserACCENT, ECLParserA, ECLParserB, ECLParserC, ECLParserD, ECLParserE, ECLParserF, ECLParserG, ECLParserH, ECLParserI, ECLParserJ, ECLParserK, ECLParserL, ECLParserM, ECLParserN, ECLParserO, ECLParserP, ECLParserQ, ECLParserR, ECLParserS, ECLParserT, ECLParserU, ECLParserV, ECLParserW, ECLParserX, ECLParserY, ECLParserZ, ECLParserLEFT_CURLY_BRACE, ECLParserPIPE, ECLParserRIGHT_CURLY_BRACE, ECLParserTILDE, ECLParserU_00C2, ECLParserU_00C3, ECLParserU_00C4, ECLParserU_00C5, ECLParserU_00C6, ECLParserU_00C7, ECLParserU_00C8, ECLParserU_00C9, ECLParserU_00CA, ECLParserU_00CB, ECLParserU_00CC, ECLParserU_00CD, ECLParserU_00CE, ECLParserU_00CF, ECLParserU_00D0, ECLParserU_00D1, ECLParserU_00D2, ECLParserU_00D3, ECLParserU_00D4, ECLParserU_00D5, ECLParserU_00D6, ECLParserU_00D7, ECLParserU_00D8, ECLParserU_00D9, ECLParserU_00DA, ECLParserU_00DB, ECLParserU_00DC, ECLParserU_00DD, ECLParserU_00DE, ECLParserU_00DF, ECLParserU_00E0, ECLParserU_00E1, ECLParserU_00E2, ECLParserU_00E3, ECLParserU_00E4, ECLParserU_00E5, ECLParserU_00E6, ECLParserU_00E7, ECLParserU_00E8, ECLParserU_00E9, ECLParserU_00EA, ECLParserU_00EB, ECLParserU_00EC, ECLParserU_00ED, ECLParserU_00EE, ECLParserU_00EF, ECLParserU_00F0, ECLParserU_00F1, ECLParserU_00F2, ECLParserU_00F3, ECLParserU_00F4:
			{
				p.SetState(467)
				p.Anynonescapedchar()
			}

		case ECLParserBACKSLASH:
			{
				p.SetState(468)
				p.Escapedchar()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(471)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IIntegervalueContext is an interface to support dynamic dispatch.
type IIntegervalueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIntegervalueContext differentiates from other interfaces.
	IsIntegervalueContext()
}

type IntegervalueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIntegervalueContext() *IntegervalueContext {
	var p = new(IntegervalueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ECLParserRULE_integervalue
	return p
}

func (*IntegervalueContext) IsIntegervalueContext() {}

func NewIntegervalueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IntegervalueContext {
	var p = new(IntegervalueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ECLParserRULE_integervalue

	return p
}

func (s *IntegervalueContext) GetParser() antlr.Parser { return s.parser }

func (s *IntegervalueContext) Digitnonzero() IDigitnonzeroContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDigitnonzeroContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDigitnonzeroContext)
}

func (s *IntegervalueContext) AllDigit() []IDigitContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDigitContext)(nil)).Elem())
	var tst = make([]IDigitContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDigitContext)
		}
	}

	return tst
}

func (s *IntegervalueContext) Digit(i int) IDigitContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDigitContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDigitContext)
}

func (s *IntegervalueContext) Zero() IZeroContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IZeroContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IZeroContext)
}

func (s *IntegervalueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntegervalueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IntegervalueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ECLListener); ok {
		listenerT.EnterIntegervalue(s)
	}
}

func (s *IntegervalueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ECLListener); ok {
		listenerT.ExitIntegervalue(s)
	}
}

func (s *IntegervalueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ECLVisitor:
		return t.VisitIntegervalue(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ECLParser) Integervalue() (localctx IIntegervalueContext) {
	localctx = NewIntegervalueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, ECLParserRULE_integervalue)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(481)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ECLParserONE, ECLParserTWO, ECLParserTHREE, ECLParserFOUR, ECLParserFIVE, ECLParserSIX, ECLParserSEVEN, ECLParserEIGHT, ECLParserNINE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(473)
			p.Digitnonzero()
		}
		p.SetState(477)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<ECLParserZERO)|(1<<ECLParserONE)|(1<<ECLParserTWO)|(1<<ECLParserTHREE)|(1<<ECLParserFOUR)|(1<<ECLParserFIVE)|(1<<ECLParserSIX)|(1<<ECLParserSEVEN)|(1<<ECLParserEIGHT)|(1<<ECLParserNINE))) != 0 {
			{
				p.SetState(474)
				p.Digit()
			}

			p.SetState(479)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	case ECLParserZERO:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(480)
			p.Zero()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IDecimalvalueContext is an interface to support dynamic dispatch.
type IDecimalvalueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDecimalvalueContext differentiates from other interfaces.
	IsDecimalvalueContext()
}

type DecimalvalueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDecimalvalueContext() *DecimalvalueContext {
	var p = new(DecimalvalueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ECLParserRULE_decimalvalue
	return p
}

func (*DecimalvalueContext) IsDecimalvalueContext() {}

func NewDecimalvalueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DecimalvalueContext {
	var p = new(DecimalvalueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ECLParserRULE_decimalvalue

	return p
}

func (s *DecimalvalueContext) GetParser() antlr.Parser { return s.parser }

func (s *DecimalvalueContext) Integervalue() IIntegervalueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIntegervalueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIntegervalueContext)
}

func (s *DecimalvalueContext) PERIOD() antlr.TerminalNode {
	return s.GetToken(ECLParserPERIOD, 0)
}

func (s *DecimalvalueContext) AllDigit() []IDigitContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDigitContext)(nil)).Elem())
	var tst = make([]IDigitContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDigitContext)
		}
	}

	return tst
}

func (s *DecimalvalueContext) Digit(i int) IDigitContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDigitContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDigitContext)
}

func (s *DecimalvalueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DecimalvalueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DecimalvalueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ECLListener); ok {
		listenerT.EnterDecimalvalue(s)
	}
}

func (s *DecimalvalueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ECLListener); ok {
		listenerT.ExitDecimalvalue(s)
	}
}

func (s *DecimalvalueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ECLVisitor:
		return t.VisitDecimalvalue(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ECLParser) Decimalvalue() (localctx IDecimalvalueContext) {
	localctx = NewDecimalvalueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, ECLParserRULE_decimalvalue)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(483)
		p.Integervalue()
	}
	{
		p.SetState(484)
		p.Match(ECLParserPERIOD)
	}
	p.SetState(486)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<ECLParserZERO)|(1<<ECLParserONE)|(1<<ECLParserTWO)|(1<<ECLParserTHREE)|(1<<ECLParserFOUR)|(1<<ECLParserFIVE)|(1<<ECLParserSIX)|(1<<ECLParserSEVEN)|(1<<ECLParserEIGHT)|(1<<ECLParserNINE))) != 0) {
		{
			p.SetState(485)
			p.Digit()
		}

		p.SetState(488)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// INonnegativeintegervalueContext is an interface to support dynamic dispatch.
type INonnegativeintegervalueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNonnegativeintegervalueContext differentiates from other interfaces.
	IsNonnegativeintegervalueContext()
}

type NonnegativeintegervalueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNonnegativeintegervalueContext() *NonnegativeintegervalueContext {
	var p = new(NonnegativeintegervalueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ECLParserRULE_nonnegativeintegervalue
	return p
}

func (*NonnegativeintegervalueContext) IsNonnegativeintegervalueContext() {}

func NewNonnegativeintegervalueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NonnegativeintegervalueContext {
	var p = new(NonnegativeintegervalueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ECLParserRULE_nonnegativeintegervalue

	return p
}

func (s *NonnegativeintegervalueContext) GetParser() antlr.Parser { return s.parser }

func (s *NonnegativeintegervalueContext) Digitnonzero() IDigitnonzeroContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDigitnonzeroContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDigitnonzeroContext)
}

func (s *NonnegativeintegervalueContext) AllDigit() []IDigitContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDigitContext)(nil)).Elem())
	var tst = make([]IDigitContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDigitContext)
		}
	}

	return tst
}

func (s *NonnegativeintegervalueContext) Digit(i int) IDigitContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDigitContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDigitContext)
}

func (s *NonnegativeintegervalueContext) Zero() IZeroContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IZeroContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IZeroContext)
}

func (s *NonnegativeintegervalueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NonnegativeintegervalueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NonnegativeintegervalueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ECLListener); ok {
		listenerT.EnterNonnegativeintegervalue(s)
	}
}

func (s *NonnegativeintegervalueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ECLListener); ok {
		listenerT.ExitNonnegativeintegervalue(s)
	}
}

func (s *NonnegativeintegervalueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ECLVisitor:
		return t.VisitNonnegativeintegervalue(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ECLParser) Nonnegativeintegervalue() (localctx INonnegativeintegervalueContext) {
	localctx = NewNonnegativeintegervalueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, ECLParserRULE_nonnegativeintegervalue)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(498)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ECLParserONE, ECLParserTWO, ECLParserTHREE, ECLParserFOUR, ECLParserFIVE, ECLParserSIX, ECLParserSEVEN, ECLParserEIGHT, ECLParserNINE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(490)
			p.Digitnonzero()
		}
		p.SetState(494)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<ECLParserZERO)|(1<<ECLParserONE)|(1<<ECLParserTWO)|(1<<ECLParserTHREE)|(1<<ECLParserFOUR)|(1<<ECLParserFIVE)|(1<<ECLParserSIX)|(1<<ECLParserSEVEN)|(1<<ECLParserEIGHT)|(1<<ECLParserNINE))) != 0 {
			{
				p.SetState(491)
				p.Digit()
			}

			p.SetState(496)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	case ECLParserZERO:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(497)
			p.Zero()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ISctidContext is an interface to support dynamic dispatch.
type ISctidContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSctidContext differentiates from other interfaces.
	IsSctidContext()
}

type SctidContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySctidContext() *SctidContext {
	var p = new(SctidContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ECLParserRULE_sctid
	return p
}

func (*SctidContext) IsSctidContext() {}

func NewSctidContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SctidContext {
	var p = new(SctidContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ECLParserRULE_sctid

	return p
}

func (s *SctidContext) GetParser() antlr.Parser { return s.parser }

func (s *SctidContext) Digitnonzero() IDigitnonzeroContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDigitnonzeroContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDigitnonzeroContext)
}

func (s *SctidContext) AllDigit() []IDigitContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDigitContext)(nil)).Elem())
	var tst = make([]IDigitContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDigitContext)
		}
	}

	return tst
}

func (s *SctidContext) Digit(i int) IDigitContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDigitContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDigitContext)
}

func (s *SctidContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SctidContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SctidContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ECLListener); ok {
		listenerT.EnterSctid(s)
	}
}

func (s *SctidContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ECLListener); ok {
		listenerT.ExitSctid(s)
	}
}

func (s *SctidContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ECLVisitor:
		return t.VisitSctid(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ECLParser) Sctid() (localctx ISctidContext) {
	localctx = NewSctidContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, ECLParserRULE_sctid)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(500)
		p.Digitnonzero()
	}

	{
		p.SetState(501)
		p.Digit()
	}

	{
		p.SetState(502)
		p.Digit()
	}

	{
		p.SetState(503)
		p.Digit()
	}

	{
		p.SetState(504)
		p.Digit()
	}

	{
		p.SetState(505)
		p.Digit()
	}

	p.SetState(597)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 42, p.GetParserRuleContext()) {
	case 1:
		p.SetState(507)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if ((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<ECLParserZERO)|(1<<ECLParserONE)|(1<<ECLParserTWO)|(1<<ECLParserTHREE)|(1<<ECLParserFOUR)|(1<<ECLParserFIVE)|(1<<ECLParserSIX)|(1<<ECLParserSEVEN)|(1<<ECLParserEIGHT)|(1<<ECLParserNINE))) != 0 {
			{
				p.SetState(506)
				p.Digit()
			}

		}

	case 2:
		{
			p.SetState(509)
			p.Digit()
		}

		{
			p.SetState(510)
			p.Digit()
		}

	case 3:
		{
			p.SetState(512)
			p.Digit()
		}

		{
			p.SetState(513)
			p.Digit()
		}

		{
			p.SetState(514)
			p.Digit()
		}

	case 4:
		{
			p.SetState(516)
			p.Digit()
		}

		{
			p.SetState(517)
			p.Digit()
		}

		{
			p.SetState(518)
			p.Digit()
		}

		{
			p.SetState(519)
			p.Digit()
		}

	case 5:
		{
			p.SetState(521)
			p.Digit()
		}

		{
			p.SetState(522)
			p.Digit()
		}

		{
			p.SetState(523)
			p.Digit()
		}

		{
			p.SetState(524)
			p.Digit()
		}

		{
			p.SetState(525)
			p.Digit()
		}

	case 6:
		{
			p.SetState(527)
			p.Digit()
		}

		{
			p.SetState(528)
			p.Digit()
		}

		{
			p.SetState(529)
			p.Digit()
		}

		{
			p.SetState(530)
			p.Digit()
		}

		{
			p.SetState(531)
			p.Digit()
		}

		{
			p.SetState(532)
			p.Digit()
		}

	case 7:
		{
			p.SetState(534)
			p.Digit()
		}

		{
			p.SetState(535)
			p.Digit()
		}

		{
			p.SetState(536)
			p.Digit()
		}

		{
			p.SetState(537)
			p.Digit()
		}

		{
			p.SetState(538)
			p.Digit()
		}

		{
			p.SetState(539)
			p.Digit()
		}

		{
			p.SetState(540)
			p.Digit()
		}

	case 8:
		{
			p.SetState(542)
			p.Digit()
		}

		{
			p.SetState(543)
			p.Digit()
		}

		{
			p.SetState(544)
			p.Digit()
		}

		{
			p.SetState(545)
			p.Digit()
		}

		{
			p.SetState(546)
			p.Digit()
		}

		{
			p.SetState(547)
			p.Digit()
		}

		{
			p.SetState(548)
			p.Digit()
		}

		{
			p.SetState(549)
			p.Digit()
		}

	case 9:
		{
			p.SetState(551)
			p.Digit()
		}

		{
			p.SetState(552)
			p.Digit()
		}

		{
			p.SetState(553)
			p.Digit()
		}

		{
			p.SetState(554)
			p.Digit()
		}

		{
			p.SetState(555)
			p.Digit()
		}

		{
			p.SetState(556)
			p.Digit()
		}

		{
			p.SetState(557)
			p.Digit()
		}

		{
			p.SetState(558)
			p.Digit()
		}

		{
			p.SetState(559)
			p.Digit()
		}

	case 10:
		{
			p.SetState(561)
			p.Digit()
		}

		{
			p.SetState(562)
			p.Digit()
		}

		{
			p.SetState(563)
			p.Digit()
		}

		{
			p.SetState(564)
			p.Digit()
		}

		{
			p.SetState(565)
			p.Digit()
		}

		{
			p.SetState(566)
			p.Digit()
		}

		{
			p.SetState(567)
			p.Digit()
		}

		{
			p.SetState(568)
			p.Digit()
		}

		{
			p.SetState(569)
			p.Digit()
		}

		{
			p.SetState(570)
			p.Digit()
		}

	case 11:
		{
			p.SetState(572)
			p.Digit()
		}

		{
			p.SetState(573)
			p.Digit()
		}

		{
			p.SetState(574)
			p.Digit()
		}

		{
			p.SetState(575)
			p.Digit()
		}

		{
			p.SetState(576)
			p.Digit()
		}

		{
			p.SetState(577)
			p.Digit()
		}

		{
			p.SetState(578)
			p.Digit()
		}

		{
			p.SetState(579)
			p.Digit()
		}

		{
			p.SetState(580)
			p.Digit()
		}

		{
			p.SetState(581)
			p.Digit()
		}

		{
			p.SetState(582)
			p.Digit()
		}

	case 12:
		{
			p.SetState(584)
			p.Digit()
		}

		{
			p.SetState(585)
			p.Digit()
		}

		{
			p.SetState(586)
			p.Digit()
		}

		{
			p.SetState(587)
			p.Digit()
		}

		{
			p.SetState(588)
			p.Digit()
		}

		{
			p.SetState(589)
			p.Digit()
		}

		{
			p.SetState(590)
			p.Digit()
		}

		{
			p.SetState(591)
			p.Digit()
		}

		{
			p.SetState(592)
			p.Digit()
		}

		{
			p.SetState(593)
			p.Digit()
		}

		{
			p.SetState(594)
			p.Digit()
		}

		{
			p.SetState(595)
			p.Digit()
		}

	}

	return localctx
}

// IWsContext is an interface to support dynamic dispatch.
type IWsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWsContext differentiates from other interfaces.
	IsWsContext()
}

type WsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWsContext() *WsContext {
	var p = new(WsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ECLParserRULE_ws
	return p
}

func (*WsContext) IsWsContext() {}

func NewWsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WsContext {
	var p = new(WsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ECLParserRULE_ws

	return p
}

func (s *WsContext) GetParser() antlr.Parser { return s.parser }

func (s *WsContext) AllSp() []ISpContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISpContext)(nil)).Elem())
	var tst = make([]ISpContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISpContext)
		}
	}

	return tst
}

func (s *WsContext) Sp(i int) ISpContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISpContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISpContext)
}

func (s *WsContext) AllHtab() []IHtabContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IHtabContext)(nil)).Elem())
	var tst = make([]IHtabContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IHtabContext)
		}
	}

	return tst
}

func (s *WsContext) Htab(i int) IHtabContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHtabContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IHtabContext)
}

func (s *WsContext) AllCr() []ICrContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICrContext)(nil)).Elem())
	var tst = make([]ICrContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICrContext)
		}
	}

	return tst
}

func (s *WsContext) Cr(i int) ICrContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICrContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICrContext)
}

func (s *WsContext) AllLf() []ILfContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ILfContext)(nil)).Elem())
	var tst = make([]ILfContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ILfContext)
		}
	}

	return tst
}

func (s *WsContext) Lf(i int) ILfContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILfContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ILfContext)
}

func (s *WsContext) AllComment() []ICommentContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICommentContext)(nil)).Elem())
	var tst = make([]ICommentContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICommentContext)
		}
	}

	return tst
}

func (s *WsContext) Comment(i int) ICommentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICommentContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICommentContext)
}

func (s *WsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ECLListener); ok {
		listenerT.EnterWs(s)
	}
}

func (s *WsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ECLListener); ok {
		listenerT.ExitWs(s)
	}
}

func (s *WsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ECLVisitor:
		return t.VisitWs(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ECLParser) Ws() (localctx IWsContext) {
	localctx = NewWsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, ECLParserRULE_ws)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(606)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 44, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(604)
			p.GetErrorHandler().Sync(p)

			switch p.GetTokenStream().LA(1) {
			case ECLParserSPACE:
				{
					p.SetState(599)
					p.Sp()
				}

			case ECLParserTAB:
				{
					p.SetState(600)
					p.Htab()
				}

			case ECLParserCR:
				{
					p.SetState(601)
					p.Cr()
				}

			case ECLParserLF:
				{
					p.SetState(602)
					p.Lf()
				}

			case ECLParserSLASH:
				{
					p.SetState(603)
					p.Comment()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

		}
		p.SetState(608)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 44, p.GetParserRuleContext())
	}

	return localctx
}

// IMwsContext is an interface to support dynamic dispatch.
type IMwsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMwsContext differentiates from other interfaces.
	IsMwsContext()
}

type MwsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMwsContext() *MwsContext {
	var p = new(MwsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ECLParserRULE_mws
	return p
}

func (*MwsContext) IsMwsContext() {}

func NewMwsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MwsContext {
	var p = new(MwsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ECLParserRULE_mws

	return p
}

func (s *MwsContext) GetParser() antlr.Parser { return s.parser }

func (s *MwsContext) AllSp() []ISpContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISpContext)(nil)).Elem())
	var tst = make([]ISpContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISpContext)
		}
	}

	return tst
}

func (s *MwsContext) Sp(i int) ISpContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISpContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISpContext)
}

func (s *MwsContext) AllHtab() []IHtabContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IHtabContext)(nil)).Elem())
	var tst = make([]IHtabContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IHtabContext)
		}
	}

	return tst
}

func (s *MwsContext) Htab(i int) IHtabContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHtabContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IHtabContext)
}

func (s *MwsContext) AllCr() []ICrContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICrContext)(nil)).Elem())
	var tst = make([]ICrContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICrContext)
		}
	}

	return tst
}

func (s *MwsContext) Cr(i int) ICrContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICrContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICrContext)
}

func (s *MwsContext) AllLf() []ILfContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ILfContext)(nil)).Elem())
	var tst = make([]ILfContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ILfContext)
		}
	}

	return tst
}

func (s *MwsContext) Lf(i int) ILfContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILfContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ILfContext)
}

func (s *MwsContext) AllComment() []ICommentContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICommentContext)(nil)).Elem())
	var tst = make([]ICommentContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICommentContext)
		}
	}

	return tst
}

func (s *MwsContext) Comment(i int) ICommentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICommentContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICommentContext)
}

func (s *MwsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MwsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MwsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ECLListener); ok {
		listenerT.EnterMws(s)
	}
}

func (s *MwsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ECLListener); ok {
		listenerT.ExitMws(s)
	}
}

func (s *MwsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ECLVisitor:
		return t.VisitMws(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ECLParser) Mws() (localctx IMwsContext) {
	localctx = NewMwsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, ECLParserRULE_mws)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(614)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			p.SetState(614)
			p.GetErrorHandler().Sync(p)

			switch p.GetTokenStream().LA(1) {
			case ECLParserSPACE:
				{
					p.SetState(609)
					p.Sp()
				}

			case ECLParserTAB:
				{
					p.SetState(610)
					p.Htab()
				}

			case ECLParserCR:
				{
					p.SetState(611)
					p.Cr()
				}

			case ECLParserLF:
				{
					p.SetState(612)
					p.Lf()
				}

			case ECLParserSLASH:
				{
					p.SetState(613)
					p.Comment()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(616)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 46, p.GetParserRuleContext())
	}

	return localctx
}

// ICommentContext is an interface to support dynamic dispatch.
type ICommentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCommentContext differentiates from other interfaces.
	IsCommentContext()
}

type CommentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCommentContext() *CommentContext {
	var p = new(CommentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ECLParserRULE_comment
	return p
}

func (*CommentContext) IsCommentContext() {}

func NewCommentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CommentContext {
	var p = new(CommentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ECLParserRULE_comment

	return p
}

func (s *CommentContext) GetParser() antlr.Parser { return s.parser }

func (s *CommentContext) AllSLASH() []antlr.TerminalNode {
	return s.GetTokens(ECLParserSLASH)
}

func (s *CommentContext) SLASH(i int) antlr.TerminalNode {
	return s.GetToken(ECLParserSLASH, i)
}

func (s *CommentContext) AllASTERISK() []antlr.TerminalNode {
	return s.GetTokens(ECLParserASTERISK)
}

func (s *CommentContext) ASTERISK(i int) antlr.TerminalNode {
	return s.GetToken(ECLParserASTERISK, i)
}

func (s *CommentContext) AllNonstarchar() []INonstarcharContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INonstarcharContext)(nil)).Elem())
	var tst = make([]INonstarcharContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INonstarcharContext)
		}
	}

	return tst
}

func (s *CommentContext) Nonstarchar(i int) INonstarcharContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INonstarcharContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INonstarcharContext)
}

func (s *CommentContext) AllStarwithnonfslash() []IStarwithnonfslashContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStarwithnonfslashContext)(nil)).Elem())
	var tst = make([]IStarwithnonfslashContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStarwithnonfslashContext)
		}
	}

	return tst
}

func (s *CommentContext) Starwithnonfslash(i int) IStarwithnonfslashContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStarwithnonfslashContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStarwithnonfslashContext)
}

func (s *CommentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CommentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CommentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ECLListener); ok {
		listenerT.EnterComment(s)
	}
}

func (s *CommentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ECLListener); ok {
		listenerT.ExitComment(s)
	}
}

func (s *CommentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ECLVisitor:
		return t.VisitComment(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ECLParser) Comment() (localctx ICommentContext) {
	localctx = NewCommentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, ECLParserRULE_comment)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(618)
		p.Match(ECLParserSLASH)
	}
	{
		p.SetState(619)
		p.Match(ECLParserASTERISK)
	}

	p.SetState(625)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 48, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(623)
			p.GetErrorHandler().Sync(p)

			switch p.GetTokenStream().LA(1) {
			case ECLParserTAB, ECLParserLF, ECLParserCR, ECLParserSPACE, ECLParserEXCLAMATION, ECLParserQUOTE, ECLParserPOUND, ECLParserDOLLAR, ECLParserPERCENT, ECLParserAMPERSAND, ECLParserAPOSTROPHE, ECLParserLEFT_PAREN, ECLParserRIGHT_PAREN, ECLParserPLUS, ECLParserCOMMA, ECLParserDASH, ECLParserPERIOD, ECLParserSLASH, ECLParserZERO, ECLParserONE, ECLParserTWO, ECLParserTHREE, ECLParserFOUR, ECLParserFIVE, ECLParserSIX, ECLParserSEVEN, ECLParserEIGHT, ECLParserNINE, ECLParserCOLON, ECLParserSEMICOLON, ECLParserLESS_THAN, ECLParserEQUALS, ECLParserGREATER_THAN, ECLParserQUESTION, ECLParserAT, ECLParserCAP_A, ECLParserCAP_B, ECLParserCAP_C, ECLParserCAP_D, ECLParserCAP_E, ECLParserCAP_F, ECLParserCAP_G, ECLParserCAP_H, ECLParserCAP_I, ECLParserCAP_J, ECLParserCAP_K, ECLParserCAP_L, ECLParserCAP_M, ECLParserCAP_N, ECLParserCAP_O, ECLParserCAP_P, ECLParserCAP_Q, ECLParserCAP_R, ECLParserCAP_S, ECLParserCAP_T, ECLParserCAP_U, ECLParserCAP_V, ECLParserCAP_W, ECLParserCAP_X, ECLParserCAP_Y, ECLParserCAP_Z, ECLParserLEFT_BRACE, ECLParserBACKSLASH, ECLParserRIGHT_BRACE, ECLParserCARAT, ECLParserUNDERSCORE, ECLParserACCENT, ECLParserA, ECLParserB, ECLParserC, ECLParserD, ECLParserE, ECLParserF, ECLParserG, ECLParserH, ECLParserI, ECLParserJ, ECLParserK, ECLParserL, ECLParserM, ECLParserN, ECLParserO, ECLParserP, ECLParserQ, ECLParserR, ECLParserS, ECLParserT, ECLParserU, ECLParserV, ECLParserW, ECLParserX, ECLParserY, ECLParserZ, ECLParserLEFT_CURLY_BRACE, ECLParserPIPE, ECLParserRIGHT_CURLY_BRACE, ECLParserTILDE, ECLParserU_00C2, ECLParserU_00C3, ECLParserU_00C4, ECLParserU_00C5, ECLParserU_00C6, ECLParserU_00C7, ECLParserU_00C8, ECLParserU_00C9, ECLParserU_00CA, ECLParserU_00CB, ECLParserU_00CC, ECLParserU_00CD, ECLParserU_00CE, ECLParserU_00CF, ECLParserU_00D0, ECLParserU_00D1, ECLParserU_00D2, ECLParserU_00D3, ECLParserU_00D4, ECLParserU_00D5, ECLParserU_00D6, ECLParserU_00D7, ECLParserU_00D8, ECLParserU_00D9, ECLParserU_00DA, ECLParserU_00DB, ECLParserU_00DC, ECLParserU_00DD, ECLParserU_00DE, ECLParserU_00DF, ECLParserU_00E0, ECLParserU_00E1, ECLParserU_00E2, ECLParserU_00E3, ECLParserU_00E4, ECLParserU_00E5, ECLParserU_00E6, ECLParserU_00E7, ECLParserU_00E8, ECLParserU_00E9, ECLParserU_00EA, ECLParserU_00EB, ECLParserU_00EC, ECLParserU_00ED, ECLParserU_00EE, ECLParserU_00EF, ECLParserU_00F0, ECLParserU_00F1, ECLParserU_00F2, ECLParserU_00F3, ECLParserU_00F4:
				{
					p.SetState(621)
					p.Nonstarchar()
				}

			case ECLParserASTERISK:
				{
					p.SetState(622)
					p.Starwithnonfslash()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

		}
		p.SetState(627)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 48, p.GetParserRuleContext())
	}

	{
		p.SetState(628)
		p.Match(ECLParserASTERISK)
	}
	{
		p.SetState(629)
		p.Match(ECLParserSLASH)
	}

	return localctx
}

// INonstarcharContext is an interface to support dynamic dispatch.
type INonstarcharContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNonstarcharContext differentiates from other interfaces.
	IsNonstarcharContext()
}

type NonstarcharContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNonstarcharContext() *NonstarcharContext {
	var p = new(NonstarcharContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ECLParserRULE_nonstarchar
	return p
}

func (*NonstarcharContext) IsNonstarcharContext() {}

func NewNonstarcharContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NonstarcharContext {
	var p = new(NonstarcharContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ECLParserRULE_nonstarchar

	return p
}

func (s *NonstarcharContext) GetParser() antlr.Parser { return s.parser }

func (s *NonstarcharContext) Sp() ISpContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISpContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISpContext)
}

func (s *NonstarcharContext) Htab() IHtabContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHtabContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHtabContext)
}

func (s *NonstarcharContext) Cr() ICrContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICrContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICrContext)
}

func (s *NonstarcharContext) Lf() ILfContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILfContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILfContext)
}

func (s *NonstarcharContext) EXCLAMATION() antlr.TerminalNode {
	return s.GetToken(ECLParserEXCLAMATION, 0)
}

func (s *NonstarcharContext) QUOTE() antlr.TerminalNode {
	return s.GetToken(ECLParserQUOTE, 0)
}

func (s *NonstarcharContext) POUND() antlr.TerminalNode {
	return s.GetToken(ECLParserPOUND, 0)
}

func (s *NonstarcharContext) DOLLAR() antlr.TerminalNode {
	return s.GetToken(ECLParserDOLLAR, 0)
}

func (s *NonstarcharContext) PERCENT() antlr.TerminalNode {
	return s.GetToken(ECLParserPERCENT, 0)
}

func (s *NonstarcharContext) AMPERSAND() antlr.TerminalNode {
	return s.GetToken(ECLParserAMPERSAND, 0)
}

func (s *NonstarcharContext) APOSTROPHE() antlr.TerminalNode {
	return s.GetToken(ECLParserAPOSTROPHE, 0)
}

func (s *NonstarcharContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(ECLParserLEFT_PAREN, 0)
}

func (s *NonstarcharContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(ECLParserRIGHT_PAREN, 0)
}

func (s *NonstarcharContext) PLUS() antlr.TerminalNode {
	return s.GetToken(ECLParserPLUS, 0)
}

func (s *NonstarcharContext) COMMA() antlr.TerminalNode {
	return s.GetToken(ECLParserCOMMA, 0)
}

func (s *NonstarcharContext) DASH() antlr.TerminalNode {
	return s.GetToken(ECLParserDASH, 0)
}

func (s *NonstarcharContext) PERIOD() antlr.TerminalNode {
	return s.GetToken(ECLParserPERIOD, 0)
}

func (s *NonstarcharContext) SLASH() antlr.TerminalNode {
	return s.GetToken(ECLParserSLASH, 0)
}

func (s *NonstarcharContext) ZERO() antlr.TerminalNode {
	return s.GetToken(ECLParserZERO, 0)
}

func (s *NonstarcharContext) ONE() antlr.TerminalNode {
	return s.GetToken(ECLParserONE, 0)
}

func (s *NonstarcharContext) TWO() antlr.TerminalNode {
	return s.GetToken(ECLParserTWO, 0)
}

func (s *NonstarcharContext) THREE() antlr.TerminalNode {
	return s.GetToken(ECLParserTHREE, 0)
}

func (s *NonstarcharContext) FOUR() antlr.TerminalNode {
	return s.GetToken(ECLParserFOUR, 0)
}

func (s *NonstarcharContext) FIVE() antlr.TerminalNode {
	return s.GetToken(ECLParserFIVE, 0)
}

func (s *NonstarcharContext) SIX() antlr.TerminalNode {
	return s.GetToken(ECLParserSIX, 0)
}

func (s *NonstarcharContext) SEVEN() antlr.TerminalNode {
	return s.GetToken(ECLParserSEVEN, 0)
}

func (s *NonstarcharContext) EIGHT() antlr.TerminalNode {
	return s.GetToken(ECLParserEIGHT, 0)
}

func (s *NonstarcharContext) NINE() antlr.TerminalNode {
	return s.GetToken(ECLParserNINE, 0)
}

func (s *NonstarcharContext) COLON() antlr.TerminalNode {
	return s.GetToken(ECLParserCOLON, 0)
}

func (s *NonstarcharContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(ECLParserSEMICOLON, 0)
}

func (s *NonstarcharContext) LESS_THAN() antlr.TerminalNode {
	return s.GetToken(ECLParserLESS_THAN, 0)
}

func (s *NonstarcharContext) EQUALS() antlr.TerminalNode {
	return s.GetToken(ECLParserEQUALS, 0)
}

func (s *NonstarcharContext) GREATER_THAN() antlr.TerminalNode {
	return s.GetToken(ECLParserGREATER_THAN, 0)
}

func (s *NonstarcharContext) QUESTION() antlr.TerminalNode {
	return s.GetToken(ECLParserQUESTION, 0)
}

func (s *NonstarcharContext) AT() antlr.TerminalNode {
	return s.GetToken(ECLParserAT, 0)
}

func (s *NonstarcharContext) CAP_A() antlr.TerminalNode {
	return s.GetToken(ECLParserCAP_A, 0)
}

func (s *NonstarcharContext) CAP_B() antlr.TerminalNode {
	return s.GetToken(ECLParserCAP_B, 0)
}

func (s *NonstarcharContext) CAP_C() antlr.TerminalNode {
	return s.GetToken(ECLParserCAP_C, 0)
}

func (s *NonstarcharContext) CAP_D() antlr.TerminalNode {
	return s.GetToken(ECLParserCAP_D, 0)
}

func (s *NonstarcharContext) CAP_E() antlr.TerminalNode {
	return s.GetToken(ECLParserCAP_E, 0)
}

func (s *NonstarcharContext) CAP_F() antlr.TerminalNode {
	return s.GetToken(ECLParserCAP_F, 0)
}

func (s *NonstarcharContext) CAP_G() antlr.TerminalNode {
	return s.GetToken(ECLParserCAP_G, 0)
}

func (s *NonstarcharContext) CAP_H() antlr.TerminalNode {
	return s.GetToken(ECLParserCAP_H, 0)
}

func (s *NonstarcharContext) CAP_I() antlr.TerminalNode {
	return s.GetToken(ECLParserCAP_I, 0)
}

func (s *NonstarcharContext) CAP_J() antlr.TerminalNode {
	return s.GetToken(ECLParserCAP_J, 0)
}

func (s *NonstarcharContext) CAP_K() antlr.TerminalNode {
	return s.GetToken(ECLParserCAP_K, 0)
}

func (s *NonstarcharContext) CAP_L() antlr.TerminalNode {
	return s.GetToken(ECLParserCAP_L, 0)
}

func (s *NonstarcharContext) CAP_M() antlr.TerminalNode {
	return s.GetToken(ECLParserCAP_M, 0)
}

func (s *NonstarcharContext) CAP_N() antlr.TerminalNode {
	return s.GetToken(ECLParserCAP_N, 0)
}

func (s *NonstarcharContext) CAP_O() antlr.TerminalNode {
	return s.GetToken(ECLParserCAP_O, 0)
}

func (s *NonstarcharContext) CAP_P() antlr.TerminalNode {
	return s.GetToken(ECLParserCAP_P, 0)
}

func (s *NonstarcharContext) CAP_Q() antlr.TerminalNode {
	return s.GetToken(ECLParserCAP_Q, 0)
}

func (s *NonstarcharContext) CAP_R() antlr.TerminalNode {
	return s.GetToken(ECLParserCAP_R, 0)
}

func (s *NonstarcharContext) CAP_S() antlr.TerminalNode {
	return s.GetToken(ECLParserCAP_S, 0)
}

func (s *NonstarcharContext) CAP_T() antlr.TerminalNode {
	return s.GetToken(ECLParserCAP_T, 0)
}

func (s *NonstarcharContext) CAP_U() antlr.TerminalNode {
	return s.GetToken(ECLParserCAP_U, 0)
}

func (s *NonstarcharContext) CAP_V() antlr.TerminalNode {
	return s.GetToken(ECLParserCAP_V, 0)
}

func (s *NonstarcharContext) CAP_W() antlr.TerminalNode {
	return s.GetToken(ECLParserCAP_W, 0)
}

func (s *NonstarcharContext) CAP_X() antlr.TerminalNode {
	return s.GetToken(ECLParserCAP_X, 0)
}

func (s *NonstarcharContext) CAP_Y() antlr.TerminalNode {
	return s.GetToken(ECLParserCAP_Y, 0)
}

func (s *NonstarcharContext) CAP_Z() antlr.TerminalNode {
	return s.GetToken(ECLParserCAP_Z, 0)
}

func (s *NonstarcharContext) LEFT_BRACE() antlr.TerminalNode {
	return s.GetToken(ECLParserLEFT_BRACE, 0)
}

func (s *NonstarcharContext) BACKSLASH() antlr.TerminalNode {
	return s.GetToken(ECLParserBACKSLASH, 0)
}

func (s *NonstarcharContext) RIGHT_BRACE() antlr.TerminalNode {
	return s.GetToken(ECLParserRIGHT_BRACE, 0)
}

func (s *NonstarcharContext) CARAT() antlr.TerminalNode {
	return s.GetToken(ECLParserCARAT, 0)
}

func (s *NonstarcharContext) UNDERSCORE() antlr.TerminalNode {
	return s.GetToken(ECLParserUNDERSCORE, 0)
}

func (s *NonstarcharContext) ACCENT() antlr.TerminalNode {
	return s.GetToken(ECLParserACCENT, 0)
}

func (s *NonstarcharContext) A() antlr.TerminalNode {
	return s.GetToken(ECLParserA, 0)
}

func (s *NonstarcharContext) B() antlr.TerminalNode {
	return s.GetToken(ECLParserB, 0)
}

func (s *NonstarcharContext) C() antlr.TerminalNode {
	return s.GetToken(ECLParserC, 0)
}

func (s *NonstarcharContext) D() antlr.TerminalNode {
	return s.GetToken(ECLParserD, 0)
}

func (s *NonstarcharContext) E() antlr.TerminalNode {
	return s.GetToken(ECLParserE, 0)
}

func (s *NonstarcharContext) F() antlr.TerminalNode {
	return s.GetToken(ECLParserF, 0)
}

func (s *NonstarcharContext) G() antlr.TerminalNode {
	return s.GetToken(ECLParserG, 0)
}

func (s *NonstarcharContext) H() antlr.TerminalNode {
	return s.GetToken(ECLParserH, 0)
}

func (s *NonstarcharContext) I() antlr.TerminalNode {
	return s.GetToken(ECLParserI, 0)
}

func (s *NonstarcharContext) J() antlr.TerminalNode {
	return s.GetToken(ECLParserJ, 0)
}

func (s *NonstarcharContext) K() antlr.TerminalNode {
	return s.GetToken(ECLParserK, 0)
}

func (s *NonstarcharContext) L() antlr.TerminalNode {
	return s.GetToken(ECLParserL, 0)
}

func (s *NonstarcharContext) M() antlr.TerminalNode {
	return s.GetToken(ECLParserM, 0)
}

func (s *NonstarcharContext) N() antlr.TerminalNode {
	return s.GetToken(ECLParserN, 0)
}

func (s *NonstarcharContext) O() antlr.TerminalNode {
	return s.GetToken(ECLParserO, 0)
}

func (s *NonstarcharContext) P() antlr.TerminalNode {
	return s.GetToken(ECLParserP, 0)
}

func (s *NonstarcharContext) Q() antlr.TerminalNode {
	return s.GetToken(ECLParserQ, 0)
}

func (s *NonstarcharContext) R() antlr.TerminalNode {
	return s.GetToken(ECLParserR, 0)
}

func (s *NonstarcharContext) S() antlr.TerminalNode {
	return s.GetToken(ECLParserS, 0)
}

func (s *NonstarcharContext) T() antlr.TerminalNode {
	return s.GetToken(ECLParserT, 0)
}

func (s *NonstarcharContext) U() antlr.TerminalNode {
	return s.GetToken(ECLParserU, 0)
}

func (s *NonstarcharContext) V() antlr.TerminalNode {
	return s.GetToken(ECLParserV, 0)
}

func (s *NonstarcharContext) W() antlr.TerminalNode {
	return s.GetToken(ECLParserW, 0)
}

func (s *NonstarcharContext) X() antlr.TerminalNode {
	return s.GetToken(ECLParserX, 0)
}

func (s *NonstarcharContext) Y() antlr.TerminalNode {
	return s.GetToken(ECLParserY, 0)
}

func (s *NonstarcharContext) Z() antlr.TerminalNode {
	return s.GetToken(ECLParserZ, 0)
}

func (s *NonstarcharContext) LEFT_CURLY_BRACE() antlr.TerminalNode {
	return s.GetToken(ECLParserLEFT_CURLY_BRACE, 0)
}

func (s *NonstarcharContext) PIPE() antlr.TerminalNode {
	return s.GetToken(ECLParserPIPE, 0)
}

func (s *NonstarcharContext) RIGHT_CURLY_BRACE() antlr.TerminalNode {
	return s.GetToken(ECLParserRIGHT_CURLY_BRACE, 0)
}

func (s *NonstarcharContext) TILDE() antlr.TerminalNode {
	return s.GetToken(ECLParserTILDE, 0)
}

func (s *NonstarcharContext) Utf8_2() IUtf8_2Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUtf8_2Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUtf8_2Context)
}

func (s *NonstarcharContext) Utf8_3() IUtf8_3Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUtf8_3Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUtf8_3Context)
}

func (s *NonstarcharContext) Utf8_4() IUtf8_4Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUtf8_4Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUtf8_4Context)
}

func (s *NonstarcharContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NonstarcharContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NonstarcharContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ECLListener); ok {
		listenerT.EnterNonstarchar(s)
	}
}

func (s *NonstarcharContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ECLListener); ok {
		listenerT.ExitNonstarchar(s)
	}
}

func (s *NonstarcharContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ECLVisitor:
		return t.VisitNonstarchar(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ECLParser) Nonstarchar() (localctx INonstarcharContext) {
	localctx = NewNonstarcharContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, ECLParserRULE_nonstarchar)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(640)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ECLParserSPACE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(631)
			p.Sp()
		}

	case ECLParserTAB:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(632)
			p.Htab()
		}

	case ECLParserCR:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(633)
			p.Cr()
		}

	case ECLParserLF:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(634)
			p.Lf()
		}

	case ECLParserEXCLAMATION, ECLParserQUOTE, ECLParserPOUND, ECLParserDOLLAR, ECLParserPERCENT, ECLParserAMPERSAND, ECLParserAPOSTROPHE, ECLParserLEFT_PAREN, ECLParserRIGHT_PAREN:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(635)
			_la = p.GetTokenStream().LA(1)

			if !(((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<ECLParserEXCLAMATION)|(1<<ECLParserQUOTE)|(1<<ECLParserPOUND)|(1<<ECLParserDOLLAR)|(1<<ECLParserPERCENT)|(1<<ECLParserAMPERSAND)|(1<<ECLParserAPOSTROPHE)|(1<<ECLParserLEFT_PAREN)|(1<<ECLParserRIGHT_PAREN))) != 0) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case ECLParserPLUS, ECLParserCOMMA, ECLParserDASH, ECLParserPERIOD, ECLParserSLASH, ECLParserZERO, ECLParserONE, ECLParserTWO, ECLParserTHREE, ECLParserFOUR, ECLParserFIVE, ECLParserSIX, ECLParserSEVEN, ECLParserEIGHT, ECLParserNINE, ECLParserCOLON, ECLParserSEMICOLON, ECLParserLESS_THAN, ECLParserEQUALS, ECLParserGREATER_THAN, ECLParserQUESTION, ECLParserAT, ECLParserCAP_A, ECLParserCAP_B, ECLParserCAP_C, ECLParserCAP_D, ECLParserCAP_E, ECLParserCAP_F, ECLParserCAP_G, ECLParserCAP_H, ECLParserCAP_I, ECLParserCAP_J, ECLParserCAP_K, ECLParserCAP_L, ECLParserCAP_M, ECLParserCAP_N, ECLParserCAP_O, ECLParserCAP_P, ECLParserCAP_Q, ECLParserCAP_R, ECLParserCAP_S, ECLParserCAP_T, ECLParserCAP_U, ECLParserCAP_V, ECLParserCAP_W, ECLParserCAP_X, ECLParserCAP_Y, ECLParserCAP_Z, ECLParserLEFT_BRACE, ECLParserBACKSLASH, ECLParserRIGHT_BRACE, ECLParserCARAT, ECLParserUNDERSCORE, ECLParserACCENT, ECLParserA, ECLParserB, ECLParserC, ECLParserD, ECLParserE, ECLParserF, ECLParserG, ECLParserH, ECLParserI, ECLParserJ, ECLParserK, ECLParserL, ECLParserM, ECLParserN, ECLParserO, ECLParserP, ECLParserQ, ECLParserR, ECLParserS, ECLParserT, ECLParserU, ECLParserV, ECLParserW, ECLParserX, ECLParserY, ECLParserZ, ECLParserLEFT_CURLY_BRACE, ECLParserPIPE, ECLParserRIGHT_CURLY_BRACE, ECLParserTILDE:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(636)
			_la = p.GetTokenStream().LA(1)

			if !((((_la-15)&-(0x1f+1)) == 0 && ((1<<uint((_la-15)))&((1<<(ECLParserPLUS-15))|(1<<(ECLParserCOMMA-15))|(1<<(ECLParserDASH-15))|(1<<(ECLParserPERIOD-15))|(1<<(ECLParserSLASH-15))|(1<<(ECLParserZERO-15))|(1<<(ECLParserONE-15))|(1<<(ECLParserTWO-15))|(1<<(ECLParserTHREE-15))|(1<<(ECLParserFOUR-15))|(1<<(ECLParserFIVE-15))|(1<<(ECLParserSIX-15))|(1<<(ECLParserSEVEN-15))|(1<<(ECLParserEIGHT-15))|(1<<(ECLParserNINE-15))|(1<<(ECLParserCOLON-15))|(1<<(ECLParserSEMICOLON-15))|(1<<(ECLParserLESS_THAN-15))|(1<<(ECLParserEQUALS-15))|(1<<(ECLParserGREATER_THAN-15))|(1<<(ECLParserQUESTION-15))|(1<<(ECLParserAT-15))|(1<<(ECLParserCAP_A-15))|(1<<(ECLParserCAP_B-15))|(1<<(ECLParserCAP_C-15))|(1<<(ECLParserCAP_D-15))|(1<<(ECLParserCAP_E-15))|(1<<(ECLParserCAP_F-15))|(1<<(ECLParserCAP_G-15))|(1<<(ECLParserCAP_H-15))|(1<<(ECLParserCAP_I-15))|(1<<(ECLParserCAP_J-15)))) != 0) || (((_la-47)&-(0x1f+1)) == 0 && ((1<<uint((_la-47)))&((1<<(ECLParserCAP_K-47))|(1<<(ECLParserCAP_L-47))|(1<<(ECLParserCAP_M-47))|(1<<(ECLParserCAP_N-47))|(1<<(ECLParserCAP_O-47))|(1<<(ECLParserCAP_P-47))|(1<<(ECLParserCAP_Q-47))|(1<<(ECLParserCAP_R-47))|(1<<(ECLParserCAP_S-47))|(1<<(ECLParserCAP_T-47))|(1<<(ECLParserCAP_U-47))|(1<<(ECLParserCAP_V-47))|(1<<(ECLParserCAP_W-47))|(1<<(ECLParserCAP_X-47))|(1<<(ECLParserCAP_Y-47))|(1<<(ECLParserCAP_Z-47))|(1<<(ECLParserLEFT_BRACE-47))|(1<<(ECLParserBACKSLASH-47))|(1<<(ECLParserRIGHT_BRACE-47))|(1<<(ECLParserCARAT-47))|(1<<(ECLParserUNDERSCORE-47))|(1<<(ECLParserACCENT-47))|(1<<(ECLParserA-47))|(1<<(ECLParserB-47))|(1<<(ECLParserC-47))|(1<<(ECLParserD-47))|(1<<(ECLParserE-47))|(1<<(ECLParserF-47))|(1<<(ECLParserG-47))|(1<<(ECLParserH-47))|(1<<(ECLParserI-47))|(1<<(ECLParserJ-47)))) != 0) || (((_la-79)&-(0x1f+1)) == 0 && ((1<<uint((_la-79)))&((1<<(ECLParserK-79))|(1<<(ECLParserL-79))|(1<<(ECLParserM-79))|(1<<(ECLParserN-79))|(1<<(ECLParserO-79))|(1<<(ECLParserP-79))|(1<<(ECLParserQ-79))|(1<<(ECLParserR-79))|(1<<(ECLParserS-79))|(1<<(ECLParserT-79))|(1<<(ECLParserU-79))|(1<<(ECLParserV-79))|(1<<(ECLParserW-79))|(1<<(ECLParserX-79))|(1<<(ECLParserY-79))|(1<<(ECLParserZ-79))|(1<<(ECLParserLEFT_CURLY_BRACE-79))|(1<<(ECLParserPIPE-79))|(1<<(ECLParserRIGHT_CURLY_BRACE-79))|(1<<(ECLParserTILDE-79)))) != 0)) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case ECLParserU_00C2, ECLParserU_00C3, ECLParserU_00C4, ECLParserU_00C5, ECLParserU_00C6, ECLParserU_00C7, ECLParserU_00C8, ECLParserU_00C9, ECLParserU_00CA, ECLParserU_00CB, ECLParserU_00CC, ECLParserU_00CD, ECLParserU_00CE, ECLParserU_00CF, ECLParserU_00D0, ECLParserU_00D1, ECLParserU_00D2, ECLParserU_00D3, ECLParserU_00D4, ECLParserU_00D5, ECLParserU_00D6, ECLParserU_00D7, ECLParserU_00D8, ECLParserU_00D9, ECLParserU_00DA, ECLParserU_00DB, ECLParserU_00DC, ECLParserU_00DD, ECLParserU_00DE, ECLParserU_00DF:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(637)
			p.Utf8_2()
		}

	case ECLParserU_00E0, ECLParserU_00E1, ECLParserU_00E2, ECLParserU_00E3, ECLParserU_00E4, ECLParserU_00E5, ECLParserU_00E6, ECLParserU_00E7, ECLParserU_00E8, ECLParserU_00E9, ECLParserU_00EA, ECLParserU_00EB, ECLParserU_00EC, ECLParserU_00ED, ECLParserU_00EE, ECLParserU_00EF:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(638)
			p.Utf8_3()
		}

	case ECLParserU_00F0, ECLParserU_00F1, ECLParserU_00F2, ECLParserU_00F3, ECLParserU_00F4:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(639)
			p.Utf8_4()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IStarwithnonfslashContext is an interface to support dynamic dispatch.
type IStarwithnonfslashContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStarwithnonfslashContext differentiates from other interfaces.
	IsStarwithnonfslashContext()
}

type StarwithnonfslashContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStarwithnonfslashContext() *StarwithnonfslashContext {
	var p = new(StarwithnonfslashContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ECLParserRULE_starwithnonfslash
	return p
}

func (*StarwithnonfslashContext) IsStarwithnonfslashContext() {}

func NewStarwithnonfslashContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StarwithnonfslashContext {
	var p = new(StarwithnonfslashContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ECLParserRULE_starwithnonfslash

	return p
}

func (s *StarwithnonfslashContext) GetParser() antlr.Parser { return s.parser }

func (s *StarwithnonfslashContext) ASTERISK() antlr.TerminalNode {
	return s.GetToken(ECLParserASTERISK, 0)
}

func (s *StarwithnonfslashContext) Nonfslash() INonfslashContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INonfslashContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INonfslashContext)
}

func (s *StarwithnonfslashContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StarwithnonfslashContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StarwithnonfslashContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ECLListener); ok {
		listenerT.EnterStarwithnonfslash(s)
	}
}

func (s *StarwithnonfslashContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ECLListener); ok {
		listenerT.ExitStarwithnonfslash(s)
	}
}

func (s *StarwithnonfslashContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ECLVisitor:
		return t.VisitStarwithnonfslash(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ECLParser) Starwithnonfslash() (localctx IStarwithnonfslashContext) {
	localctx = NewStarwithnonfslashContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, ECLParserRULE_starwithnonfslash)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(642)
		p.Match(ECLParserASTERISK)
	}
	{
		p.SetState(643)
		p.Nonfslash()
	}

	return localctx
}

// INonfslashContext is an interface to support dynamic dispatch.
type INonfslashContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNonfslashContext differentiates from other interfaces.
	IsNonfslashContext()
}

type NonfslashContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNonfslashContext() *NonfslashContext {
	var p = new(NonfslashContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ECLParserRULE_nonfslash
	return p
}

func (*NonfslashContext) IsNonfslashContext() {}

func NewNonfslashContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NonfslashContext {
	var p = new(NonfslashContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ECLParserRULE_nonfslash

	return p
}

func (s *NonfslashContext) GetParser() antlr.Parser { return s.parser }

func (s *NonfslashContext) Sp() ISpContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISpContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISpContext)
}

func (s *NonfslashContext) Htab() IHtabContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHtabContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHtabContext)
}

func (s *NonfslashContext) Cr() ICrContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICrContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICrContext)
}

func (s *NonfslashContext) Lf() ILfContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILfContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILfContext)
}

func (s *NonfslashContext) EXCLAMATION() antlr.TerminalNode {
	return s.GetToken(ECLParserEXCLAMATION, 0)
}

func (s *NonfslashContext) QUOTE() antlr.TerminalNode {
	return s.GetToken(ECLParserQUOTE, 0)
}

func (s *NonfslashContext) POUND() antlr.TerminalNode {
	return s.GetToken(ECLParserPOUND, 0)
}

func (s *NonfslashContext) DOLLAR() antlr.TerminalNode {
	return s.GetToken(ECLParserDOLLAR, 0)
}

func (s *NonfslashContext) PERCENT() antlr.TerminalNode {
	return s.GetToken(ECLParserPERCENT, 0)
}

func (s *NonfslashContext) AMPERSAND() antlr.TerminalNode {
	return s.GetToken(ECLParserAMPERSAND, 0)
}

func (s *NonfslashContext) APOSTROPHE() antlr.TerminalNode {
	return s.GetToken(ECLParserAPOSTROPHE, 0)
}

func (s *NonfslashContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(ECLParserLEFT_PAREN, 0)
}

func (s *NonfslashContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(ECLParserRIGHT_PAREN, 0)
}

func (s *NonfslashContext) ASTERISK() antlr.TerminalNode {
	return s.GetToken(ECLParserASTERISK, 0)
}

func (s *NonfslashContext) PLUS() antlr.TerminalNode {
	return s.GetToken(ECLParserPLUS, 0)
}

func (s *NonfslashContext) COMMA() antlr.TerminalNode {
	return s.GetToken(ECLParserCOMMA, 0)
}

func (s *NonfslashContext) DASH() antlr.TerminalNode {
	return s.GetToken(ECLParserDASH, 0)
}

func (s *NonfslashContext) PERIOD() antlr.TerminalNode {
	return s.GetToken(ECLParserPERIOD, 0)
}

func (s *NonfslashContext) ZERO() antlr.TerminalNode {
	return s.GetToken(ECLParserZERO, 0)
}

func (s *NonfslashContext) ONE() antlr.TerminalNode {
	return s.GetToken(ECLParserONE, 0)
}

func (s *NonfslashContext) TWO() antlr.TerminalNode {
	return s.GetToken(ECLParserTWO, 0)
}

func (s *NonfslashContext) THREE() antlr.TerminalNode {
	return s.GetToken(ECLParserTHREE, 0)
}

func (s *NonfslashContext) FOUR() antlr.TerminalNode {
	return s.GetToken(ECLParserFOUR, 0)
}

func (s *NonfslashContext) FIVE() antlr.TerminalNode {
	return s.GetToken(ECLParserFIVE, 0)
}

func (s *NonfslashContext) SIX() antlr.TerminalNode {
	return s.GetToken(ECLParserSIX, 0)
}

func (s *NonfslashContext) SEVEN() antlr.TerminalNode {
	return s.GetToken(ECLParserSEVEN, 0)
}

func (s *NonfslashContext) EIGHT() antlr.TerminalNode {
	return s.GetToken(ECLParserEIGHT, 0)
}

func (s *NonfslashContext) NINE() antlr.TerminalNode {
	return s.GetToken(ECLParserNINE, 0)
}

func (s *NonfslashContext) COLON() antlr.TerminalNode {
	return s.GetToken(ECLParserCOLON, 0)
}

func (s *NonfslashContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(ECLParserSEMICOLON, 0)
}

func (s *NonfslashContext) LESS_THAN() antlr.TerminalNode {
	return s.GetToken(ECLParserLESS_THAN, 0)
}

func (s *NonfslashContext) EQUALS() antlr.TerminalNode {
	return s.GetToken(ECLParserEQUALS, 0)
}

func (s *NonfslashContext) GREATER_THAN() antlr.TerminalNode {
	return s.GetToken(ECLParserGREATER_THAN, 0)
}

func (s *NonfslashContext) QUESTION() antlr.TerminalNode {
	return s.GetToken(ECLParserQUESTION, 0)
}

func (s *NonfslashContext) AT() antlr.TerminalNode {
	return s.GetToken(ECLParserAT, 0)
}

func (s *NonfslashContext) CAP_A() antlr.TerminalNode {
	return s.GetToken(ECLParserCAP_A, 0)
}

func (s *NonfslashContext) CAP_B() antlr.TerminalNode {
	return s.GetToken(ECLParserCAP_B, 0)
}

func (s *NonfslashContext) CAP_C() antlr.TerminalNode {
	return s.GetToken(ECLParserCAP_C, 0)
}

func (s *NonfslashContext) CAP_D() antlr.TerminalNode {
	return s.GetToken(ECLParserCAP_D, 0)
}

func (s *NonfslashContext) CAP_E() antlr.TerminalNode {
	return s.GetToken(ECLParserCAP_E, 0)
}

func (s *NonfslashContext) CAP_F() antlr.TerminalNode {
	return s.GetToken(ECLParserCAP_F, 0)
}

func (s *NonfslashContext) CAP_G() antlr.TerminalNode {
	return s.GetToken(ECLParserCAP_G, 0)
}

func (s *NonfslashContext) CAP_H() antlr.TerminalNode {
	return s.GetToken(ECLParserCAP_H, 0)
}

func (s *NonfslashContext) CAP_I() antlr.TerminalNode {
	return s.GetToken(ECLParserCAP_I, 0)
}

func (s *NonfslashContext) CAP_J() antlr.TerminalNode {
	return s.GetToken(ECLParserCAP_J, 0)
}

func (s *NonfslashContext) CAP_K() antlr.TerminalNode {
	return s.GetToken(ECLParserCAP_K, 0)
}

func (s *NonfslashContext) CAP_L() antlr.TerminalNode {
	return s.GetToken(ECLParserCAP_L, 0)
}

func (s *NonfslashContext) CAP_M() antlr.TerminalNode {
	return s.GetToken(ECLParserCAP_M, 0)
}

func (s *NonfslashContext) CAP_N() antlr.TerminalNode {
	return s.GetToken(ECLParserCAP_N, 0)
}

func (s *NonfslashContext) CAP_O() antlr.TerminalNode {
	return s.GetToken(ECLParserCAP_O, 0)
}

func (s *NonfslashContext) CAP_P() antlr.TerminalNode {
	return s.GetToken(ECLParserCAP_P, 0)
}

func (s *NonfslashContext) CAP_Q() antlr.TerminalNode {
	return s.GetToken(ECLParserCAP_Q, 0)
}

func (s *NonfslashContext) CAP_R() antlr.TerminalNode {
	return s.GetToken(ECLParserCAP_R, 0)
}

func (s *NonfslashContext) CAP_S() antlr.TerminalNode {
	return s.GetToken(ECLParserCAP_S, 0)
}

func (s *NonfslashContext) CAP_T() antlr.TerminalNode {
	return s.GetToken(ECLParserCAP_T, 0)
}

func (s *NonfslashContext) CAP_U() antlr.TerminalNode {
	return s.GetToken(ECLParserCAP_U, 0)
}

func (s *NonfslashContext) CAP_V() antlr.TerminalNode {
	return s.GetToken(ECLParserCAP_V, 0)
}

func (s *NonfslashContext) CAP_W() antlr.TerminalNode {
	return s.GetToken(ECLParserCAP_W, 0)
}

func (s *NonfslashContext) CAP_X() antlr.TerminalNode {
	return s.GetToken(ECLParserCAP_X, 0)
}

func (s *NonfslashContext) CAP_Y() antlr.TerminalNode {
	return s.GetToken(ECLParserCAP_Y, 0)
}

func (s *NonfslashContext) CAP_Z() antlr.TerminalNode {
	return s.GetToken(ECLParserCAP_Z, 0)
}

func (s *NonfslashContext) LEFT_BRACE() antlr.TerminalNode {
	return s.GetToken(ECLParserLEFT_BRACE, 0)
}

func (s *NonfslashContext) BACKSLASH() antlr.TerminalNode {
	return s.GetToken(ECLParserBACKSLASH, 0)
}

func (s *NonfslashContext) RIGHT_BRACE() antlr.TerminalNode {
	return s.GetToken(ECLParserRIGHT_BRACE, 0)
}

func (s *NonfslashContext) CARAT() antlr.TerminalNode {
	return s.GetToken(ECLParserCARAT, 0)
}

func (s *NonfslashContext) UNDERSCORE() antlr.TerminalNode {
	return s.GetToken(ECLParserUNDERSCORE, 0)
}

func (s *NonfslashContext) ACCENT() antlr.TerminalNode {
	return s.GetToken(ECLParserACCENT, 0)
}

func (s *NonfslashContext) A() antlr.TerminalNode {
	return s.GetToken(ECLParserA, 0)
}

func (s *NonfslashContext) B() antlr.TerminalNode {
	return s.GetToken(ECLParserB, 0)
}

func (s *NonfslashContext) C() antlr.TerminalNode {
	return s.GetToken(ECLParserC, 0)
}

func (s *NonfslashContext) D() antlr.TerminalNode {
	return s.GetToken(ECLParserD, 0)
}

func (s *NonfslashContext) E() antlr.TerminalNode {
	return s.GetToken(ECLParserE, 0)
}

func (s *NonfslashContext) F() antlr.TerminalNode {
	return s.GetToken(ECLParserF, 0)
}

func (s *NonfslashContext) G() antlr.TerminalNode {
	return s.GetToken(ECLParserG, 0)
}

func (s *NonfslashContext) H() antlr.TerminalNode {
	return s.GetToken(ECLParserH, 0)
}

func (s *NonfslashContext) I() antlr.TerminalNode {
	return s.GetToken(ECLParserI, 0)
}

func (s *NonfslashContext) J() antlr.TerminalNode {
	return s.GetToken(ECLParserJ, 0)
}

func (s *NonfslashContext) K() antlr.TerminalNode {
	return s.GetToken(ECLParserK, 0)
}

func (s *NonfslashContext) L() antlr.TerminalNode {
	return s.GetToken(ECLParserL, 0)
}

func (s *NonfslashContext) M() antlr.TerminalNode {
	return s.GetToken(ECLParserM, 0)
}

func (s *NonfslashContext) N() antlr.TerminalNode {
	return s.GetToken(ECLParserN, 0)
}

func (s *NonfslashContext) O() antlr.TerminalNode {
	return s.GetToken(ECLParserO, 0)
}

func (s *NonfslashContext) P() antlr.TerminalNode {
	return s.GetToken(ECLParserP, 0)
}

func (s *NonfslashContext) Q() antlr.TerminalNode {
	return s.GetToken(ECLParserQ, 0)
}

func (s *NonfslashContext) R() antlr.TerminalNode {
	return s.GetToken(ECLParserR, 0)
}

func (s *NonfslashContext) S() antlr.TerminalNode {
	return s.GetToken(ECLParserS, 0)
}

func (s *NonfslashContext) T() antlr.TerminalNode {
	return s.GetToken(ECLParserT, 0)
}

func (s *NonfslashContext) U() antlr.TerminalNode {
	return s.GetToken(ECLParserU, 0)
}

func (s *NonfslashContext) V() antlr.TerminalNode {
	return s.GetToken(ECLParserV, 0)
}

func (s *NonfslashContext) W() antlr.TerminalNode {
	return s.GetToken(ECLParserW, 0)
}

func (s *NonfslashContext) X() antlr.TerminalNode {
	return s.GetToken(ECLParserX, 0)
}

func (s *NonfslashContext) Y() antlr.TerminalNode {
	return s.GetToken(ECLParserY, 0)
}

func (s *NonfslashContext) Z() antlr.TerminalNode {
	return s.GetToken(ECLParserZ, 0)
}

func (s *NonfslashContext) LEFT_CURLY_BRACE() antlr.TerminalNode {
	return s.GetToken(ECLParserLEFT_CURLY_BRACE, 0)
}

func (s *NonfslashContext) PIPE() antlr.TerminalNode {
	return s.GetToken(ECLParserPIPE, 0)
}

func (s *NonfslashContext) RIGHT_CURLY_BRACE() antlr.TerminalNode {
	return s.GetToken(ECLParserRIGHT_CURLY_BRACE, 0)
}

func (s *NonfslashContext) TILDE() antlr.TerminalNode {
	return s.GetToken(ECLParserTILDE, 0)
}

func (s *NonfslashContext) Utf8_2() IUtf8_2Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUtf8_2Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUtf8_2Context)
}

func (s *NonfslashContext) Utf8_3() IUtf8_3Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUtf8_3Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUtf8_3Context)
}

func (s *NonfslashContext) Utf8_4() IUtf8_4Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUtf8_4Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUtf8_4Context)
}

func (s *NonfslashContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NonfslashContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NonfslashContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ECLListener); ok {
		listenerT.EnterNonfslash(s)
	}
}

func (s *NonfslashContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ECLListener); ok {
		listenerT.ExitNonfslash(s)
	}
}

func (s *NonfslashContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ECLVisitor:
		return t.VisitNonfslash(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ECLParser) Nonfslash() (localctx INonfslashContext) {
	localctx = NewNonfslashContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, ECLParserRULE_nonfslash)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(654)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ECLParserSPACE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(645)
			p.Sp()
		}

	case ECLParserTAB:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(646)
			p.Htab()
		}

	case ECLParserCR:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(647)
			p.Cr()
		}

	case ECLParserLF:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(648)
			p.Lf()
		}

	case ECLParserEXCLAMATION, ECLParserQUOTE, ECLParserPOUND, ECLParserDOLLAR, ECLParserPERCENT, ECLParserAMPERSAND, ECLParserAPOSTROPHE, ECLParserLEFT_PAREN, ECLParserRIGHT_PAREN, ECLParserASTERISK, ECLParserPLUS, ECLParserCOMMA, ECLParserDASH, ECLParserPERIOD:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(649)
			_la = p.GetTokenStream().LA(1)

			if !(((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<ECLParserEXCLAMATION)|(1<<ECLParserQUOTE)|(1<<ECLParserPOUND)|(1<<ECLParserDOLLAR)|(1<<ECLParserPERCENT)|(1<<ECLParserAMPERSAND)|(1<<ECLParserAPOSTROPHE)|(1<<ECLParserLEFT_PAREN)|(1<<ECLParserRIGHT_PAREN)|(1<<ECLParserASTERISK)|(1<<ECLParserPLUS)|(1<<ECLParserCOMMA)|(1<<ECLParserDASH)|(1<<ECLParserPERIOD))) != 0) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case ECLParserZERO, ECLParserONE, ECLParserTWO, ECLParserTHREE, ECLParserFOUR, ECLParserFIVE, ECLParserSIX, ECLParserSEVEN, ECLParserEIGHT, ECLParserNINE, ECLParserCOLON, ECLParserSEMICOLON, ECLParserLESS_THAN, ECLParserEQUALS, ECLParserGREATER_THAN, ECLParserQUESTION, ECLParserAT, ECLParserCAP_A, ECLParserCAP_B, ECLParserCAP_C, ECLParserCAP_D, ECLParserCAP_E, ECLParserCAP_F, ECLParserCAP_G, ECLParserCAP_H, ECLParserCAP_I, ECLParserCAP_J, ECLParserCAP_K, ECLParserCAP_L, ECLParserCAP_M, ECLParserCAP_N, ECLParserCAP_O, ECLParserCAP_P, ECLParserCAP_Q, ECLParserCAP_R, ECLParserCAP_S, ECLParserCAP_T, ECLParserCAP_U, ECLParserCAP_V, ECLParserCAP_W, ECLParserCAP_X, ECLParserCAP_Y, ECLParserCAP_Z, ECLParserLEFT_BRACE, ECLParserBACKSLASH, ECLParserRIGHT_BRACE, ECLParserCARAT, ECLParserUNDERSCORE, ECLParserACCENT, ECLParserA, ECLParserB, ECLParserC, ECLParserD, ECLParserE, ECLParserF, ECLParserG, ECLParserH, ECLParserI, ECLParserJ, ECLParserK, ECLParserL, ECLParserM, ECLParserN, ECLParserO, ECLParserP, ECLParserQ, ECLParserR, ECLParserS, ECLParserT, ECLParserU, ECLParserV, ECLParserW, ECLParserX, ECLParserY, ECLParserZ, ECLParserLEFT_CURLY_BRACE, ECLParserPIPE, ECLParserRIGHT_CURLY_BRACE, ECLParserTILDE:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(650)
			_la = p.GetTokenStream().LA(1)

			if !((((_la-20)&-(0x1f+1)) == 0 && ((1<<uint((_la-20)))&((1<<(ECLParserZERO-20))|(1<<(ECLParserONE-20))|(1<<(ECLParserTWO-20))|(1<<(ECLParserTHREE-20))|(1<<(ECLParserFOUR-20))|(1<<(ECLParserFIVE-20))|(1<<(ECLParserSIX-20))|(1<<(ECLParserSEVEN-20))|(1<<(ECLParserEIGHT-20))|(1<<(ECLParserNINE-20))|(1<<(ECLParserCOLON-20))|(1<<(ECLParserSEMICOLON-20))|(1<<(ECLParserLESS_THAN-20))|(1<<(ECLParserEQUALS-20))|(1<<(ECLParserGREATER_THAN-20))|(1<<(ECLParserQUESTION-20))|(1<<(ECLParserAT-20))|(1<<(ECLParserCAP_A-20))|(1<<(ECLParserCAP_B-20))|(1<<(ECLParserCAP_C-20))|(1<<(ECLParserCAP_D-20))|(1<<(ECLParserCAP_E-20))|(1<<(ECLParserCAP_F-20))|(1<<(ECLParserCAP_G-20))|(1<<(ECLParserCAP_H-20))|(1<<(ECLParserCAP_I-20))|(1<<(ECLParserCAP_J-20))|(1<<(ECLParserCAP_K-20))|(1<<(ECLParserCAP_L-20))|(1<<(ECLParserCAP_M-20))|(1<<(ECLParserCAP_N-20))|(1<<(ECLParserCAP_O-20)))) != 0) || (((_la-52)&-(0x1f+1)) == 0 && ((1<<uint((_la-52)))&((1<<(ECLParserCAP_P-52))|(1<<(ECLParserCAP_Q-52))|(1<<(ECLParserCAP_R-52))|(1<<(ECLParserCAP_S-52))|(1<<(ECLParserCAP_T-52))|(1<<(ECLParserCAP_U-52))|(1<<(ECLParserCAP_V-52))|(1<<(ECLParserCAP_W-52))|(1<<(ECLParserCAP_X-52))|(1<<(ECLParserCAP_Y-52))|(1<<(ECLParserCAP_Z-52))|(1<<(ECLParserLEFT_BRACE-52))|(1<<(ECLParserBACKSLASH-52))|(1<<(ECLParserRIGHT_BRACE-52))|(1<<(ECLParserCARAT-52))|(1<<(ECLParserUNDERSCORE-52))|(1<<(ECLParserACCENT-52))|(1<<(ECLParserA-52))|(1<<(ECLParserB-52))|(1<<(ECLParserC-52))|(1<<(ECLParserD-52))|(1<<(ECLParserE-52))|(1<<(ECLParserF-52))|(1<<(ECLParserG-52))|(1<<(ECLParserH-52))|(1<<(ECLParserI-52))|(1<<(ECLParserJ-52))|(1<<(ECLParserK-52))|(1<<(ECLParserL-52))|(1<<(ECLParserM-52))|(1<<(ECLParserN-52))|(1<<(ECLParserO-52)))) != 0) || (((_la-84)&-(0x1f+1)) == 0 && ((1<<uint((_la-84)))&((1<<(ECLParserP-84))|(1<<(ECLParserQ-84))|(1<<(ECLParserR-84))|(1<<(ECLParserS-84))|(1<<(ECLParserT-84))|(1<<(ECLParserU-84))|(1<<(ECLParserV-84))|(1<<(ECLParserW-84))|(1<<(ECLParserX-84))|(1<<(ECLParserY-84))|(1<<(ECLParserZ-84))|(1<<(ECLParserLEFT_CURLY_BRACE-84))|(1<<(ECLParserPIPE-84))|(1<<(ECLParserRIGHT_CURLY_BRACE-84))|(1<<(ECLParserTILDE-84)))) != 0)) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case ECLParserU_00C2, ECLParserU_00C3, ECLParserU_00C4, ECLParserU_00C5, ECLParserU_00C6, ECLParserU_00C7, ECLParserU_00C8, ECLParserU_00C9, ECLParserU_00CA, ECLParserU_00CB, ECLParserU_00CC, ECLParserU_00CD, ECLParserU_00CE, ECLParserU_00CF, ECLParserU_00D0, ECLParserU_00D1, ECLParserU_00D2, ECLParserU_00D3, ECLParserU_00D4, ECLParserU_00D5, ECLParserU_00D6, ECLParserU_00D7, ECLParserU_00D8, ECLParserU_00D9, ECLParserU_00DA, ECLParserU_00DB, ECLParserU_00DC, ECLParserU_00DD, ECLParserU_00DE, ECLParserU_00DF:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(651)
			p.Utf8_2()
		}

	case ECLParserU_00E0, ECLParserU_00E1, ECLParserU_00E2, ECLParserU_00E3, ECLParserU_00E4, ECLParserU_00E5, ECLParserU_00E6, ECLParserU_00E7, ECLParserU_00E8, ECLParserU_00E9, ECLParserU_00EA, ECLParserU_00EB, ECLParserU_00EC, ECLParserU_00ED, ECLParserU_00EE, ECLParserU_00EF:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(652)
			p.Utf8_3()
		}

	case ECLParserU_00F0, ECLParserU_00F1, ECLParserU_00F2, ECLParserU_00F3, ECLParserU_00F4:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(653)
			p.Utf8_4()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ISpContext is an interface to support dynamic dispatch.
type ISpContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSpContext differentiates from other interfaces.
	IsSpContext()
}

type SpContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySpContext() *SpContext {
	var p = new(SpContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ECLParserRULE_sp
	return p
}

func (*SpContext) IsSpContext() {}

func NewSpContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SpContext {
	var p = new(SpContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ECLParserRULE_sp

	return p
}

func (s *SpContext) GetParser() antlr.Parser { return s.parser }

func (s *SpContext) SPACE() antlr.TerminalNode {
	return s.GetToken(ECLParserSPACE, 0)
}

func (s *SpContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SpContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SpContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ECLListener); ok {
		listenerT.EnterSp(s)
	}
}

func (s *SpContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ECLListener); ok {
		listenerT.ExitSp(s)
	}
}

func (s *SpContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ECLVisitor:
		return t.VisitSp(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ECLParser) Sp() (localctx ISpContext) {
	localctx = NewSpContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, ECLParserRULE_sp)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(656)
		p.Match(ECLParserSPACE)
	}

	return localctx
}

// IHtabContext is an interface to support dynamic dispatch.
type IHtabContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHtabContext differentiates from other interfaces.
	IsHtabContext()
}

type HtabContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHtabContext() *HtabContext {
	var p = new(HtabContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ECLParserRULE_htab
	return p
}

func (*HtabContext) IsHtabContext() {}

func NewHtabContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HtabContext {
	var p = new(HtabContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ECLParserRULE_htab

	return p
}

func (s *HtabContext) GetParser() antlr.Parser { return s.parser }

func (s *HtabContext) TAB() antlr.TerminalNode {
	return s.GetToken(ECLParserTAB, 0)
}

func (s *HtabContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HtabContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HtabContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ECLListener); ok {
		listenerT.EnterHtab(s)
	}
}

func (s *HtabContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ECLListener); ok {
		listenerT.ExitHtab(s)
	}
}

func (s *HtabContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ECLVisitor:
		return t.VisitHtab(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ECLParser) Htab() (localctx IHtabContext) {
	localctx = NewHtabContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, ECLParserRULE_htab)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(658)
		p.Match(ECLParserTAB)
	}

	return localctx
}

// ICrContext is an interface to support dynamic dispatch.
type ICrContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCrContext differentiates from other interfaces.
	IsCrContext()
}

type CrContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCrContext() *CrContext {
	var p = new(CrContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ECLParserRULE_cr
	return p
}

func (*CrContext) IsCrContext() {}

func NewCrContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CrContext {
	var p = new(CrContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ECLParserRULE_cr

	return p
}

func (s *CrContext) GetParser() antlr.Parser { return s.parser }

func (s *CrContext) CR() antlr.TerminalNode {
	return s.GetToken(ECLParserCR, 0)
}

func (s *CrContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CrContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CrContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ECLListener); ok {
		listenerT.EnterCr(s)
	}
}

func (s *CrContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ECLListener); ok {
		listenerT.ExitCr(s)
	}
}

func (s *CrContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ECLVisitor:
		return t.VisitCr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ECLParser) Cr() (localctx ICrContext) {
	localctx = NewCrContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, ECLParserRULE_cr)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(660)
		p.Match(ECLParserCR)
	}

	return localctx
}

// ILfContext is an interface to support dynamic dispatch.
type ILfContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLfContext differentiates from other interfaces.
	IsLfContext()
}

type LfContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLfContext() *LfContext {
	var p = new(LfContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ECLParserRULE_lf
	return p
}

func (*LfContext) IsLfContext() {}

func NewLfContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LfContext {
	var p = new(LfContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ECLParserRULE_lf

	return p
}

func (s *LfContext) GetParser() antlr.Parser { return s.parser }

func (s *LfContext) LF() antlr.TerminalNode {
	return s.GetToken(ECLParserLF, 0)
}

func (s *LfContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LfContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LfContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ECLListener); ok {
		listenerT.EnterLf(s)
	}
}

func (s *LfContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ECLListener); ok {
		listenerT.ExitLf(s)
	}
}

func (s *LfContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ECLVisitor:
		return t.VisitLf(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ECLParser) Lf() (localctx ILfContext) {
	localctx = NewLfContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, ECLParserRULE_lf)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(662)
		p.Match(ECLParserLF)
	}

	return localctx
}

// IQmContext is an interface to support dynamic dispatch.
type IQmContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsQmContext differentiates from other interfaces.
	IsQmContext()
}

type QmContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQmContext() *QmContext {
	var p = new(QmContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ECLParserRULE_qm
	return p
}

func (*QmContext) IsQmContext() {}

func NewQmContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QmContext {
	var p = new(QmContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ECLParserRULE_qm

	return p
}

func (s *QmContext) GetParser() antlr.Parser { return s.parser }

func (s *QmContext) QUOTE() antlr.TerminalNode {
	return s.GetToken(ECLParserQUOTE, 0)
}

func (s *QmContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QmContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QmContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ECLListener); ok {
		listenerT.EnterQm(s)
	}
}

func (s *QmContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ECLListener); ok {
		listenerT.ExitQm(s)
	}
}

func (s *QmContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ECLVisitor:
		return t.VisitQm(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ECLParser) Qm() (localctx IQmContext) {
	localctx = NewQmContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, ECLParserRULE_qm)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(664)
		p.Match(ECLParserQUOTE)
	}

	return localctx
}

// IBsContext is an interface to support dynamic dispatch.
type IBsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBsContext differentiates from other interfaces.
	IsBsContext()
}

type BsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBsContext() *BsContext {
	var p = new(BsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ECLParserRULE_bs
	return p
}

func (*BsContext) IsBsContext() {}

func NewBsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BsContext {
	var p = new(BsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ECLParserRULE_bs

	return p
}

func (s *BsContext) GetParser() antlr.Parser { return s.parser }

func (s *BsContext) BACKSLASH() antlr.TerminalNode {
	return s.GetToken(ECLParserBACKSLASH, 0)
}

func (s *BsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ECLListener); ok {
		listenerT.EnterBs(s)
	}
}

func (s *BsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ECLListener); ok {
		listenerT.ExitBs(s)
	}
}

func (s *BsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ECLVisitor:
		return t.VisitBs(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ECLParser) Bs() (localctx IBsContext) {
	localctx = NewBsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 126, ECLParserRULE_bs)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(666)
		p.Match(ECLParserBACKSLASH)
	}

	return localctx
}

// IDigitContext is an interface to support dynamic dispatch.
type IDigitContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDigitContext differentiates from other interfaces.
	IsDigitContext()
}

type DigitContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDigitContext() *DigitContext {
	var p = new(DigitContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ECLParserRULE_digit
	return p
}

func (*DigitContext) IsDigitContext() {}

func NewDigitContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DigitContext {
	var p = new(DigitContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ECLParserRULE_digit

	return p
}

func (s *DigitContext) GetParser() antlr.Parser { return s.parser }

func (s *DigitContext) ZERO() antlr.TerminalNode {
	return s.GetToken(ECLParserZERO, 0)
}

func (s *DigitContext) ONE() antlr.TerminalNode {
	return s.GetToken(ECLParserONE, 0)
}

func (s *DigitContext) TWO() antlr.TerminalNode {
	return s.GetToken(ECLParserTWO, 0)
}

func (s *DigitContext) THREE() antlr.TerminalNode {
	return s.GetToken(ECLParserTHREE, 0)
}

func (s *DigitContext) FOUR() antlr.TerminalNode {
	return s.GetToken(ECLParserFOUR, 0)
}

func (s *DigitContext) FIVE() antlr.TerminalNode {
	return s.GetToken(ECLParserFIVE, 0)
}

func (s *DigitContext) SIX() antlr.TerminalNode {
	return s.GetToken(ECLParserSIX, 0)
}

func (s *DigitContext) SEVEN() antlr.TerminalNode {
	return s.GetToken(ECLParserSEVEN, 0)
}

func (s *DigitContext) EIGHT() antlr.TerminalNode {
	return s.GetToken(ECLParserEIGHT, 0)
}

func (s *DigitContext) NINE() antlr.TerminalNode {
	return s.GetToken(ECLParserNINE, 0)
}

func (s *DigitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DigitContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DigitContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ECLListener); ok {
		listenerT.EnterDigit(s)
	}
}

func (s *DigitContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ECLListener); ok {
		listenerT.ExitDigit(s)
	}
}

func (s *DigitContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ECLVisitor:
		return t.VisitDigit(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ECLParser) Digit() (localctx IDigitContext) {
	localctx = NewDigitContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, ECLParserRULE_digit)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(668)
		_la = p.GetTokenStream().LA(1)

		if !(((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<ECLParserZERO)|(1<<ECLParserONE)|(1<<ECLParserTWO)|(1<<ECLParserTHREE)|(1<<ECLParserFOUR)|(1<<ECLParserFIVE)|(1<<ECLParserSIX)|(1<<ECLParserSEVEN)|(1<<ECLParserEIGHT)|(1<<ECLParserNINE))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IZeroContext is an interface to support dynamic dispatch.
type IZeroContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsZeroContext differentiates from other interfaces.
	IsZeroContext()
}

type ZeroContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyZeroContext() *ZeroContext {
	var p = new(ZeroContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ECLParserRULE_zero
	return p
}

func (*ZeroContext) IsZeroContext() {}

func NewZeroContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ZeroContext {
	var p = new(ZeroContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ECLParserRULE_zero

	return p
}

func (s *ZeroContext) GetParser() antlr.Parser { return s.parser }

func (s *ZeroContext) ZERO() antlr.TerminalNode {
	return s.GetToken(ECLParserZERO, 0)
}

func (s *ZeroContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ZeroContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ZeroContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ECLListener); ok {
		listenerT.EnterZero(s)
	}
}

func (s *ZeroContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ECLListener); ok {
		listenerT.ExitZero(s)
	}
}

func (s *ZeroContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ECLVisitor:
		return t.VisitZero(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ECLParser) Zero() (localctx IZeroContext) {
	localctx = NewZeroContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 130, ECLParserRULE_zero)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(670)
		p.Match(ECLParserZERO)
	}

	return localctx
}

// IDigitnonzeroContext is an interface to support dynamic dispatch.
type IDigitnonzeroContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDigitnonzeroContext differentiates from other interfaces.
	IsDigitnonzeroContext()
}

type DigitnonzeroContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDigitnonzeroContext() *DigitnonzeroContext {
	var p = new(DigitnonzeroContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ECLParserRULE_digitnonzero
	return p
}

func (*DigitnonzeroContext) IsDigitnonzeroContext() {}

func NewDigitnonzeroContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DigitnonzeroContext {
	var p = new(DigitnonzeroContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ECLParserRULE_digitnonzero

	return p
}

func (s *DigitnonzeroContext) GetParser() antlr.Parser { return s.parser }

func (s *DigitnonzeroContext) ONE() antlr.TerminalNode {
	return s.GetToken(ECLParserONE, 0)
}

func (s *DigitnonzeroContext) TWO() antlr.TerminalNode {
	return s.GetToken(ECLParserTWO, 0)
}

func (s *DigitnonzeroContext) THREE() antlr.TerminalNode {
	return s.GetToken(ECLParserTHREE, 0)
}

func (s *DigitnonzeroContext) FOUR() antlr.TerminalNode {
	return s.GetToken(ECLParserFOUR, 0)
}

func (s *DigitnonzeroContext) FIVE() antlr.TerminalNode {
	return s.GetToken(ECLParserFIVE, 0)
}

func (s *DigitnonzeroContext) SIX() antlr.TerminalNode {
	return s.GetToken(ECLParserSIX, 0)
}

func (s *DigitnonzeroContext) SEVEN() antlr.TerminalNode {
	return s.GetToken(ECLParserSEVEN, 0)
}

func (s *DigitnonzeroContext) EIGHT() antlr.TerminalNode {
	return s.GetToken(ECLParserEIGHT, 0)
}

func (s *DigitnonzeroContext) NINE() antlr.TerminalNode {
	return s.GetToken(ECLParserNINE, 0)
}

func (s *DigitnonzeroContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DigitnonzeroContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DigitnonzeroContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ECLListener); ok {
		listenerT.EnterDigitnonzero(s)
	}
}

func (s *DigitnonzeroContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ECLListener); ok {
		listenerT.ExitDigitnonzero(s)
	}
}

func (s *DigitnonzeroContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ECLVisitor:
		return t.VisitDigitnonzero(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ECLParser) Digitnonzero() (localctx IDigitnonzeroContext) {
	localctx = NewDigitnonzeroContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 132, ECLParserRULE_digitnonzero)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(672)
		_la = p.GetTokenStream().LA(1)

		if !(((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<ECLParserONE)|(1<<ECLParserTWO)|(1<<ECLParserTHREE)|(1<<ECLParserFOUR)|(1<<ECLParserFIVE)|(1<<ECLParserSIX)|(1<<ECLParserSEVEN)|(1<<ECLParserEIGHT)|(1<<ECLParserNINE))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// INonwsnonpipeContext is an interface to support dynamic dispatch.
type INonwsnonpipeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNonwsnonpipeContext differentiates from other interfaces.
	IsNonwsnonpipeContext()
}

type NonwsnonpipeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNonwsnonpipeContext() *NonwsnonpipeContext {
	var p = new(NonwsnonpipeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ECLParserRULE_nonwsnonpipe
	return p
}

func (*NonwsnonpipeContext) IsNonwsnonpipeContext() {}

func NewNonwsnonpipeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NonwsnonpipeContext {
	var p = new(NonwsnonpipeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ECLParserRULE_nonwsnonpipe

	return p
}

func (s *NonwsnonpipeContext) GetParser() antlr.Parser { return s.parser }

func (s *NonwsnonpipeContext) EXCLAMATION() antlr.TerminalNode {
	return s.GetToken(ECLParserEXCLAMATION, 0)
}

func (s *NonwsnonpipeContext) QUOTE() antlr.TerminalNode {
	return s.GetToken(ECLParserQUOTE, 0)
}

func (s *NonwsnonpipeContext) POUND() antlr.TerminalNode {
	return s.GetToken(ECLParserPOUND, 0)
}

func (s *NonwsnonpipeContext) DOLLAR() antlr.TerminalNode {
	return s.GetToken(ECLParserDOLLAR, 0)
}

func (s *NonwsnonpipeContext) PERCENT() antlr.TerminalNode {
	return s.GetToken(ECLParserPERCENT, 0)
}

func (s *NonwsnonpipeContext) AMPERSAND() antlr.TerminalNode {
	return s.GetToken(ECLParserAMPERSAND, 0)
}

func (s *NonwsnonpipeContext) APOSTROPHE() antlr.TerminalNode {
	return s.GetToken(ECLParserAPOSTROPHE, 0)
}

func (s *NonwsnonpipeContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(ECLParserLEFT_PAREN, 0)
}

func (s *NonwsnonpipeContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(ECLParserRIGHT_PAREN, 0)
}

func (s *NonwsnonpipeContext) ASTERISK() antlr.TerminalNode {
	return s.GetToken(ECLParserASTERISK, 0)
}

func (s *NonwsnonpipeContext) PLUS() antlr.TerminalNode {
	return s.GetToken(ECLParserPLUS, 0)
}

func (s *NonwsnonpipeContext) COMMA() antlr.TerminalNode {
	return s.GetToken(ECLParserCOMMA, 0)
}

func (s *NonwsnonpipeContext) DASH() antlr.TerminalNode {
	return s.GetToken(ECLParserDASH, 0)
}

func (s *NonwsnonpipeContext) PERIOD() antlr.TerminalNode {
	return s.GetToken(ECLParserPERIOD, 0)
}

func (s *NonwsnonpipeContext) SLASH() antlr.TerminalNode {
	return s.GetToken(ECLParserSLASH, 0)
}

func (s *NonwsnonpipeContext) ZERO() antlr.TerminalNode {
	return s.GetToken(ECLParserZERO, 0)
}

func (s *NonwsnonpipeContext) ONE() antlr.TerminalNode {
	return s.GetToken(ECLParserONE, 0)
}

func (s *NonwsnonpipeContext) TWO() antlr.TerminalNode {
	return s.GetToken(ECLParserTWO, 0)
}

func (s *NonwsnonpipeContext) THREE() antlr.TerminalNode {
	return s.GetToken(ECLParserTHREE, 0)
}

func (s *NonwsnonpipeContext) FOUR() antlr.TerminalNode {
	return s.GetToken(ECLParserFOUR, 0)
}

func (s *NonwsnonpipeContext) FIVE() antlr.TerminalNode {
	return s.GetToken(ECLParserFIVE, 0)
}

func (s *NonwsnonpipeContext) SIX() antlr.TerminalNode {
	return s.GetToken(ECLParserSIX, 0)
}

func (s *NonwsnonpipeContext) SEVEN() antlr.TerminalNode {
	return s.GetToken(ECLParserSEVEN, 0)
}

func (s *NonwsnonpipeContext) EIGHT() antlr.TerminalNode {
	return s.GetToken(ECLParserEIGHT, 0)
}

func (s *NonwsnonpipeContext) NINE() antlr.TerminalNode {
	return s.GetToken(ECLParserNINE, 0)
}

func (s *NonwsnonpipeContext) COLON() antlr.TerminalNode {
	return s.GetToken(ECLParserCOLON, 0)
}

func (s *NonwsnonpipeContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(ECLParserSEMICOLON, 0)
}

func (s *NonwsnonpipeContext) LESS_THAN() antlr.TerminalNode {
	return s.GetToken(ECLParserLESS_THAN, 0)
}

func (s *NonwsnonpipeContext) EQUALS() antlr.TerminalNode {
	return s.GetToken(ECLParserEQUALS, 0)
}

func (s *NonwsnonpipeContext) GREATER_THAN() antlr.TerminalNode {
	return s.GetToken(ECLParserGREATER_THAN, 0)
}

func (s *NonwsnonpipeContext) QUESTION() antlr.TerminalNode {
	return s.GetToken(ECLParserQUESTION, 0)
}

func (s *NonwsnonpipeContext) AT() antlr.TerminalNode {
	return s.GetToken(ECLParserAT, 0)
}

func (s *NonwsnonpipeContext) CAP_A() antlr.TerminalNode {
	return s.GetToken(ECLParserCAP_A, 0)
}

func (s *NonwsnonpipeContext) CAP_B() antlr.TerminalNode {
	return s.GetToken(ECLParserCAP_B, 0)
}

func (s *NonwsnonpipeContext) CAP_C() antlr.TerminalNode {
	return s.GetToken(ECLParserCAP_C, 0)
}

func (s *NonwsnonpipeContext) CAP_D() antlr.TerminalNode {
	return s.GetToken(ECLParserCAP_D, 0)
}

func (s *NonwsnonpipeContext) CAP_E() antlr.TerminalNode {
	return s.GetToken(ECLParserCAP_E, 0)
}

func (s *NonwsnonpipeContext) CAP_F() antlr.TerminalNode {
	return s.GetToken(ECLParserCAP_F, 0)
}

func (s *NonwsnonpipeContext) CAP_G() antlr.TerminalNode {
	return s.GetToken(ECLParserCAP_G, 0)
}

func (s *NonwsnonpipeContext) CAP_H() antlr.TerminalNode {
	return s.GetToken(ECLParserCAP_H, 0)
}

func (s *NonwsnonpipeContext) CAP_I() antlr.TerminalNode {
	return s.GetToken(ECLParserCAP_I, 0)
}

func (s *NonwsnonpipeContext) CAP_J() antlr.TerminalNode {
	return s.GetToken(ECLParserCAP_J, 0)
}

func (s *NonwsnonpipeContext) CAP_K() antlr.TerminalNode {
	return s.GetToken(ECLParserCAP_K, 0)
}

func (s *NonwsnonpipeContext) CAP_L() antlr.TerminalNode {
	return s.GetToken(ECLParserCAP_L, 0)
}

func (s *NonwsnonpipeContext) CAP_M() antlr.TerminalNode {
	return s.GetToken(ECLParserCAP_M, 0)
}

func (s *NonwsnonpipeContext) CAP_N() antlr.TerminalNode {
	return s.GetToken(ECLParserCAP_N, 0)
}

func (s *NonwsnonpipeContext) CAP_O() antlr.TerminalNode {
	return s.GetToken(ECLParserCAP_O, 0)
}

func (s *NonwsnonpipeContext) CAP_P() antlr.TerminalNode {
	return s.GetToken(ECLParserCAP_P, 0)
}

func (s *NonwsnonpipeContext) CAP_Q() antlr.TerminalNode {
	return s.GetToken(ECLParserCAP_Q, 0)
}

func (s *NonwsnonpipeContext) CAP_R() antlr.TerminalNode {
	return s.GetToken(ECLParserCAP_R, 0)
}

func (s *NonwsnonpipeContext) CAP_S() antlr.TerminalNode {
	return s.GetToken(ECLParserCAP_S, 0)
}

func (s *NonwsnonpipeContext) CAP_T() antlr.TerminalNode {
	return s.GetToken(ECLParserCAP_T, 0)
}

func (s *NonwsnonpipeContext) CAP_U() antlr.TerminalNode {
	return s.GetToken(ECLParserCAP_U, 0)
}

func (s *NonwsnonpipeContext) CAP_V() antlr.TerminalNode {
	return s.GetToken(ECLParserCAP_V, 0)
}

func (s *NonwsnonpipeContext) CAP_W() antlr.TerminalNode {
	return s.GetToken(ECLParserCAP_W, 0)
}

func (s *NonwsnonpipeContext) CAP_X() antlr.TerminalNode {
	return s.GetToken(ECLParserCAP_X, 0)
}

func (s *NonwsnonpipeContext) CAP_Y() antlr.TerminalNode {
	return s.GetToken(ECLParserCAP_Y, 0)
}

func (s *NonwsnonpipeContext) CAP_Z() antlr.TerminalNode {
	return s.GetToken(ECLParserCAP_Z, 0)
}

func (s *NonwsnonpipeContext) LEFT_BRACE() antlr.TerminalNode {
	return s.GetToken(ECLParserLEFT_BRACE, 0)
}

func (s *NonwsnonpipeContext) BACKSLASH() antlr.TerminalNode {
	return s.GetToken(ECLParserBACKSLASH, 0)
}

func (s *NonwsnonpipeContext) RIGHT_BRACE() antlr.TerminalNode {
	return s.GetToken(ECLParserRIGHT_BRACE, 0)
}

func (s *NonwsnonpipeContext) CARAT() antlr.TerminalNode {
	return s.GetToken(ECLParserCARAT, 0)
}

func (s *NonwsnonpipeContext) UNDERSCORE() antlr.TerminalNode {
	return s.GetToken(ECLParserUNDERSCORE, 0)
}

func (s *NonwsnonpipeContext) ACCENT() antlr.TerminalNode {
	return s.GetToken(ECLParserACCENT, 0)
}

func (s *NonwsnonpipeContext) A() antlr.TerminalNode {
	return s.GetToken(ECLParserA, 0)
}

func (s *NonwsnonpipeContext) B() antlr.TerminalNode {
	return s.GetToken(ECLParserB, 0)
}

func (s *NonwsnonpipeContext) C() antlr.TerminalNode {
	return s.GetToken(ECLParserC, 0)
}

func (s *NonwsnonpipeContext) D() antlr.TerminalNode {
	return s.GetToken(ECLParserD, 0)
}

func (s *NonwsnonpipeContext) E() antlr.TerminalNode {
	return s.GetToken(ECLParserE, 0)
}

func (s *NonwsnonpipeContext) F() antlr.TerminalNode {
	return s.GetToken(ECLParserF, 0)
}

func (s *NonwsnonpipeContext) G() antlr.TerminalNode {
	return s.GetToken(ECLParserG, 0)
}

func (s *NonwsnonpipeContext) H() antlr.TerminalNode {
	return s.GetToken(ECLParserH, 0)
}

func (s *NonwsnonpipeContext) I() antlr.TerminalNode {
	return s.GetToken(ECLParserI, 0)
}

func (s *NonwsnonpipeContext) J() antlr.TerminalNode {
	return s.GetToken(ECLParserJ, 0)
}

func (s *NonwsnonpipeContext) K() antlr.TerminalNode {
	return s.GetToken(ECLParserK, 0)
}

func (s *NonwsnonpipeContext) L() antlr.TerminalNode {
	return s.GetToken(ECLParserL, 0)
}

func (s *NonwsnonpipeContext) M() antlr.TerminalNode {
	return s.GetToken(ECLParserM, 0)
}

func (s *NonwsnonpipeContext) N() antlr.TerminalNode {
	return s.GetToken(ECLParserN, 0)
}

func (s *NonwsnonpipeContext) O() antlr.TerminalNode {
	return s.GetToken(ECLParserO, 0)
}

func (s *NonwsnonpipeContext) P() antlr.TerminalNode {
	return s.GetToken(ECLParserP, 0)
}

func (s *NonwsnonpipeContext) Q() antlr.TerminalNode {
	return s.GetToken(ECLParserQ, 0)
}

func (s *NonwsnonpipeContext) R() antlr.TerminalNode {
	return s.GetToken(ECLParserR, 0)
}

func (s *NonwsnonpipeContext) S() antlr.TerminalNode {
	return s.GetToken(ECLParserS, 0)
}

func (s *NonwsnonpipeContext) T() antlr.TerminalNode {
	return s.GetToken(ECLParserT, 0)
}

func (s *NonwsnonpipeContext) U() antlr.TerminalNode {
	return s.GetToken(ECLParserU, 0)
}

func (s *NonwsnonpipeContext) V() antlr.TerminalNode {
	return s.GetToken(ECLParserV, 0)
}

func (s *NonwsnonpipeContext) W() antlr.TerminalNode {
	return s.GetToken(ECLParserW, 0)
}

func (s *NonwsnonpipeContext) X() antlr.TerminalNode {
	return s.GetToken(ECLParserX, 0)
}

func (s *NonwsnonpipeContext) Y() antlr.TerminalNode {
	return s.GetToken(ECLParserY, 0)
}

func (s *NonwsnonpipeContext) Z() antlr.TerminalNode {
	return s.GetToken(ECLParserZ, 0)
}

func (s *NonwsnonpipeContext) LEFT_CURLY_BRACE() antlr.TerminalNode {
	return s.GetToken(ECLParserLEFT_CURLY_BRACE, 0)
}

func (s *NonwsnonpipeContext) RIGHT_CURLY_BRACE() antlr.TerminalNode {
	return s.GetToken(ECLParserRIGHT_CURLY_BRACE, 0)
}

func (s *NonwsnonpipeContext) TILDE() antlr.TerminalNode {
	return s.GetToken(ECLParserTILDE, 0)
}

func (s *NonwsnonpipeContext) Utf8_2() IUtf8_2Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUtf8_2Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUtf8_2Context)
}

func (s *NonwsnonpipeContext) Utf8_3() IUtf8_3Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUtf8_3Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUtf8_3Context)
}

func (s *NonwsnonpipeContext) Utf8_4() IUtf8_4Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUtf8_4Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUtf8_4Context)
}

func (s *NonwsnonpipeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NonwsnonpipeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NonwsnonpipeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ECLListener); ok {
		listenerT.EnterNonwsnonpipe(s)
	}
}

func (s *NonwsnonpipeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ECLListener); ok {
		listenerT.ExitNonwsnonpipe(s)
	}
}

func (s *NonwsnonpipeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ECLVisitor:
		return t.VisitNonwsnonpipe(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ECLParser) Nonwsnonpipe() (localctx INonwsnonpipeContext) {
	localctx = NewNonwsnonpipeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 134, ECLParserRULE_nonwsnonpipe)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(679)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ECLParserEXCLAMATION, ECLParserQUOTE, ECLParserPOUND, ECLParserDOLLAR, ECLParserPERCENT, ECLParserAMPERSAND, ECLParserAPOSTROPHE, ECLParserLEFT_PAREN, ECLParserRIGHT_PAREN, ECLParserASTERISK, ECLParserPLUS, ECLParserCOMMA, ECLParserDASH, ECLParserPERIOD, ECLParserSLASH, ECLParserZERO, ECLParserONE, ECLParserTWO, ECLParserTHREE, ECLParserFOUR, ECLParserFIVE, ECLParserSIX, ECLParserSEVEN, ECLParserEIGHT, ECLParserNINE, ECLParserCOLON, ECLParserSEMICOLON, ECLParserLESS_THAN, ECLParserEQUALS, ECLParserGREATER_THAN, ECLParserQUESTION, ECLParserAT, ECLParserCAP_A, ECLParserCAP_B, ECLParserCAP_C, ECLParserCAP_D, ECLParserCAP_E, ECLParserCAP_F, ECLParserCAP_G, ECLParserCAP_H, ECLParserCAP_I, ECLParserCAP_J, ECLParserCAP_K, ECLParserCAP_L, ECLParserCAP_M, ECLParserCAP_N, ECLParserCAP_O, ECLParserCAP_P, ECLParserCAP_Q, ECLParserCAP_R, ECLParserCAP_S, ECLParserCAP_T, ECLParserCAP_U, ECLParserCAP_V, ECLParserCAP_W, ECLParserCAP_X, ECLParserCAP_Y, ECLParserCAP_Z, ECLParserLEFT_BRACE, ECLParserBACKSLASH, ECLParserRIGHT_BRACE, ECLParserCARAT, ECLParserUNDERSCORE, ECLParserACCENT, ECLParserA, ECLParserB, ECLParserC, ECLParserD, ECLParserE, ECLParserF, ECLParserG, ECLParserH, ECLParserI, ECLParserJ, ECLParserK, ECLParserL, ECLParserM, ECLParserN, ECLParserO, ECLParserP, ECLParserQ, ECLParserR, ECLParserS, ECLParserT, ECLParserU, ECLParserV, ECLParserW, ECLParserX, ECLParserY, ECLParserZ, ECLParserLEFT_CURLY_BRACE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(674)
			_la = p.GetTokenStream().LA(1)

			if !((((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<ECLParserEXCLAMATION)|(1<<ECLParserQUOTE)|(1<<ECLParserPOUND)|(1<<ECLParserDOLLAR)|(1<<ECLParserPERCENT)|(1<<ECLParserAMPERSAND)|(1<<ECLParserAPOSTROPHE)|(1<<ECLParserLEFT_PAREN)|(1<<ECLParserRIGHT_PAREN)|(1<<ECLParserASTERISK)|(1<<ECLParserPLUS)|(1<<ECLParserCOMMA)|(1<<ECLParserDASH)|(1<<ECLParserPERIOD)|(1<<ECLParserSLASH)|(1<<ECLParserZERO)|(1<<ECLParserONE)|(1<<ECLParserTWO)|(1<<ECLParserTHREE)|(1<<ECLParserFOUR)|(1<<ECLParserFIVE)|(1<<ECLParserSIX)|(1<<ECLParserSEVEN)|(1<<ECLParserEIGHT)|(1<<ECLParserNINE)|(1<<ECLParserCOLON)|(1<<ECLParserSEMICOLON))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(ECLParserLESS_THAN-32))|(1<<(ECLParserEQUALS-32))|(1<<(ECLParserGREATER_THAN-32))|(1<<(ECLParserQUESTION-32))|(1<<(ECLParserAT-32))|(1<<(ECLParserCAP_A-32))|(1<<(ECLParserCAP_B-32))|(1<<(ECLParserCAP_C-32))|(1<<(ECLParserCAP_D-32))|(1<<(ECLParserCAP_E-32))|(1<<(ECLParserCAP_F-32))|(1<<(ECLParserCAP_G-32))|(1<<(ECLParserCAP_H-32))|(1<<(ECLParserCAP_I-32))|(1<<(ECLParserCAP_J-32))|(1<<(ECLParserCAP_K-32))|(1<<(ECLParserCAP_L-32))|(1<<(ECLParserCAP_M-32))|(1<<(ECLParserCAP_N-32))|(1<<(ECLParserCAP_O-32))|(1<<(ECLParserCAP_P-32))|(1<<(ECLParserCAP_Q-32))|(1<<(ECLParserCAP_R-32))|(1<<(ECLParserCAP_S-32))|(1<<(ECLParserCAP_T-32))|(1<<(ECLParserCAP_U-32))|(1<<(ECLParserCAP_V-32))|(1<<(ECLParserCAP_W-32))|(1<<(ECLParserCAP_X-32))|(1<<(ECLParserCAP_Y-32))|(1<<(ECLParserCAP_Z-32))|(1<<(ECLParserLEFT_BRACE-32)))) != 0) || (((_la-64)&-(0x1f+1)) == 0 && ((1<<uint((_la-64)))&((1<<(ECLParserBACKSLASH-64))|(1<<(ECLParserRIGHT_BRACE-64))|(1<<(ECLParserCARAT-64))|(1<<(ECLParserUNDERSCORE-64))|(1<<(ECLParserACCENT-64))|(1<<(ECLParserA-64))|(1<<(ECLParserB-64))|(1<<(ECLParserC-64))|(1<<(ECLParserD-64))|(1<<(ECLParserE-64))|(1<<(ECLParserF-64))|(1<<(ECLParserG-64))|(1<<(ECLParserH-64))|(1<<(ECLParserI-64))|(1<<(ECLParserJ-64))|(1<<(ECLParserK-64))|(1<<(ECLParserL-64))|(1<<(ECLParserM-64))|(1<<(ECLParserN-64))|(1<<(ECLParserO-64))|(1<<(ECLParserP-64))|(1<<(ECLParserQ-64))|(1<<(ECLParserR-64))|(1<<(ECLParserS-64))|(1<<(ECLParserT-64))|(1<<(ECLParserU-64))|(1<<(ECLParserV-64))|(1<<(ECLParserW-64))|(1<<(ECLParserX-64))|(1<<(ECLParserY-64))|(1<<(ECLParserZ-64))|(1<<(ECLParserLEFT_CURLY_BRACE-64)))) != 0)) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case ECLParserRIGHT_CURLY_BRACE, ECLParserTILDE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(675)
			_la = p.GetTokenStream().LA(1)

			if !(_la == ECLParserRIGHT_CURLY_BRACE || _la == ECLParserTILDE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case ECLParserU_00C2, ECLParserU_00C3, ECLParserU_00C4, ECLParserU_00C5, ECLParserU_00C6, ECLParserU_00C7, ECLParserU_00C8, ECLParserU_00C9, ECLParserU_00CA, ECLParserU_00CB, ECLParserU_00CC, ECLParserU_00CD, ECLParserU_00CE, ECLParserU_00CF, ECLParserU_00D0, ECLParserU_00D1, ECLParserU_00D2, ECLParserU_00D3, ECLParserU_00D4, ECLParserU_00D5, ECLParserU_00D6, ECLParserU_00D7, ECLParserU_00D8, ECLParserU_00D9, ECLParserU_00DA, ECLParserU_00DB, ECLParserU_00DC, ECLParserU_00DD, ECLParserU_00DE, ECLParserU_00DF:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(676)
			p.Utf8_2()
		}

	case ECLParserU_00E0, ECLParserU_00E1, ECLParserU_00E2, ECLParserU_00E3, ECLParserU_00E4, ECLParserU_00E5, ECLParserU_00E6, ECLParserU_00E7, ECLParserU_00E8, ECLParserU_00E9, ECLParserU_00EA, ECLParserU_00EB, ECLParserU_00EC, ECLParserU_00ED, ECLParserU_00EE, ECLParserU_00EF:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(677)
			p.Utf8_3()
		}

	case ECLParserU_00F0, ECLParserU_00F1, ECLParserU_00F2, ECLParserU_00F3, ECLParserU_00F4:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(678)
			p.Utf8_4()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IAnynonescapedcharContext is an interface to support dynamic dispatch.
type IAnynonescapedcharContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAnynonescapedcharContext differentiates from other interfaces.
	IsAnynonescapedcharContext()
}

type AnynonescapedcharContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnynonescapedcharContext() *AnynonescapedcharContext {
	var p = new(AnynonescapedcharContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ECLParserRULE_anynonescapedchar
	return p
}

func (*AnynonescapedcharContext) IsAnynonescapedcharContext() {}

func NewAnynonescapedcharContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AnynonescapedcharContext {
	var p = new(AnynonescapedcharContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ECLParserRULE_anynonescapedchar

	return p
}

func (s *AnynonescapedcharContext) GetParser() antlr.Parser { return s.parser }

func (s *AnynonescapedcharContext) Sp() ISpContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISpContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISpContext)
}

func (s *AnynonescapedcharContext) Htab() IHtabContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHtabContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHtabContext)
}

func (s *AnynonescapedcharContext) Cr() ICrContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICrContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICrContext)
}

func (s *AnynonescapedcharContext) Lf() ILfContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILfContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILfContext)
}

func (s *AnynonescapedcharContext) SPACE() antlr.TerminalNode {
	return s.GetToken(ECLParserSPACE, 0)
}

func (s *AnynonescapedcharContext) EXCLAMATION() antlr.TerminalNode {
	return s.GetToken(ECLParserEXCLAMATION, 0)
}

func (s *AnynonescapedcharContext) POUND() antlr.TerminalNode {
	return s.GetToken(ECLParserPOUND, 0)
}

func (s *AnynonescapedcharContext) DOLLAR() antlr.TerminalNode {
	return s.GetToken(ECLParserDOLLAR, 0)
}

func (s *AnynonescapedcharContext) PERCENT() antlr.TerminalNode {
	return s.GetToken(ECLParserPERCENT, 0)
}

func (s *AnynonescapedcharContext) AMPERSAND() antlr.TerminalNode {
	return s.GetToken(ECLParserAMPERSAND, 0)
}

func (s *AnynonescapedcharContext) APOSTROPHE() antlr.TerminalNode {
	return s.GetToken(ECLParserAPOSTROPHE, 0)
}

func (s *AnynonescapedcharContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(ECLParserLEFT_PAREN, 0)
}

func (s *AnynonescapedcharContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(ECLParserRIGHT_PAREN, 0)
}

func (s *AnynonescapedcharContext) ASTERISK() antlr.TerminalNode {
	return s.GetToken(ECLParserASTERISK, 0)
}

func (s *AnynonescapedcharContext) PLUS() antlr.TerminalNode {
	return s.GetToken(ECLParserPLUS, 0)
}

func (s *AnynonescapedcharContext) COMMA() antlr.TerminalNode {
	return s.GetToken(ECLParserCOMMA, 0)
}

func (s *AnynonescapedcharContext) DASH() antlr.TerminalNode {
	return s.GetToken(ECLParserDASH, 0)
}

func (s *AnynonescapedcharContext) PERIOD() antlr.TerminalNode {
	return s.GetToken(ECLParserPERIOD, 0)
}

func (s *AnynonescapedcharContext) SLASH() antlr.TerminalNode {
	return s.GetToken(ECLParserSLASH, 0)
}

func (s *AnynonescapedcharContext) ZERO() antlr.TerminalNode {
	return s.GetToken(ECLParserZERO, 0)
}

func (s *AnynonescapedcharContext) ONE() antlr.TerminalNode {
	return s.GetToken(ECLParserONE, 0)
}

func (s *AnynonescapedcharContext) TWO() antlr.TerminalNode {
	return s.GetToken(ECLParserTWO, 0)
}

func (s *AnynonescapedcharContext) THREE() antlr.TerminalNode {
	return s.GetToken(ECLParserTHREE, 0)
}

func (s *AnynonescapedcharContext) FOUR() antlr.TerminalNode {
	return s.GetToken(ECLParserFOUR, 0)
}

func (s *AnynonescapedcharContext) FIVE() antlr.TerminalNode {
	return s.GetToken(ECLParserFIVE, 0)
}

func (s *AnynonescapedcharContext) SIX() antlr.TerminalNode {
	return s.GetToken(ECLParserSIX, 0)
}

func (s *AnynonescapedcharContext) SEVEN() antlr.TerminalNode {
	return s.GetToken(ECLParserSEVEN, 0)
}

func (s *AnynonescapedcharContext) EIGHT() antlr.TerminalNode {
	return s.GetToken(ECLParserEIGHT, 0)
}

func (s *AnynonescapedcharContext) NINE() antlr.TerminalNode {
	return s.GetToken(ECLParserNINE, 0)
}

func (s *AnynonescapedcharContext) COLON() antlr.TerminalNode {
	return s.GetToken(ECLParserCOLON, 0)
}

func (s *AnynonescapedcharContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(ECLParserSEMICOLON, 0)
}

func (s *AnynonescapedcharContext) LESS_THAN() antlr.TerminalNode {
	return s.GetToken(ECLParserLESS_THAN, 0)
}

func (s *AnynonescapedcharContext) EQUALS() antlr.TerminalNode {
	return s.GetToken(ECLParserEQUALS, 0)
}

func (s *AnynonescapedcharContext) GREATER_THAN() antlr.TerminalNode {
	return s.GetToken(ECLParserGREATER_THAN, 0)
}

func (s *AnynonescapedcharContext) QUESTION() antlr.TerminalNode {
	return s.GetToken(ECLParserQUESTION, 0)
}

func (s *AnynonescapedcharContext) AT() antlr.TerminalNode {
	return s.GetToken(ECLParserAT, 0)
}

func (s *AnynonescapedcharContext) CAP_A() antlr.TerminalNode {
	return s.GetToken(ECLParserCAP_A, 0)
}

func (s *AnynonescapedcharContext) CAP_B() antlr.TerminalNode {
	return s.GetToken(ECLParserCAP_B, 0)
}

func (s *AnynonescapedcharContext) CAP_C() antlr.TerminalNode {
	return s.GetToken(ECLParserCAP_C, 0)
}

func (s *AnynonescapedcharContext) CAP_D() antlr.TerminalNode {
	return s.GetToken(ECLParserCAP_D, 0)
}

func (s *AnynonescapedcharContext) CAP_E() antlr.TerminalNode {
	return s.GetToken(ECLParserCAP_E, 0)
}

func (s *AnynonescapedcharContext) CAP_F() antlr.TerminalNode {
	return s.GetToken(ECLParserCAP_F, 0)
}

func (s *AnynonescapedcharContext) CAP_G() antlr.TerminalNode {
	return s.GetToken(ECLParserCAP_G, 0)
}

func (s *AnynonescapedcharContext) CAP_H() antlr.TerminalNode {
	return s.GetToken(ECLParserCAP_H, 0)
}

func (s *AnynonescapedcharContext) CAP_I() antlr.TerminalNode {
	return s.GetToken(ECLParserCAP_I, 0)
}

func (s *AnynonescapedcharContext) CAP_J() antlr.TerminalNode {
	return s.GetToken(ECLParserCAP_J, 0)
}

func (s *AnynonescapedcharContext) CAP_K() antlr.TerminalNode {
	return s.GetToken(ECLParserCAP_K, 0)
}

func (s *AnynonescapedcharContext) CAP_L() antlr.TerminalNode {
	return s.GetToken(ECLParserCAP_L, 0)
}

func (s *AnynonescapedcharContext) CAP_M() antlr.TerminalNode {
	return s.GetToken(ECLParserCAP_M, 0)
}

func (s *AnynonescapedcharContext) CAP_N() antlr.TerminalNode {
	return s.GetToken(ECLParserCAP_N, 0)
}

func (s *AnynonescapedcharContext) CAP_O() antlr.TerminalNode {
	return s.GetToken(ECLParserCAP_O, 0)
}

func (s *AnynonescapedcharContext) CAP_P() antlr.TerminalNode {
	return s.GetToken(ECLParserCAP_P, 0)
}

func (s *AnynonescapedcharContext) CAP_Q() antlr.TerminalNode {
	return s.GetToken(ECLParserCAP_Q, 0)
}

func (s *AnynonescapedcharContext) CAP_R() antlr.TerminalNode {
	return s.GetToken(ECLParserCAP_R, 0)
}

func (s *AnynonescapedcharContext) CAP_S() antlr.TerminalNode {
	return s.GetToken(ECLParserCAP_S, 0)
}

func (s *AnynonescapedcharContext) CAP_T() antlr.TerminalNode {
	return s.GetToken(ECLParserCAP_T, 0)
}

func (s *AnynonescapedcharContext) CAP_U() antlr.TerminalNode {
	return s.GetToken(ECLParserCAP_U, 0)
}

func (s *AnynonescapedcharContext) CAP_V() antlr.TerminalNode {
	return s.GetToken(ECLParserCAP_V, 0)
}

func (s *AnynonescapedcharContext) CAP_W() antlr.TerminalNode {
	return s.GetToken(ECLParserCAP_W, 0)
}

func (s *AnynonescapedcharContext) CAP_X() antlr.TerminalNode {
	return s.GetToken(ECLParserCAP_X, 0)
}

func (s *AnynonescapedcharContext) CAP_Y() antlr.TerminalNode {
	return s.GetToken(ECLParserCAP_Y, 0)
}

func (s *AnynonescapedcharContext) CAP_Z() antlr.TerminalNode {
	return s.GetToken(ECLParserCAP_Z, 0)
}

func (s *AnynonescapedcharContext) LEFT_BRACE() antlr.TerminalNode {
	return s.GetToken(ECLParserLEFT_BRACE, 0)
}

func (s *AnynonescapedcharContext) RIGHT_BRACE() antlr.TerminalNode {
	return s.GetToken(ECLParserRIGHT_BRACE, 0)
}

func (s *AnynonescapedcharContext) CARAT() antlr.TerminalNode {
	return s.GetToken(ECLParserCARAT, 0)
}

func (s *AnynonescapedcharContext) UNDERSCORE() antlr.TerminalNode {
	return s.GetToken(ECLParserUNDERSCORE, 0)
}

func (s *AnynonescapedcharContext) ACCENT() antlr.TerminalNode {
	return s.GetToken(ECLParserACCENT, 0)
}

func (s *AnynonescapedcharContext) A() antlr.TerminalNode {
	return s.GetToken(ECLParserA, 0)
}

func (s *AnynonescapedcharContext) B() antlr.TerminalNode {
	return s.GetToken(ECLParserB, 0)
}

func (s *AnynonescapedcharContext) C() antlr.TerminalNode {
	return s.GetToken(ECLParserC, 0)
}

func (s *AnynonescapedcharContext) D() antlr.TerminalNode {
	return s.GetToken(ECLParserD, 0)
}

func (s *AnynonescapedcharContext) E() antlr.TerminalNode {
	return s.GetToken(ECLParserE, 0)
}

func (s *AnynonescapedcharContext) F() antlr.TerminalNode {
	return s.GetToken(ECLParserF, 0)
}

func (s *AnynonescapedcharContext) G() antlr.TerminalNode {
	return s.GetToken(ECLParserG, 0)
}

func (s *AnynonescapedcharContext) H() antlr.TerminalNode {
	return s.GetToken(ECLParserH, 0)
}

func (s *AnynonescapedcharContext) I() antlr.TerminalNode {
	return s.GetToken(ECLParserI, 0)
}

func (s *AnynonescapedcharContext) J() antlr.TerminalNode {
	return s.GetToken(ECLParserJ, 0)
}

func (s *AnynonescapedcharContext) K() antlr.TerminalNode {
	return s.GetToken(ECLParserK, 0)
}

func (s *AnynonescapedcharContext) L() antlr.TerminalNode {
	return s.GetToken(ECLParserL, 0)
}

func (s *AnynonescapedcharContext) M() antlr.TerminalNode {
	return s.GetToken(ECLParserM, 0)
}

func (s *AnynonescapedcharContext) N() antlr.TerminalNode {
	return s.GetToken(ECLParserN, 0)
}

func (s *AnynonescapedcharContext) O() antlr.TerminalNode {
	return s.GetToken(ECLParserO, 0)
}

func (s *AnynonescapedcharContext) P() antlr.TerminalNode {
	return s.GetToken(ECLParserP, 0)
}

func (s *AnynonescapedcharContext) Q() antlr.TerminalNode {
	return s.GetToken(ECLParserQ, 0)
}

func (s *AnynonescapedcharContext) R() antlr.TerminalNode {
	return s.GetToken(ECLParserR, 0)
}

func (s *AnynonescapedcharContext) S() antlr.TerminalNode {
	return s.GetToken(ECLParserS, 0)
}

func (s *AnynonescapedcharContext) T() antlr.TerminalNode {
	return s.GetToken(ECLParserT, 0)
}

func (s *AnynonescapedcharContext) U() antlr.TerminalNode {
	return s.GetToken(ECLParserU, 0)
}

func (s *AnynonescapedcharContext) V() antlr.TerminalNode {
	return s.GetToken(ECLParserV, 0)
}

func (s *AnynonescapedcharContext) W() antlr.TerminalNode {
	return s.GetToken(ECLParserW, 0)
}

func (s *AnynonescapedcharContext) X() antlr.TerminalNode {
	return s.GetToken(ECLParserX, 0)
}

func (s *AnynonescapedcharContext) Y() antlr.TerminalNode {
	return s.GetToken(ECLParserY, 0)
}

func (s *AnynonescapedcharContext) Z() antlr.TerminalNode {
	return s.GetToken(ECLParserZ, 0)
}

func (s *AnynonescapedcharContext) LEFT_CURLY_BRACE() antlr.TerminalNode {
	return s.GetToken(ECLParserLEFT_CURLY_BRACE, 0)
}

func (s *AnynonescapedcharContext) PIPE() antlr.TerminalNode {
	return s.GetToken(ECLParserPIPE, 0)
}

func (s *AnynonescapedcharContext) RIGHT_CURLY_BRACE() antlr.TerminalNode {
	return s.GetToken(ECLParserRIGHT_CURLY_BRACE, 0)
}

func (s *AnynonescapedcharContext) TILDE() antlr.TerminalNode {
	return s.GetToken(ECLParserTILDE, 0)
}

func (s *AnynonescapedcharContext) Utf8_2() IUtf8_2Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUtf8_2Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUtf8_2Context)
}

func (s *AnynonescapedcharContext) Utf8_3() IUtf8_3Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUtf8_3Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUtf8_3Context)
}

func (s *AnynonescapedcharContext) Utf8_4() IUtf8_4Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUtf8_4Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUtf8_4Context)
}

func (s *AnynonescapedcharContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnynonescapedcharContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AnynonescapedcharContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ECLListener); ok {
		listenerT.EnterAnynonescapedchar(s)
	}
}

func (s *AnynonescapedcharContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ECLListener); ok {
		listenerT.ExitAnynonescapedchar(s)
	}
}

func (s *AnynonescapedcharContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ECLVisitor:
		return t.VisitAnynonescapedchar(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ECLParser) Anynonescapedchar() (localctx IAnynonescapedcharContext) {
	localctx = NewAnynonescapedcharContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 136, ECLParserRULE_anynonescapedchar)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(691)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 52, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(681)
			p.Sp()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(682)
			p.Htab()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(683)
			p.Cr()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(684)
			p.Lf()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(685)
			_la = p.GetTokenStream().LA(1)

			if !(_la == ECLParserSPACE || _la == ECLParserEXCLAMATION) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(686)
			_la = p.GetTokenStream().LA(1)

			if !((((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<ECLParserPOUND)|(1<<ECLParserDOLLAR)|(1<<ECLParserPERCENT)|(1<<ECLParserAMPERSAND)|(1<<ECLParserAPOSTROPHE)|(1<<ECLParserLEFT_PAREN)|(1<<ECLParserRIGHT_PAREN)|(1<<ECLParserASTERISK)|(1<<ECLParserPLUS)|(1<<ECLParserCOMMA)|(1<<ECLParserDASH)|(1<<ECLParserPERIOD)|(1<<ECLParserSLASH)|(1<<ECLParserZERO)|(1<<ECLParserONE)|(1<<ECLParserTWO)|(1<<ECLParserTHREE)|(1<<ECLParserFOUR)|(1<<ECLParserFIVE)|(1<<ECLParserSIX)|(1<<ECLParserSEVEN)|(1<<ECLParserEIGHT)|(1<<ECLParserNINE)|(1<<ECLParserCOLON)|(1<<ECLParserSEMICOLON))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(ECLParserLESS_THAN-32))|(1<<(ECLParserEQUALS-32))|(1<<(ECLParserGREATER_THAN-32))|(1<<(ECLParserQUESTION-32))|(1<<(ECLParserAT-32))|(1<<(ECLParserCAP_A-32))|(1<<(ECLParserCAP_B-32))|(1<<(ECLParserCAP_C-32))|(1<<(ECLParserCAP_D-32))|(1<<(ECLParserCAP_E-32))|(1<<(ECLParserCAP_F-32))|(1<<(ECLParserCAP_G-32))|(1<<(ECLParserCAP_H-32))|(1<<(ECLParserCAP_I-32))|(1<<(ECLParserCAP_J-32))|(1<<(ECLParserCAP_K-32))|(1<<(ECLParserCAP_L-32))|(1<<(ECLParserCAP_M-32))|(1<<(ECLParserCAP_N-32))|(1<<(ECLParserCAP_O-32))|(1<<(ECLParserCAP_P-32))|(1<<(ECLParserCAP_Q-32))|(1<<(ECLParserCAP_R-32))|(1<<(ECLParserCAP_S-32))|(1<<(ECLParserCAP_T-32))|(1<<(ECLParserCAP_U-32))|(1<<(ECLParserCAP_V-32))|(1<<(ECLParserCAP_W-32))|(1<<(ECLParserCAP_X-32))|(1<<(ECLParserCAP_Y-32))|(1<<(ECLParserCAP_Z-32))|(1<<(ECLParserLEFT_BRACE-32)))) != 0)) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(687)
			_la = p.GetTokenStream().LA(1)

			if !((((_la-65)&-(0x1f+1)) == 0 && ((1<<uint((_la-65)))&((1<<(ECLParserRIGHT_BRACE-65))|(1<<(ECLParserCARAT-65))|(1<<(ECLParserUNDERSCORE-65))|(1<<(ECLParserACCENT-65))|(1<<(ECLParserA-65))|(1<<(ECLParserB-65))|(1<<(ECLParserC-65))|(1<<(ECLParserD-65))|(1<<(ECLParserE-65))|(1<<(ECLParserF-65))|(1<<(ECLParserG-65))|(1<<(ECLParserH-65))|(1<<(ECLParserI-65))|(1<<(ECLParserJ-65))|(1<<(ECLParserK-65))|(1<<(ECLParserL-65))|(1<<(ECLParserM-65))|(1<<(ECLParserN-65))|(1<<(ECLParserO-65))|(1<<(ECLParserP-65))|(1<<(ECLParserQ-65))|(1<<(ECLParserR-65))|(1<<(ECLParserS-65))|(1<<(ECLParserT-65))|(1<<(ECLParserU-65))|(1<<(ECLParserV-65))|(1<<(ECLParserW-65))|(1<<(ECLParserX-65))|(1<<(ECLParserY-65))|(1<<(ECLParserZ-65))|(1<<(ECLParserLEFT_CURLY_BRACE-65))|(1<<(ECLParserPIPE-65)))) != 0) || _la == ECLParserRIGHT_CURLY_BRACE || _la == ECLParserTILDE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(688)
			p.Utf8_2()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(689)
			p.Utf8_3()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(690)
			p.Utf8_4()
		}

	}

	return localctx
}

// IEscapedcharContext is an interface to support dynamic dispatch.
type IEscapedcharContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEscapedcharContext differentiates from other interfaces.
	IsEscapedcharContext()
}

type EscapedcharContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEscapedcharContext() *EscapedcharContext {
	var p = new(EscapedcharContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ECLParserRULE_escapedchar
	return p
}

func (*EscapedcharContext) IsEscapedcharContext() {}

func NewEscapedcharContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EscapedcharContext {
	var p = new(EscapedcharContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ECLParserRULE_escapedchar

	return p
}

func (s *EscapedcharContext) GetParser() antlr.Parser { return s.parser }

func (s *EscapedcharContext) AllBs() []IBsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IBsContext)(nil)).Elem())
	var tst = make([]IBsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IBsContext)
		}
	}

	return tst
}

func (s *EscapedcharContext) Bs(i int) IBsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IBsContext)
}

func (s *EscapedcharContext) Qm() IQmContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQmContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQmContext)
}

func (s *EscapedcharContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EscapedcharContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EscapedcharContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ECLListener); ok {
		listenerT.EnterEscapedchar(s)
	}
}

func (s *EscapedcharContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ECLListener); ok {
		listenerT.ExitEscapedchar(s)
	}
}

func (s *EscapedcharContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ECLVisitor:
		return t.VisitEscapedchar(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ECLParser) Escapedchar() (localctx IEscapedcharContext) {
	localctx = NewEscapedcharContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 138, ECLParserRULE_escapedchar)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(699)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 53, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(693)
			p.Bs()
		}
		{
			p.SetState(694)
			p.Qm()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(696)
			p.Bs()
		}
		{
			p.SetState(697)
			p.Bs()
		}

	}

	return localctx
}

// IUtf8_2Context is an interface to support dynamic dispatch.
type IUtf8_2Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUtf8_2Context differentiates from other interfaces.
	IsUtf8_2Context()
}

type Utf8_2Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUtf8_2Context() *Utf8_2Context {
	var p = new(Utf8_2Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ECLParserRULE_utf8_2
	return p
}

func (*Utf8_2Context) IsUtf8_2Context() {}

func NewUtf8_2Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Utf8_2Context {
	var p = new(Utf8_2Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ECLParserRULE_utf8_2

	return p
}

func (s *Utf8_2Context) GetParser() antlr.Parser { return s.parser }

func (s *Utf8_2Context) Utf8_tail() IUtf8_tailContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUtf8_tailContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUtf8_tailContext)
}

func (s *Utf8_2Context) U_00C2() antlr.TerminalNode {
	return s.GetToken(ECLParserU_00C2, 0)
}

func (s *Utf8_2Context) U_00C3() antlr.TerminalNode {
	return s.GetToken(ECLParserU_00C3, 0)
}

func (s *Utf8_2Context) U_00C4() antlr.TerminalNode {
	return s.GetToken(ECLParserU_00C4, 0)
}

func (s *Utf8_2Context) U_00C5() antlr.TerminalNode {
	return s.GetToken(ECLParserU_00C5, 0)
}

func (s *Utf8_2Context) U_00C6() antlr.TerminalNode {
	return s.GetToken(ECLParserU_00C6, 0)
}

func (s *Utf8_2Context) U_00C7() antlr.TerminalNode {
	return s.GetToken(ECLParserU_00C7, 0)
}

func (s *Utf8_2Context) U_00C8() antlr.TerminalNode {
	return s.GetToken(ECLParserU_00C8, 0)
}

func (s *Utf8_2Context) U_00C9() antlr.TerminalNode {
	return s.GetToken(ECLParserU_00C9, 0)
}

func (s *Utf8_2Context) U_00CA() antlr.TerminalNode {
	return s.GetToken(ECLParserU_00CA, 0)
}

func (s *Utf8_2Context) U_00CB() antlr.TerminalNode {
	return s.GetToken(ECLParserU_00CB, 0)
}

func (s *Utf8_2Context) U_00CC() antlr.TerminalNode {
	return s.GetToken(ECLParserU_00CC, 0)
}

func (s *Utf8_2Context) U_00CD() antlr.TerminalNode {
	return s.GetToken(ECLParserU_00CD, 0)
}

func (s *Utf8_2Context) U_00CE() antlr.TerminalNode {
	return s.GetToken(ECLParserU_00CE, 0)
}

func (s *Utf8_2Context) U_00CF() antlr.TerminalNode {
	return s.GetToken(ECLParserU_00CF, 0)
}

func (s *Utf8_2Context) U_00D0() antlr.TerminalNode {
	return s.GetToken(ECLParserU_00D0, 0)
}

func (s *Utf8_2Context) U_00D1() antlr.TerminalNode {
	return s.GetToken(ECLParserU_00D1, 0)
}

func (s *Utf8_2Context) U_00D2() antlr.TerminalNode {
	return s.GetToken(ECLParserU_00D2, 0)
}

func (s *Utf8_2Context) U_00D3() antlr.TerminalNode {
	return s.GetToken(ECLParserU_00D3, 0)
}

func (s *Utf8_2Context) U_00D4() antlr.TerminalNode {
	return s.GetToken(ECLParserU_00D4, 0)
}

func (s *Utf8_2Context) U_00D5() antlr.TerminalNode {
	return s.GetToken(ECLParserU_00D5, 0)
}

func (s *Utf8_2Context) U_00D6() antlr.TerminalNode {
	return s.GetToken(ECLParserU_00D6, 0)
}

func (s *Utf8_2Context) U_00D7() antlr.TerminalNode {
	return s.GetToken(ECLParserU_00D7, 0)
}

func (s *Utf8_2Context) U_00D8() antlr.TerminalNode {
	return s.GetToken(ECLParserU_00D8, 0)
}

func (s *Utf8_2Context) U_00D9() antlr.TerminalNode {
	return s.GetToken(ECLParserU_00D9, 0)
}

func (s *Utf8_2Context) U_00DA() antlr.TerminalNode {
	return s.GetToken(ECLParserU_00DA, 0)
}

func (s *Utf8_2Context) U_00DB() antlr.TerminalNode {
	return s.GetToken(ECLParserU_00DB, 0)
}

func (s *Utf8_2Context) U_00DC() antlr.TerminalNode {
	return s.GetToken(ECLParserU_00DC, 0)
}

func (s *Utf8_2Context) U_00DD() antlr.TerminalNode {
	return s.GetToken(ECLParserU_00DD, 0)
}

func (s *Utf8_2Context) U_00DE() antlr.TerminalNode {
	return s.GetToken(ECLParserU_00DE, 0)
}

func (s *Utf8_2Context) U_00DF() antlr.TerminalNode {
	return s.GetToken(ECLParserU_00DF, 0)
}

func (s *Utf8_2Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Utf8_2Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Utf8_2Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ECLListener); ok {
		listenerT.EnterUtf8_2(s)
	}
}

func (s *Utf8_2Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ECLListener); ok {
		listenerT.ExitUtf8_2(s)
	}
}

func (s *Utf8_2Context) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ECLVisitor:
		return t.VisitUtf8_2(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ECLParser) Utf8_2() (localctx IUtf8_2Context) {
	localctx = NewUtf8_2Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 140, ECLParserRULE_utf8_2)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(701)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-163)&-(0x1f+1)) == 0 && ((1<<uint((_la-163)))&((1<<(ECLParserU_00C2-163))|(1<<(ECLParserU_00C3-163))|(1<<(ECLParserU_00C4-163))|(1<<(ECLParserU_00C5-163))|(1<<(ECLParserU_00C6-163))|(1<<(ECLParserU_00C7-163))|(1<<(ECLParserU_00C8-163))|(1<<(ECLParserU_00C9-163))|(1<<(ECLParserU_00CA-163))|(1<<(ECLParserU_00CB-163))|(1<<(ECLParserU_00CC-163))|(1<<(ECLParserU_00CD-163))|(1<<(ECLParserU_00CE-163))|(1<<(ECLParserU_00CF-163))|(1<<(ECLParserU_00D0-163))|(1<<(ECLParserU_00D1-163))|(1<<(ECLParserU_00D2-163))|(1<<(ECLParserU_00D3-163))|(1<<(ECLParserU_00D4-163))|(1<<(ECLParserU_00D5-163))|(1<<(ECLParserU_00D6-163))|(1<<(ECLParserU_00D7-163))|(1<<(ECLParserU_00D8-163))|(1<<(ECLParserU_00D9-163))|(1<<(ECLParserU_00DA-163))|(1<<(ECLParserU_00DB-163))|(1<<(ECLParserU_00DC-163))|(1<<(ECLParserU_00DD-163))|(1<<(ECLParserU_00DE-163))|(1<<(ECLParserU_00DF-163)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(702)
		p.Utf8_tail()
	}

	return localctx
}

// IUtf8_3Context is an interface to support dynamic dispatch.
type IUtf8_3Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUtf8_3Context differentiates from other interfaces.
	IsUtf8_3Context()
}

type Utf8_3Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUtf8_3Context() *Utf8_3Context {
	var p = new(Utf8_3Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ECLParserRULE_utf8_3
	return p
}

func (*Utf8_3Context) IsUtf8_3Context() {}

func NewUtf8_3Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Utf8_3Context {
	var p = new(Utf8_3Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ECLParserRULE_utf8_3

	return p
}

func (s *Utf8_3Context) GetParser() antlr.Parser { return s.parser }

func (s *Utf8_3Context) U_00E0() antlr.TerminalNode {
	return s.GetToken(ECLParserU_00E0, 0)
}

func (s *Utf8_3Context) AllUtf8_tail() []IUtf8_tailContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IUtf8_tailContext)(nil)).Elem())
	var tst = make([]IUtf8_tailContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IUtf8_tailContext)
		}
	}

	return tst
}

func (s *Utf8_3Context) Utf8_tail(i int) IUtf8_tailContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUtf8_tailContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IUtf8_tailContext)
}

func (s *Utf8_3Context) U_00A0() antlr.TerminalNode {
	return s.GetToken(ECLParserU_00A0, 0)
}

func (s *Utf8_3Context) U_00A1() antlr.TerminalNode {
	return s.GetToken(ECLParserU_00A1, 0)
}

func (s *Utf8_3Context) U_00A2() antlr.TerminalNode {
	return s.GetToken(ECLParserU_00A2, 0)
}

func (s *Utf8_3Context) U_00A3() antlr.TerminalNode {
	return s.GetToken(ECLParserU_00A3, 0)
}

func (s *Utf8_3Context) U_00A4() antlr.TerminalNode {
	return s.GetToken(ECLParserU_00A4, 0)
}

func (s *Utf8_3Context) U_00A5() antlr.TerminalNode {
	return s.GetToken(ECLParserU_00A5, 0)
}

func (s *Utf8_3Context) U_00A6() antlr.TerminalNode {
	return s.GetToken(ECLParserU_00A6, 0)
}

func (s *Utf8_3Context) U_00A7() antlr.TerminalNode {
	return s.GetToken(ECLParserU_00A7, 0)
}

func (s *Utf8_3Context) U_00A8() antlr.TerminalNode {
	return s.GetToken(ECLParserU_00A8, 0)
}

func (s *Utf8_3Context) U_00A9() antlr.TerminalNode {
	return s.GetToken(ECLParserU_00A9, 0)
}

func (s *Utf8_3Context) U_00AA() antlr.TerminalNode {
	return s.GetToken(ECLParserU_00AA, 0)
}

func (s *Utf8_3Context) U_00AB() antlr.TerminalNode {
	return s.GetToken(ECLParserU_00AB, 0)
}

func (s *Utf8_3Context) U_00AC() antlr.TerminalNode {
	return s.GetToken(ECLParserU_00AC, 0)
}

func (s *Utf8_3Context) U_00AD() antlr.TerminalNode {
	return s.GetToken(ECLParserU_00AD, 0)
}

func (s *Utf8_3Context) U_00AE() antlr.TerminalNode {
	return s.GetToken(ECLParserU_00AE, 0)
}

func (s *Utf8_3Context) U_00AF() antlr.TerminalNode {
	return s.GetToken(ECLParserU_00AF, 0)
}

func (s *Utf8_3Context) U_00B0() antlr.TerminalNode {
	return s.GetToken(ECLParserU_00B0, 0)
}

func (s *Utf8_3Context) U_00B1() antlr.TerminalNode {
	return s.GetToken(ECLParserU_00B1, 0)
}

func (s *Utf8_3Context) U_00B2() antlr.TerminalNode {
	return s.GetToken(ECLParserU_00B2, 0)
}

func (s *Utf8_3Context) U_00B3() antlr.TerminalNode {
	return s.GetToken(ECLParserU_00B3, 0)
}

func (s *Utf8_3Context) U_00B4() antlr.TerminalNode {
	return s.GetToken(ECLParserU_00B4, 0)
}

func (s *Utf8_3Context) U_00B5() antlr.TerminalNode {
	return s.GetToken(ECLParserU_00B5, 0)
}

func (s *Utf8_3Context) U_00B6() antlr.TerminalNode {
	return s.GetToken(ECLParserU_00B6, 0)
}

func (s *Utf8_3Context) U_00B7() antlr.TerminalNode {
	return s.GetToken(ECLParserU_00B7, 0)
}

func (s *Utf8_3Context) U_00B8() antlr.TerminalNode {
	return s.GetToken(ECLParserU_00B8, 0)
}

func (s *Utf8_3Context) U_00B9() antlr.TerminalNode {
	return s.GetToken(ECLParserU_00B9, 0)
}

func (s *Utf8_3Context) U_00BA() antlr.TerminalNode {
	return s.GetToken(ECLParserU_00BA, 0)
}

func (s *Utf8_3Context) U_00BB() antlr.TerminalNode {
	return s.GetToken(ECLParserU_00BB, 0)
}

func (s *Utf8_3Context) U_00BC() antlr.TerminalNode {
	return s.GetToken(ECLParserU_00BC, 0)
}

func (s *Utf8_3Context) U_00BD() antlr.TerminalNode {
	return s.GetToken(ECLParserU_00BD, 0)
}

func (s *Utf8_3Context) U_00BE() antlr.TerminalNode {
	return s.GetToken(ECLParserU_00BE, 0)
}

func (s *Utf8_3Context) U_00BF() antlr.TerminalNode {
	return s.GetToken(ECLParserU_00BF, 0)
}

func (s *Utf8_3Context) U_00E1() antlr.TerminalNode {
	return s.GetToken(ECLParserU_00E1, 0)
}

func (s *Utf8_3Context) U_00E2() antlr.TerminalNode {
	return s.GetToken(ECLParserU_00E2, 0)
}

func (s *Utf8_3Context) U_00E3() antlr.TerminalNode {
	return s.GetToken(ECLParserU_00E3, 0)
}

func (s *Utf8_3Context) U_00E4() antlr.TerminalNode {
	return s.GetToken(ECLParserU_00E4, 0)
}

func (s *Utf8_3Context) U_00E5() antlr.TerminalNode {
	return s.GetToken(ECLParserU_00E5, 0)
}

func (s *Utf8_3Context) U_00E6() antlr.TerminalNode {
	return s.GetToken(ECLParserU_00E6, 0)
}

func (s *Utf8_3Context) U_00E7() antlr.TerminalNode {
	return s.GetToken(ECLParserU_00E7, 0)
}

func (s *Utf8_3Context) U_00E8() antlr.TerminalNode {
	return s.GetToken(ECLParserU_00E8, 0)
}

func (s *Utf8_3Context) U_00E9() antlr.TerminalNode {
	return s.GetToken(ECLParserU_00E9, 0)
}

func (s *Utf8_3Context) U_00EA() antlr.TerminalNode {
	return s.GetToken(ECLParserU_00EA, 0)
}

func (s *Utf8_3Context) U_00EB() antlr.TerminalNode {
	return s.GetToken(ECLParserU_00EB, 0)
}

func (s *Utf8_3Context) U_00EC() antlr.TerminalNode {
	return s.GetToken(ECLParserU_00EC, 0)
}

func (s *Utf8_3Context) U_00ED() antlr.TerminalNode {
	return s.GetToken(ECLParserU_00ED, 0)
}

func (s *Utf8_3Context) U_0080() antlr.TerminalNode {
	return s.GetToken(ECLParserU_0080, 0)
}

func (s *Utf8_3Context) U_0081() antlr.TerminalNode {
	return s.GetToken(ECLParserU_0081, 0)
}

func (s *Utf8_3Context) U_0082() antlr.TerminalNode {
	return s.GetToken(ECLParserU_0082, 0)
}

func (s *Utf8_3Context) U_0083() antlr.TerminalNode {
	return s.GetToken(ECLParserU_0083, 0)
}

func (s *Utf8_3Context) U_0084() antlr.TerminalNode {
	return s.GetToken(ECLParserU_0084, 0)
}

func (s *Utf8_3Context) U_0085() antlr.TerminalNode {
	return s.GetToken(ECLParserU_0085, 0)
}

func (s *Utf8_3Context) U_0086() antlr.TerminalNode {
	return s.GetToken(ECLParserU_0086, 0)
}

func (s *Utf8_3Context) U_0087() antlr.TerminalNode {
	return s.GetToken(ECLParserU_0087, 0)
}

func (s *Utf8_3Context) U_0088() antlr.TerminalNode {
	return s.GetToken(ECLParserU_0088, 0)
}

func (s *Utf8_3Context) U_0089() antlr.TerminalNode {
	return s.GetToken(ECLParserU_0089, 0)
}

func (s *Utf8_3Context) U_008A() antlr.TerminalNode {
	return s.GetToken(ECLParserU_008A, 0)
}

func (s *Utf8_3Context) U_008B() antlr.TerminalNode {
	return s.GetToken(ECLParserU_008B, 0)
}

func (s *Utf8_3Context) U_008C() antlr.TerminalNode {
	return s.GetToken(ECLParserU_008C, 0)
}

func (s *Utf8_3Context) U_008D() antlr.TerminalNode {
	return s.GetToken(ECLParserU_008D, 0)
}

func (s *Utf8_3Context) U_008E() antlr.TerminalNode {
	return s.GetToken(ECLParserU_008E, 0)
}

func (s *Utf8_3Context) U_008F() antlr.TerminalNode {
	return s.GetToken(ECLParserU_008F, 0)
}

func (s *Utf8_3Context) U_0090() antlr.TerminalNode {
	return s.GetToken(ECLParserU_0090, 0)
}

func (s *Utf8_3Context) U_0091() antlr.TerminalNode {
	return s.GetToken(ECLParserU_0091, 0)
}

func (s *Utf8_3Context) U_0092() antlr.TerminalNode {
	return s.GetToken(ECLParserU_0092, 0)
}

func (s *Utf8_3Context) U_0093() antlr.TerminalNode {
	return s.GetToken(ECLParserU_0093, 0)
}

func (s *Utf8_3Context) U_0094() antlr.TerminalNode {
	return s.GetToken(ECLParserU_0094, 0)
}

func (s *Utf8_3Context) U_0095() antlr.TerminalNode {
	return s.GetToken(ECLParserU_0095, 0)
}

func (s *Utf8_3Context) U_0096() antlr.TerminalNode {
	return s.GetToken(ECLParserU_0096, 0)
}

func (s *Utf8_3Context) U_0097() antlr.TerminalNode {
	return s.GetToken(ECLParserU_0097, 0)
}

func (s *Utf8_3Context) U_0098() antlr.TerminalNode {
	return s.GetToken(ECLParserU_0098, 0)
}

func (s *Utf8_3Context) U_0099() antlr.TerminalNode {
	return s.GetToken(ECLParserU_0099, 0)
}

func (s *Utf8_3Context) U_009A() antlr.TerminalNode {
	return s.GetToken(ECLParserU_009A, 0)
}

func (s *Utf8_3Context) U_009B() antlr.TerminalNode {
	return s.GetToken(ECLParserU_009B, 0)
}

func (s *Utf8_3Context) U_009C() antlr.TerminalNode {
	return s.GetToken(ECLParserU_009C, 0)
}

func (s *Utf8_3Context) U_009D() antlr.TerminalNode {
	return s.GetToken(ECLParserU_009D, 0)
}

func (s *Utf8_3Context) U_009E() antlr.TerminalNode {
	return s.GetToken(ECLParserU_009E, 0)
}

func (s *Utf8_3Context) U_009F() antlr.TerminalNode {
	return s.GetToken(ECLParserU_009F, 0)
}

func (s *Utf8_3Context) U_00EE() antlr.TerminalNode {
	return s.GetToken(ECLParserU_00EE, 0)
}

func (s *Utf8_3Context) U_00EF() antlr.TerminalNode {
	return s.GetToken(ECLParserU_00EF, 0)
}

func (s *Utf8_3Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Utf8_3Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Utf8_3Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ECLListener); ok {
		listenerT.EnterUtf8_3(s)
	}
}

func (s *Utf8_3Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ECLListener); ok {
		listenerT.ExitUtf8_3(s)
	}
}

func (s *Utf8_3Context) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ECLVisitor:
		return t.VisitUtf8_3(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ECLParser) Utf8_3() (localctx IUtf8_3Context) {
	localctx = NewUtf8_3Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 142, ECLParserRULE_utf8_3)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(718)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ECLParserU_00E0:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(704)
			p.Match(ECLParserU_00E0)
		}
		{
			p.SetState(705)
			_la = p.GetTokenStream().LA(1)

			if !(((_la-131)&-(0x1f+1)) == 0 && ((1<<uint((_la-131)))&((1<<(ECLParserU_00A0-131))|(1<<(ECLParserU_00A1-131))|(1<<(ECLParserU_00A2-131))|(1<<(ECLParserU_00A3-131))|(1<<(ECLParserU_00A4-131))|(1<<(ECLParserU_00A5-131))|(1<<(ECLParserU_00A6-131))|(1<<(ECLParserU_00A7-131))|(1<<(ECLParserU_00A8-131))|(1<<(ECLParserU_00A9-131))|(1<<(ECLParserU_00AA-131))|(1<<(ECLParserU_00AB-131))|(1<<(ECLParserU_00AC-131))|(1<<(ECLParserU_00AD-131))|(1<<(ECLParserU_00AE-131))|(1<<(ECLParserU_00AF-131))|(1<<(ECLParserU_00B0-131))|(1<<(ECLParserU_00B1-131))|(1<<(ECLParserU_00B2-131))|(1<<(ECLParserU_00B3-131))|(1<<(ECLParserU_00B4-131))|(1<<(ECLParserU_00B5-131))|(1<<(ECLParserU_00B6-131))|(1<<(ECLParserU_00B7-131))|(1<<(ECLParserU_00B8-131))|(1<<(ECLParserU_00B9-131))|(1<<(ECLParserU_00BA-131))|(1<<(ECLParserU_00BB-131))|(1<<(ECLParserU_00BC-131))|(1<<(ECLParserU_00BD-131))|(1<<(ECLParserU_00BE-131))|(1<<(ECLParserU_00BF-131)))) != 0) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(706)
			p.Utf8_tail()
		}

	case ECLParserU_00E1, ECLParserU_00E2, ECLParserU_00E3, ECLParserU_00E4, ECLParserU_00E5, ECLParserU_00E6, ECLParserU_00E7, ECLParserU_00E8, ECLParserU_00E9, ECLParserU_00EA, ECLParserU_00EB, ECLParserU_00EC:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(707)
			_la = p.GetTokenStream().LA(1)

			if !(((_la-194)&-(0x1f+1)) == 0 && ((1<<uint((_la-194)))&((1<<(ECLParserU_00E1-194))|(1<<(ECLParserU_00E2-194))|(1<<(ECLParserU_00E3-194))|(1<<(ECLParserU_00E4-194))|(1<<(ECLParserU_00E5-194))|(1<<(ECLParserU_00E6-194))|(1<<(ECLParserU_00E7-194))|(1<<(ECLParserU_00E8-194))|(1<<(ECLParserU_00E9-194))|(1<<(ECLParserU_00EA-194))|(1<<(ECLParserU_00EB-194))|(1<<(ECLParserU_00EC-194)))) != 0) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

		{
			p.SetState(708)
			p.Utf8_tail()
		}

		{
			p.SetState(709)
			p.Utf8_tail()
		}

	case ECLParserU_00ED:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(711)
			p.Match(ECLParserU_00ED)
		}
		{
			p.SetState(712)
			_la = p.GetTokenStream().LA(1)

			if !(((_la-99)&-(0x1f+1)) == 0 && ((1<<uint((_la-99)))&((1<<(ECLParserU_0080-99))|(1<<(ECLParserU_0081-99))|(1<<(ECLParserU_0082-99))|(1<<(ECLParserU_0083-99))|(1<<(ECLParserU_0084-99))|(1<<(ECLParserU_0085-99))|(1<<(ECLParserU_0086-99))|(1<<(ECLParserU_0087-99))|(1<<(ECLParserU_0088-99))|(1<<(ECLParserU_0089-99))|(1<<(ECLParserU_008A-99))|(1<<(ECLParserU_008B-99))|(1<<(ECLParserU_008C-99))|(1<<(ECLParserU_008D-99))|(1<<(ECLParserU_008E-99))|(1<<(ECLParserU_008F-99))|(1<<(ECLParserU_0090-99))|(1<<(ECLParserU_0091-99))|(1<<(ECLParserU_0092-99))|(1<<(ECLParserU_0093-99))|(1<<(ECLParserU_0094-99))|(1<<(ECLParserU_0095-99))|(1<<(ECLParserU_0096-99))|(1<<(ECLParserU_0097-99))|(1<<(ECLParserU_0098-99))|(1<<(ECLParserU_0099-99))|(1<<(ECLParserU_009A-99))|(1<<(ECLParserU_009B-99))|(1<<(ECLParserU_009C-99))|(1<<(ECLParserU_009D-99))|(1<<(ECLParserU_009E-99))|(1<<(ECLParserU_009F-99)))) != 0) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(713)
			p.Utf8_tail()
		}

	case ECLParserU_00EE, ECLParserU_00EF:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(714)
			_la = p.GetTokenStream().LA(1)

			if !(_la == ECLParserU_00EE || _la == ECLParserU_00EF) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

		{
			p.SetState(715)
			p.Utf8_tail()
		}

		{
			p.SetState(716)
			p.Utf8_tail()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IUtf8_4Context is an interface to support dynamic dispatch.
type IUtf8_4Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUtf8_4Context differentiates from other interfaces.
	IsUtf8_4Context()
}

type Utf8_4Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUtf8_4Context() *Utf8_4Context {
	var p = new(Utf8_4Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ECLParserRULE_utf8_4
	return p
}

func (*Utf8_4Context) IsUtf8_4Context() {}

func NewUtf8_4Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Utf8_4Context {
	var p = new(Utf8_4Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ECLParserRULE_utf8_4

	return p
}

func (s *Utf8_4Context) GetParser() antlr.Parser { return s.parser }

func (s *Utf8_4Context) U_00F0() antlr.TerminalNode {
	return s.GetToken(ECLParserU_00F0, 0)
}

func (s *Utf8_4Context) U_0090() antlr.TerminalNode {
	return s.GetToken(ECLParserU_0090, 0)
}

func (s *Utf8_4Context) U_0091() antlr.TerminalNode {
	return s.GetToken(ECLParserU_0091, 0)
}

func (s *Utf8_4Context) U_0092() antlr.TerminalNode {
	return s.GetToken(ECLParserU_0092, 0)
}

func (s *Utf8_4Context) U_0093() antlr.TerminalNode {
	return s.GetToken(ECLParserU_0093, 0)
}

func (s *Utf8_4Context) U_0094() antlr.TerminalNode {
	return s.GetToken(ECLParserU_0094, 0)
}

func (s *Utf8_4Context) U_0095() antlr.TerminalNode {
	return s.GetToken(ECLParserU_0095, 0)
}

func (s *Utf8_4Context) U_0096() antlr.TerminalNode {
	return s.GetToken(ECLParserU_0096, 0)
}

func (s *Utf8_4Context) U_0097() antlr.TerminalNode {
	return s.GetToken(ECLParserU_0097, 0)
}

func (s *Utf8_4Context) U_0098() antlr.TerminalNode {
	return s.GetToken(ECLParserU_0098, 0)
}

func (s *Utf8_4Context) U_0099() antlr.TerminalNode {
	return s.GetToken(ECLParserU_0099, 0)
}

func (s *Utf8_4Context) U_009A() antlr.TerminalNode {
	return s.GetToken(ECLParserU_009A, 0)
}

func (s *Utf8_4Context) U_009B() antlr.TerminalNode {
	return s.GetToken(ECLParserU_009B, 0)
}

func (s *Utf8_4Context) U_009C() antlr.TerminalNode {
	return s.GetToken(ECLParserU_009C, 0)
}

func (s *Utf8_4Context) U_009D() antlr.TerminalNode {
	return s.GetToken(ECLParserU_009D, 0)
}

func (s *Utf8_4Context) U_009E() antlr.TerminalNode {
	return s.GetToken(ECLParserU_009E, 0)
}

func (s *Utf8_4Context) U_009F() antlr.TerminalNode {
	return s.GetToken(ECLParserU_009F, 0)
}

func (s *Utf8_4Context) U_00A0() antlr.TerminalNode {
	return s.GetToken(ECLParserU_00A0, 0)
}

func (s *Utf8_4Context) U_00A1() antlr.TerminalNode {
	return s.GetToken(ECLParserU_00A1, 0)
}

func (s *Utf8_4Context) U_00A2() antlr.TerminalNode {
	return s.GetToken(ECLParserU_00A2, 0)
}

func (s *Utf8_4Context) U_00A3() antlr.TerminalNode {
	return s.GetToken(ECLParserU_00A3, 0)
}

func (s *Utf8_4Context) U_00A4() antlr.TerminalNode {
	return s.GetToken(ECLParserU_00A4, 0)
}

func (s *Utf8_4Context) U_00A5() antlr.TerminalNode {
	return s.GetToken(ECLParserU_00A5, 0)
}

func (s *Utf8_4Context) U_00A6() antlr.TerminalNode {
	return s.GetToken(ECLParserU_00A6, 0)
}

func (s *Utf8_4Context) U_00A7() antlr.TerminalNode {
	return s.GetToken(ECLParserU_00A7, 0)
}

func (s *Utf8_4Context) U_00A8() antlr.TerminalNode {
	return s.GetToken(ECLParserU_00A8, 0)
}

func (s *Utf8_4Context) U_00A9() antlr.TerminalNode {
	return s.GetToken(ECLParserU_00A9, 0)
}

func (s *Utf8_4Context) U_00AA() antlr.TerminalNode {
	return s.GetToken(ECLParserU_00AA, 0)
}

func (s *Utf8_4Context) U_00AB() antlr.TerminalNode {
	return s.GetToken(ECLParserU_00AB, 0)
}

func (s *Utf8_4Context) U_00AC() antlr.TerminalNode {
	return s.GetToken(ECLParserU_00AC, 0)
}

func (s *Utf8_4Context) U_00AD() antlr.TerminalNode {
	return s.GetToken(ECLParserU_00AD, 0)
}

func (s *Utf8_4Context) U_00AE() antlr.TerminalNode {
	return s.GetToken(ECLParserU_00AE, 0)
}

func (s *Utf8_4Context) U_00AF() antlr.TerminalNode {
	return s.GetToken(ECLParserU_00AF, 0)
}

func (s *Utf8_4Context) U_00B0() antlr.TerminalNode {
	return s.GetToken(ECLParserU_00B0, 0)
}

func (s *Utf8_4Context) U_00B1() antlr.TerminalNode {
	return s.GetToken(ECLParserU_00B1, 0)
}

func (s *Utf8_4Context) U_00B2() antlr.TerminalNode {
	return s.GetToken(ECLParserU_00B2, 0)
}

func (s *Utf8_4Context) U_00B3() antlr.TerminalNode {
	return s.GetToken(ECLParserU_00B3, 0)
}

func (s *Utf8_4Context) U_00B4() antlr.TerminalNode {
	return s.GetToken(ECLParserU_00B4, 0)
}

func (s *Utf8_4Context) U_00B5() antlr.TerminalNode {
	return s.GetToken(ECLParserU_00B5, 0)
}

func (s *Utf8_4Context) U_00B6() antlr.TerminalNode {
	return s.GetToken(ECLParserU_00B6, 0)
}

func (s *Utf8_4Context) U_00B7() antlr.TerminalNode {
	return s.GetToken(ECLParserU_00B7, 0)
}

func (s *Utf8_4Context) U_00B8() antlr.TerminalNode {
	return s.GetToken(ECLParserU_00B8, 0)
}

func (s *Utf8_4Context) U_00B9() antlr.TerminalNode {
	return s.GetToken(ECLParserU_00B9, 0)
}

func (s *Utf8_4Context) U_00BA() antlr.TerminalNode {
	return s.GetToken(ECLParserU_00BA, 0)
}

func (s *Utf8_4Context) U_00BB() antlr.TerminalNode {
	return s.GetToken(ECLParserU_00BB, 0)
}

func (s *Utf8_4Context) U_00BC() antlr.TerminalNode {
	return s.GetToken(ECLParserU_00BC, 0)
}

func (s *Utf8_4Context) U_00BD() antlr.TerminalNode {
	return s.GetToken(ECLParserU_00BD, 0)
}

func (s *Utf8_4Context) U_00BE() antlr.TerminalNode {
	return s.GetToken(ECLParserU_00BE, 0)
}

func (s *Utf8_4Context) U_00BF() antlr.TerminalNode {
	return s.GetToken(ECLParserU_00BF, 0)
}

func (s *Utf8_4Context) AllUtf8_tail() []IUtf8_tailContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IUtf8_tailContext)(nil)).Elem())
	var tst = make([]IUtf8_tailContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IUtf8_tailContext)
		}
	}

	return tst
}

func (s *Utf8_4Context) Utf8_tail(i int) IUtf8_tailContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUtf8_tailContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IUtf8_tailContext)
}

func (s *Utf8_4Context) U_00F1() antlr.TerminalNode {
	return s.GetToken(ECLParserU_00F1, 0)
}

func (s *Utf8_4Context) U_00F2() antlr.TerminalNode {
	return s.GetToken(ECLParserU_00F2, 0)
}

func (s *Utf8_4Context) U_00F3() antlr.TerminalNode {
	return s.GetToken(ECLParserU_00F3, 0)
}

func (s *Utf8_4Context) U_00F4() antlr.TerminalNode {
	return s.GetToken(ECLParserU_00F4, 0)
}

func (s *Utf8_4Context) U_0080() antlr.TerminalNode {
	return s.GetToken(ECLParserU_0080, 0)
}

func (s *Utf8_4Context) U_0081() antlr.TerminalNode {
	return s.GetToken(ECLParserU_0081, 0)
}

func (s *Utf8_4Context) U_0082() antlr.TerminalNode {
	return s.GetToken(ECLParserU_0082, 0)
}

func (s *Utf8_4Context) U_0083() antlr.TerminalNode {
	return s.GetToken(ECLParserU_0083, 0)
}

func (s *Utf8_4Context) U_0084() antlr.TerminalNode {
	return s.GetToken(ECLParserU_0084, 0)
}

func (s *Utf8_4Context) U_0085() antlr.TerminalNode {
	return s.GetToken(ECLParserU_0085, 0)
}

func (s *Utf8_4Context) U_0086() antlr.TerminalNode {
	return s.GetToken(ECLParserU_0086, 0)
}

func (s *Utf8_4Context) U_0087() antlr.TerminalNode {
	return s.GetToken(ECLParserU_0087, 0)
}

func (s *Utf8_4Context) U_0088() antlr.TerminalNode {
	return s.GetToken(ECLParserU_0088, 0)
}

func (s *Utf8_4Context) U_0089() antlr.TerminalNode {
	return s.GetToken(ECLParserU_0089, 0)
}

func (s *Utf8_4Context) U_008A() antlr.TerminalNode {
	return s.GetToken(ECLParserU_008A, 0)
}

func (s *Utf8_4Context) U_008B() antlr.TerminalNode {
	return s.GetToken(ECLParserU_008B, 0)
}

func (s *Utf8_4Context) U_008C() antlr.TerminalNode {
	return s.GetToken(ECLParserU_008C, 0)
}

func (s *Utf8_4Context) U_008D() antlr.TerminalNode {
	return s.GetToken(ECLParserU_008D, 0)
}

func (s *Utf8_4Context) U_008E() antlr.TerminalNode {
	return s.GetToken(ECLParserU_008E, 0)
}

func (s *Utf8_4Context) U_008F() antlr.TerminalNode {
	return s.GetToken(ECLParserU_008F, 0)
}

func (s *Utf8_4Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Utf8_4Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Utf8_4Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ECLListener); ok {
		listenerT.EnterUtf8_4(s)
	}
}

func (s *Utf8_4Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ECLListener); ok {
		listenerT.ExitUtf8_4(s)
	}
}

func (s *Utf8_4Context) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ECLVisitor:
		return t.VisitUtf8_4(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ECLParser) Utf8_4() (localctx IUtf8_4Context) {
	localctx = NewUtf8_4Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 144, ECLParserRULE_utf8_4)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(735)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case ECLParserU_00F0:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(720)
			p.Match(ECLParserU_00F0)
		}
		{
			p.SetState(721)
			_la = p.GetTokenStream().LA(1)

			if !((((_la-115)&-(0x1f+1)) == 0 && ((1<<uint((_la-115)))&((1<<(ECLParserU_0090-115))|(1<<(ECLParserU_0091-115))|(1<<(ECLParserU_0092-115))|(1<<(ECLParserU_0093-115))|(1<<(ECLParserU_0094-115))|(1<<(ECLParserU_0095-115))|(1<<(ECLParserU_0096-115))|(1<<(ECLParserU_0097-115))|(1<<(ECLParserU_0098-115))|(1<<(ECLParserU_0099-115))|(1<<(ECLParserU_009A-115))|(1<<(ECLParserU_009B-115))|(1<<(ECLParserU_009C-115))|(1<<(ECLParserU_009D-115))|(1<<(ECLParserU_009E-115))|(1<<(ECLParserU_009F-115))|(1<<(ECLParserU_00A0-115))|(1<<(ECLParserU_00A1-115))|(1<<(ECLParserU_00A2-115))|(1<<(ECLParserU_00A3-115))|(1<<(ECLParserU_00A4-115))|(1<<(ECLParserU_00A5-115))|(1<<(ECLParserU_00A6-115))|(1<<(ECLParserU_00A7-115))|(1<<(ECLParserU_00A8-115))|(1<<(ECLParserU_00A9-115))|(1<<(ECLParserU_00AA-115))|(1<<(ECLParserU_00AB-115))|(1<<(ECLParserU_00AC-115))|(1<<(ECLParserU_00AD-115))|(1<<(ECLParserU_00AE-115))|(1<<(ECLParserU_00AF-115)))) != 0) || (((_la-147)&-(0x1f+1)) == 0 && ((1<<uint((_la-147)))&((1<<(ECLParserU_00B0-147))|(1<<(ECLParserU_00B1-147))|(1<<(ECLParserU_00B2-147))|(1<<(ECLParserU_00B3-147))|(1<<(ECLParserU_00B4-147))|(1<<(ECLParserU_00B5-147))|(1<<(ECLParserU_00B6-147))|(1<<(ECLParserU_00B7-147))|(1<<(ECLParserU_00B8-147))|(1<<(ECLParserU_00B9-147))|(1<<(ECLParserU_00BA-147))|(1<<(ECLParserU_00BB-147))|(1<<(ECLParserU_00BC-147))|(1<<(ECLParserU_00BD-147))|(1<<(ECLParserU_00BE-147))|(1<<(ECLParserU_00BF-147)))) != 0)) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

		{
			p.SetState(722)
			p.Utf8_tail()
		}

		{
			p.SetState(723)
			p.Utf8_tail()
		}

	case ECLParserU_00F1, ECLParserU_00F2, ECLParserU_00F3:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(725)
			_la = p.GetTokenStream().LA(1)

			if !(((_la-210)&-(0x1f+1)) == 0 && ((1<<uint((_la-210)))&((1<<(ECLParserU_00F1-210))|(1<<(ECLParserU_00F2-210))|(1<<(ECLParserU_00F3-210)))) != 0) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

		{
			p.SetState(726)
			p.Utf8_tail()
		}

		{
			p.SetState(727)
			p.Utf8_tail()
		}

		{
			p.SetState(728)
			p.Utf8_tail()
		}

	case ECLParserU_00F4:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(730)
			p.Match(ECLParserU_00F4)
		}
		{
			p.SetState(731)
			_la = p.GetTokenStream().LA(1)

			if !(((_la-99)&-(0x1f+1)) == 0 && ((1<<uint((_la-99)))&((1<<(ECLParserU_0080-99))|(1<<(ECLParserU_0081-99))|(1<<(ECLParserU_0082-99))|(1<<(ECLParserU_0083-99))|(1<<(ECLParserU_0084-99))|(1<<(ECLParserU_0085-99))|(1<<(ECLParserU_0086-99))|(1<<(ECLParserU_0087-99))|(1<<(ECLParserU_0088-99))|(1<<(ECLParserU_0089-99))|(1<<(ECLParserU_008A-99))|(1<<(ECLParserU_008B-99))|(1<<(ECLParserU_008C-99))|(1<<(ECLParserU_008D-99))|(1<<(ECLParserU_008E-99))|(1<<(ECLParserU_008F-99)))) != 0) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

		{
			p.SetState(732)
			p.Utf8_tail()
		}

		{
			p.SetState(733)
			p.Utf8_tail()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IUtf8_tailContext is an interface to support dynamic dispatch.
type IUtf8_tailContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUtf8_tailContext differentiates from other interfaces.
	IsUtf8_tailContext()
}

type Utf8_tailContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUtf8_tailContext() *Utf8_tailContext {
	var p = new(Utf8_tailContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = ECLParserRULE_utf8_tail
	return p
}

func (*Utf8_tailContext) IsUtf8_tailContext() {}

func NewUtf8_tailContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Utf8_tailContext {
	var p = new(Utf8_tailContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = ECLParserRULE_utf8_tail

	return p
}

func (s *Utf8_tailContext) GetParser() antlr.Parser { return s.parser }

func (s *Utf8_tailContext) U_0080() antlr.TerminalNode {
	return s.GetToken(ECLParserU_0080, 0)
}

func (s *Utf8_tailContext) U_0081() antlr.TerminalNode {
	return s.GetToken(ECLParserU_0081, 0)
}

func (s *Utf8_tailContext) U_0082() antlr.TerminalNode {
	return s.GetToken(ECLParserU_0082, 0)
}

func (s *Utf8_tailContext) U_0083() antlr.TerminalNode {
	return s.GetToken(ECLParserU_0083, 0)
}

func (s *Utf8_tailContext) U_0084() antlr.TerminalNode {
	return s.GetToken(ECLParserU_0084, 0)
}

func (s *Utf8_tailContext) U_0085() antlr.TerminalNode {
	return s.GetToken(ECLParserU_0085, 0)
}

func (s *Utf8_tailContext) U_0086() antlr.TerminalNode {
	return s.GetToken(ECLParserU_0086, 0)
}

func (s *Utf8_tailContext) U_0087() antlr.TerminalNode {
	return s.GetToken(ECLParserU_0087, 0)
}

func (s *Utf8_tailContext) U_0088() antlr.TerminalNode {
	return s.GetToken(ECLParserU_0088, 0)
}

func (s *Utf8_tailContext) U_0089() antlr.TerminalNode {
	return s.GetToken(ECLParserU_0089, 0)
}

func (s *Utf8_tailContext) U_008A() antlr.TerminalNode {
	return s.GetToken(ECLParserU_008A, 0)
}

func (s *Utf8_tailContext) U_008B() antlr.TerminalNode {
	return s.GetToken(ECLParserU_008B, 0)
}

func (s *Utf8_tailContext) U_008C() antlr.TerminalNode {
	return s.GetToken(ECLParserU_008C, 0)
}

func (s *Utf8_tailContext) U_008D() antlr.TerminalNode {
	return s.GetToken(ECLParserU_008D, 0)
}

func (s *Utf8_tailContext) U_008E() antlr.TerminalNode {
	return s.GetToken(ECLParserU_008E, 0)
}

func (s *Utf8_tailContext) U_008F() antlr.TerminalNode {
	return s.GetToken(ECLParserU_008F, 0)
}

func (s *Utf8_tailContext) U_0090() antlr.TerminalNode {
	return s.GetToken(ECLParserU_0090, 0)
}

func (s *Utf8_tailContext) U_0091() antlr.TerminalNode {
	return s.GetToken(ECLParserU_0091, 0)
}

func (s *Utf8_tailContext) U_0092() antlr.TerminalNode {
	return s.GetToken(ECLParserU_0092, 0)
}

func (s *Utf8_tailContext) U_0093() antlr.TerminalNode {
	return s.GetToken(ECLParserU_0093, 0)
}

func (s *Utf8_tailContext) U_0094() antlr.TerminalNode {
	return s.GetToken(ECLParserU_0094, 0)
}

func (s *Utf8_tailContext) U_0095() antlr.TerminalNode {
	return s.GetToken(ECLParserU_0095, 0)
}

func (s *Utf8_tailContext) U_0096() antlr.TerminalNode {
	return s.GetToken(ECLParserU_0096, 0)
}

func (s *Utf8_tailContext) U_0097() antlr.TerminalNode {
	return s.GetToken(ECLParserU_0097, 0)
}

func (s *Utf8_tailContext) U_0098() antlr.TerminalNode {
	return s.GetToken(ECLParserU_0098, 0)
}

func (s *Utf8_tailContext) U_0099() antlr.TerminalNode {
	return s.GetToken(ECLParserU_0099, 0)
}

func (s *Utf8_tailContext) U_009A() antlr.TerminalNode {
	return s.GetToken(ECLParserU_009A, 0)
}

func (s *Utf8_tailContext) U_009B() antlr.TerminalNode {
	return s.GetToken(ECLParserU_009B, 0)
}

func (s *Utf8_tailContext) U_009C() antlr.TerminalNode {
	return s.GetToken(ECLParserU_009C, 0)
}

func (s *Utf8_tailContext) U_009D() antlr.TerminalNode {
	return s.GetToken(ECLParserU_009D, 0)
}

func (s *Utf8_tailContext) U_009E() antlr.TerminalNode {
	return s.GetToken(ECLParserU_009E, 0)
}

func (s *Utf8_tailContext) U_009F() antlr.TerminalNode {
	return s.GetToken(ECLParserU_009F, 0)
}

func (s *Utf8_tailContext) U_00A0() antlr.TerminalNode {
	return s.GetToken(ECLParserU_00A0, 0)
}

func (s *Utf8_tailContext) U_00A1() antlr.TerminalNode {
	return s.GetToken(ECLParserU_00A1, 0)
}

func (s *Utf8_tailContext) U_00A2() antlr.TerminalNode {
	return s.GetToken(ECLParserU_00A2, 0)
}

func (s *Utf8_tailContext) U_00A3() antlr.TerminalNode {
	return s.GetToken(ECLParserU_00A3, 0)
}

func (s *Utf8_tailContext) U_00A4() antlr.TerminalNode {
	return s.GetToken(ECLParserU_00A4, 0)
}

func (s *Utf8_tailContext) U_00A5() antlr.TerminalNode {
	return s.GetToken(ECLParserU_00A5, 0)
}

func (s *Utf8_tailContext) U_00A6() antlr.TerminalNode {
	return s.GetToken(ECLParserU_00A6, 0)
}

func (s *Utf8_tailContext) U_00A7() antlr.TerminalNode {
	return s.GetToken(ECLParserU_00A7, 0)
}

func (s *Utf8_tailContext) U_00A8() antlr.TerminalNode {
	return s.GetToken(ECLParserU_00A8, 0)
}

func (s *Utf8_tailContext) U_00A9() antlr.TerminalNode {
	return s.GetToken(ECLParserU_00A9, 0)
}

func (s *Utf8_tailContext) U_00AA() antlr.TerminalNode {
	return s.GetToken(ECLParserU_00AA, 0)
}

func (s *Utf8_tailContext) U_00AB() antlr.TerminalNode {
	return s.GetToken(ECLParserU_00AB, 0)
}

func (s *Utf8_tailContext) U_00AC() antlr.TerminalNode {
	return s.GetToken(ECLParserU_00AC, 0)
}

func (s *Utf8_tailContext) U_00AD() antlr.TerminalNode {
	return s.GetToken(ECLParserU_00AD, 0)
}

func (s *Utf8_tailContext) U_00AE() antlr.TerminalNode {
	return s.GetToken(ECLParserU_00AE, 0)
}

func (s *Utf8_tailContext) U_00AF() antlr.TerminalNode {
	return s.GetToken(ECLParserU_00AF, 0)
}

func (s *Utf8_tailContext) U_00B0() antlr.TerminalNode {
	return s.GetToken(ECLParserU_00B0, 0)
}

func (s *Utf8_tailContext) U_00B1() antlr.TerminalNode {
	return s.GetToken(ECLParserU_00B1, 0)
}

func (s *Utf8_tailContext) U_00B2() antlr.TerminalNode {
	return s.GetToken(ECLParserU_00B2, 0)
}

func (s *Utf8_tailContext) U_00B3() antlr.TerminalNode {
	return s.GetToken(ECLParserU_00B3, 0)
}

func (s *Utf8_tailContext) U_00B4() antlr.TerminalNode {
	return s.GetToken(ECLParserU_00B4, 0)
}

func (s *Utf8_tailContext) U_00B5() antlr.TerminalNode {
	return s.GetToken(ECLParserU_00B5, 0)
}

func (s *Utf8_tailContext) U_00B6() antlr.TerminalNode {
	return s.GetToken(ECLParserU_00B6, 0)
}

func (s *Utf8_tailContext) U_00B7() antlr.TerminalNode {
	return s.GetToken(ECLParserU_00B7, 0)
}

func (s *Utf8_tailContext) U_00B8() antlr.TerminalNode {
	return s.GetToken(ECLParserU_00B8, 0)
}

func (s *Utf8_tailContext) U_00B9() antlr.TerminalNode {
	return s.GetToken(ECLParserU_00B9, 0)
}

func (s *Utf8_tailContext) U_00BA() antlr.TerminalNode {
	return s.GetToken(ECLParserU_00BA, 0)
}

func (s *Utf8_tailContext) U_00BB() antlr.TerminalNode {
	return s.GetToken(ECLParserU_00BB, 0)
}

func (s *Utf8_tailContext) U_00BC() antlr.TerminalNode {
	return s.GetToken(ECLParserU_00BC, 0)
}

func (s *Utf8_tailContext) U_00BD() antlr.TerminalNode {
	return s.GetToken(ECLParserU_00BD, 0)
}

func (s *Utf8_tailContext) U_00BE() antlr.TerminalNode {
	return s.GetToken(ECLParserU_00BE, 0)
}

func (s *Utf8_tailContext) U_00BF() antlr.TerminalNode {
	return s.GetToken(ECLParserU_00BF, 0)
}

func (s *Utf8_tailContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Utf8_tailContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Utf8_tailContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ECLListener); ok {
		listenerT.EnterUtf8_tail(s)
	}
}

func (s *Utf8_tailContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ECLListener); ok {
		listenerT.ExitUtf8_tail(s)
	}
}

func (s *Utf8_tailContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ECLVisitor:
		return t.VisitUtf8_tail(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ECLParser) Utf8_tail() (localctx IUtf8_tailContext) {
	localctx = NewUtf8_tailContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 146, ECLParserRULE_utf8_tail)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(737)
		_la = p.GetTokenStream().LA(1)

		if !((((_la-99)&-(0x1f+1)) == 0 && ((1<<uint((_la-99)))&((1<<(ECLParserU_0080-99))|(1<<(ECLParserU_0081-99))|(1<<(ECLParserU_0082-99))|(1<<(ECLParserU_0083-99))|(1<<(ECLParserU_0084-99))|(1<<(ECLParserU_0085-99))|(1<<(ECLParserU_0086-99))|(1<<(ECLParserU_0087-99))|(1<<(ECLParserU_0088-99))|(1<<(ECLParserU_0089-99))|(1<<(ECLParserU_008A-99))|(1<<(ECLParserU_008B-99))|(1<<(ECLParserU_008C-99))|(1<<(ECLParserU_008D-99))|(1<<(ECLParserU_008E-99))|(1<<(ECLParserU_008F-99))|(1<<(ECLParserU_0090-99))|(1<<(ECLParserU_0091-99))|(1<<(ECLParserU_0092-99))|(1<<(ECLParserU_0093-99))|(1<<(ECLParserU_0094-99))|(1<<(ECLParserU_0095-99))|(1<<(ECLParserU_0096-99))|(1<<(ECLParserU_0097-99))|(1<<(ECLParserU_0098-99))|(1<<(ECLParserU_0099-99))|(1<<(ECLParserU_009A-99))|(1<<(ECLParserU_009B-99))|(1<<(ECLParserU_009C-99))|(1<<(ECLParserU_009D-99))|(1<<(ECLParserU_009E-99))|(1<<(ECLParserU_009F-99)))) != 0) || (((_la-131)&-(0x1f+1)) == 0 && ((1<<uint((_la-131)))&((1<<(ECLParserU_00A0-131))|(1<<(ECLParserU_00A1-131))|(1<<(ECLParserU_00A2-131))|(1<<(ECLParserU_00A3-131))|(1<<(ECLParserU_00A4-131))|(1<<(ECLParserU_00A5-131))|(1<<(ECLParserU_00A6-131))|(1<<(ECLParserU_00A7-131))|(1<<(ECLParserU_00A8-131))|(1<<(ECLParserU_00A9-131))|(1<<(ECLParserU_00AA-131))|(1<<(ECLParserU_00AB-131))|(1<<(ECLParserU_00AC-131))|(1<<(ECLParserU_00AD-131))|(1<<(ECLParserU_00AE-131))|(1<<(ECLParserU_00AF-131))|(1<<(ECLParserU_00B0-131))|(1<<(ECLParserU_00B1-131))|(1<<(ECLParserU_00B2-131))|(1<<(ECLParserU_00B3-131))|(1<<(ECLParserU_00B4-131))|(1<<(ECLParserU_00B5-131))|(1<<(ECLParserU_00B6-131))|(1<<(ECLParserU_00B7-131))|(1<<(ECLParserU_00B8-131))|(1<<(ECLParserU_00B9-131))|(1<<(ECLParserU_00BA-131))|(1<<(ECLParserU_00BB-131))|(1<<(ECLParserU_00BC-131))|(1<<(ECLParserU_00BD-131))|(1<<(ECLParserU_00BE-131))|(1<<(ECLParserU_00BF-131)))) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}
